[{"title":"Node派生类的遍历等","date":"2021-09-14T11:03:17.002Z","path":"2021/09/14/Node派生类的遍历等/","text":"需求背景需求是这样的，需要用一个几何体，在一个体元素中提取一部分的插值结果。自然是没有现成的算法。实现的过程中，就需要对Geode、Geometry进行遍历。由于我之前编译帮助文档失败了，虽然OSG版本是3.6.5的，但是帮助文档的版本却是2.9.11的。一些方法还是有出入的。所以记录一下 遍历Geode内的Geometry1234cout &lt;&lt; &quot;Geode2的数量&quot; &lt;&lt; this-&gt;temp_gde-&gt;getNumChildren() &lt;&lt; endl;for (unsigned int i = 0; i &lt; this-&gt;temp_gde-&gt;getNumDrawables(); i++) &#123; osg::ref_ptr&lt;osg::Geometry&gt; pgeo = this-&gt;temp_gde-&gt;getDrawable(i)-&gt;asGeometry();&#125; getNumChildren()和getNumDrawables()的值是一样的。不知道是不是巧合","tags":[]},{"title":"矩阵 平移旋转","date":"2021-08-28T09:55:03.768Z","path":"2021/08/28/矩阵 平移旋转/","text":"简单操作步骤： 先实例化一个node，平移到x正轴的5 1234567osg::ref_ptr&lt;osg::Group&gt; group = new osg::Group;osg::ref_ptr&lt;osg::MatrixTransform&gt; max = new osg::MatrixTransform;osg::ref_ptr&lt;osg::Node&gt; node = osgDB::readNodeFile(&quot;glider.osg&quot;);max-&gt;addChild(node.get());max-&gt;setMatrix(osg::Matrix::translate(5.0, 0.0, 0.0));group-&gt;addChild(osgDB::readNodeFile(&quot;glider.osg&quot;)); 给max一个旋转状态，让小飞机绕着Z轴在(0.0, 0.0, 0.0)点旋转，角速度为1。 1max-&gt;setUpdateCallback(new osg::AnimationPathCallback(osg::Vec3(0.0, 0.0, 0.0), osg::Z_AXIS, 1.0)); 理想状态下，应该是有一个小飞机在(5.0, 0.0, 0.0)这个位置上原地旋转： 结果 =》明显是失败了 分析一下原因 这里有一个知识点，Callback的方法会覆盖掉前面的矩阵平移的操作。 有人要说了，那给旋转操作和矩阵操作换一下位置，后执行平移操作。结果当然是不行的，这里的setXXX相当于设置的属性，而不是操作函数。影响是整个属性的对象。换言之，只有他们不是一个对象就不会覆盖掉了 重新创建一个max2对象，给它一个平移操作；给max对象一个旋转操作；再将max2对象添加给max对象。 1234567osg::ref_ptr&lt;osg::Node&gt; node = osgDB::readNodeFile(&quot;glider.osg&quot;);osg::ref_ptr&lt;osg::MatrixTransform&gt; max2 = new osg::MatrixTransform;max2-&gt;addChild(node.get());max2-&gt;setMatrix(osg::Matrix::translate(5.0, 0.0, 0.0));max-&gt;setUpdateCallback(new osg::AnimationPathCallback(osg::Vec3(5.0, 0.0, 0.0), osg::Z_AXIS, 1.0));max-&gt;addChild(max2.get()); 看一下结果 完整代码 123456789osg::ref_ptr&lt;osg::MatrixTransform&gt; max3 = new osg::MatrixTransform;osg::ref_ptr&lt;osg::MatrixTransform&gt; max4 = new osg::MatrixTransform;max4-&gt;addChild(node.get());max4-&gt;setMatrix(osg::Matrix::translate(-5.0, 0.0, 0.0));max3-&gt;setUpdateCallback(new osg::AnimationPathCallback(osg::Vec3(-5.0, 0.0, 0.0), osg::Z_AXIS, 1.0));max3-&gt;addChild(max4.get());group-&gt;addChild(max3.get()); 完整代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;osgDB/ReadFile&gt;#include &lt;osgGA/GUIEventAdapter&gt;#include &lt;osgViewer/ViewerEventHandlers&gt;#include &lt;osg/MatrixTransform&gt;#include &lt;iostream&gt;using namespace std;osg::ref_ptr&lt;osg::Node&gt; MatrixOperation() &#123; osg::ref_ptr&lt;osg::Group&gt; group = new osg::Group; osg::ref_ptr&lt;osg::MatrixTransform&gt; max = new osg::MatrixTransform; osg::ref_ptr&lt;osg::Node&gt; node = osgDB::readNodeFile(&quot;glider.osg&quot;); osg::ref_ptr&lt;osg::MatrixTransform&gt; max2 = new osg::MatrixTransform; osg::ref_ptr&lt;osg::MatrixTransform&gt; max3 = new osg::MatrixTransform; osg::ref_ptr&lt;osg::MatrixTransform&gt; max4 = new osg::MatrixTransform; max2-&gt;addChild(node.get()); max2-&gt;setMatrix(osg::Matrix::translate(5.0, 0.0, 0.0)); max-&gt;setUpdateCallback(new osg::AnimationPathCallback(osg::Vec3(5.0, 0.0, 0.0), osg::Z_AXIS, 1.0)); max-&gt;addChild(max2.get()); max4-&gt;addChild(node.get()); max4-&gt;setMatrix(osg::Matrix::translate(-5.0, 0.0, 0.0)); max3-&gt;setUpdateCallback(new osg::AnimationPathCallback(osg::Vec3(-5.0, 0.0, 0.0), osg::Z_AXIS, 1.0)); max3-&gt;addChild(max4.get()); group-&gt;addChild(node.get()); group-&gt;addChild(max.get()); group-&gt;addChild(max3.get()); return group;&#125;int main() &#123; osg::ref_ptr&lt;osgViewer::Viewer&gt; viewer = new osgViewer::Viewer; viewer-&gt;setSceneData(MatrixOperation().get()); viewer-&gt;run(); return 0;&#125; ​","tags":[]},{"title":"OSG学习中的一些小问题","date":"2021-08-20T15:42:31.028Z","path":"2021/08/20/OSG学习中的一些小问题/","text":"今天尝试叠加几何体，却出现了重叠，缝隙的问题。 思考一番后发现忽略了一些问题，圆柱体的中心点在xyz的半值。不在底部或者顶部。","tags":[]},{"title":"基础图元 简单矢量","date":"2021-08-19T12:26:55.114Z","path":"2021/08/19/基础图元 简单矢量/","text":"创建简单矢量图基础：OSG坐标系，与笛卡尔三维坐标系方向相同 步骤： 申请顶点数组，设置垂直xoy面的正方形的四个顶点 123456osg::ref_ptr&lt;osg::Vec3Array&gt; coords = new osg::Vec3Array;coords-&gt;push_back(osg::Vec3(-10.0, 5.0, -10.0));coords-&gt;push_back(osg::Vec3(10.0, 5.0, -10.0));coords-&gt;push_back(osg::Vec3(10.0, 5.0, 10.0));coords-&gt;push_back(osg::Vec3(-10.0, 5.0, 10.0)); 申请颜色数组，设置半透明的颜色组 123456osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array;colors-&gt;push_back(osg::Vec4f(1.0, 0.0, 0.0, 0.5));colors-&gt;push_back(osg::Vec4f(0.0, 1.0, 0.0, 0.5));colors-&gt;push_back(osg::Vec4f(0.0, 0.0, 1.0, 0.5));colors-&gt;push_back(osg::Vec4f(1.0, 1.0, 0.0, 0.5)); 申请法向量，令光源在正方形的一侧，压入一个法向量 123osg::ref_ptr&lt;osg::Vec3Array&gt; norms = new osg::Vec3Array;norms-&gt;push_back(osg::Vec3(0.0, -1.0, 0.0)); 申请一个几何Geometry 1osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; 设置顶点和顶点的关联方式 12geom-&gt;setVertexArray(coords.get());geom-&gt;addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::Mode::QUADS, 0, 4)); 设置顶点颜色 12geom-&gt;setColorArray(colors.get());geom-&gt;setColorBinding(osg::Geometry::AttributeBinding::BIND_PER_VERTEX); 设置法向量 12geom-&gt;setNormalArray(norms.get());geom-&gt;setNormalBinding(osg::Geometry::AttributeBinding::BIND_OVERALL); 申请一个Geode 1osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; 在Geode中绘制几何，打开透明 12geode-&gt;addDrawable(geom.get());geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_BLEND, osg::StateAttribute::ON); 将上一节中main函数中的CreateBox()改为CreateSimple()，运行 申请一个限制线宽 1osg::ref_ptr&lt;osg::LineWidth&gt; width = new osg::LineWidth; 将顶点关联方式改为LINE_LOOP 1geom-&gt;addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::Mode::LINE_LOOP, 0, 4)); 设置线宽 1width-&gt;setWidth(5.0); 运行，查看结果 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;osgViewer/Viewer&gt;#include &lt;osgDB/ReadFile&gt;#include &lt;osgGA/GUIEventAdapter&gt;#include &lt;osgViewer/ViewerEventHandlers&gt;#include &lt;osg/Geode&gt;#include &lt;osg/ShapeDrawable&gt;#include &lt;osg/Material&gt;#include &lt;osg/StateSet&gt;#include &lt;osg/Image&gt;#include &lt;osg/Texture2D&gt;#include &lt;osg/LineWidth&gt;#include &lt;iostream&gt;using namespace std;osg::ref_ptr&lt;osg::Geode&gt; CreateSimple() &#123; osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; osg::ref_ptr&lt;osg::Vec3Array&gt; coords = new osg::Vec3Array; osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; osg::ref_ptr&lt;osg::Vec3Array&gt; norms = new osg::Vec3Array; osg::ref_ptr&lt;osg::LineWidth&gt; width = new osg::LineWidth; geode-&gt;addDrawable(geom.get()); geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_BLEND, osg::StateAttribute::ON); geom-&gt;setVertexArray(coords.get()); geom-&gt;addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::Mode::LINE_LOOP, 0, 4)); geom-&gt;setColorArray(colors.get()); geom-&gt;setColorBinding(osg::Geometry::AttributeBinding::BIND_PER_VERTEX); geom-&gt;setNormalArray(norms.get()); geom-&gt;setNormalBinding(osg::Geometry::AttributeBinding::BIND_OVERALL); width-&gt;setWidth(5.0); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(width.get(), osg::StateAttribute::ON); coords-&gt;push_back(osg::Vec3(-10.0, 5.0, -10.0)); coords-&gt;push_back(osg::Vec3(10.0, 5.0, -10.0)); coords-&gt;push_back(osg::Vec3(10.0, 5.0, 10.0)); coords-&gt;push_back(osg::Vec3(-10.0, 5.0, 10.0)); colors-&gt;push_back(osg::Vec4f(1.0, 0.0, 0.0, 0.5)); colors-&gt;push_back(osg::Vec4f(0.0, 1.0, 0.0, 0.5)); colors-&gt;push_back(osg::Vec4f(0.0, 0.0, 1.0, 0.5)); colors-&gt;push_back(osg::Vec4f(1.0, 1.0, 0.0, 0.5)); norms-&gt;push_back(osg::Vec3(0.0, -1.0, 0.0)); return geode;&#125;int main() &#123; osg::ref_ptr&lt;osgViewer::Viewer&gt; viewer = new osgViewer::Viewer; osg::ref_ptr&lt;osg::Group&gt; group = new osg::Group; group-&gt;addChild(CreateSimple()); viewer-&gt;setSceneData(group.get()); return viewer-&gt;run();&#125; ​","tags":[]},{"title":"基础图元 Box","date":"2021-08-19T11:57:15.424Z","path":"2021/08/19/基础图元 Box/","text":"创建一个长方体（Box）效果图： 步骤： 申请一个精度 123osg::ref_ptr&lt;osg::TessellationHints&gt; hints = new osg::TessellationHints;hints-&gt;setDetailRatio(0.5); 申请一个Shape（需要赋值精细度） 1234osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape = new osg::ShapeDrawable(new osg::Box(osg::Vec3(0.0, 0.0, 0.0), 1.0, 10.0, 10.0), hints.get());//赋值为灰色，半透明shape-&gt;setColor(osg::Vec4(0.5, 0.5, 0.5, 0.5)); 申请一个材质 123456osg::ref_ptr&lt;osg::Material&gt; material = new osg::Material;material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4f(1.0, 1.0, 1.0, 0.5));material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4f(1.0, 1.0, 1.0, 0.5));material-&gt;setSpecular(osg::Material::FRONT_AND_BACK, osg::Vec4f(1.0, 1.0, 1.0, 0.5));material-&gt;setShininess(osg::Material::FRONT_AND_BACK, 6.0); 申请一个纹理和Image 12345678osg::ref_ptr&lt;osg::Texture2D&gt; texture2D = new osg::Texture2D;osg::ref_ptr&lt;osg::Image&gt; image = new osg::Image;image = osgDB::readImageFile(&quot;Images/whitemetal_diffuse.jpg&quot;);if (image.valid()) &#123; texture2D-&gt;setImage(image.get());&#125; 申请一个Geode作为函数返回值 123456osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode;geode-&gt;getOrCreateStateSet()-&gt;setAssociatedModes(material.get(), osg::StateAttribute::ON);geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON);geode-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture2D.get(), osg::StateAttribute::ON); 在geode中绘制shape 1geode-&gt;addDrawable(shape.get()); 将返回的Geode添加到group中 1group-&gt;addChild(CreateBox()); 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;osgViewer/Viewer&gt;#include &lt;osgDB/ReadFile&gt;#include &lt;osgGA/GUIEventAdapter&gt;#include &lt;osgViewer/ViewerEventHandlers&gt;#include &lt;osg/Geode&gt;#include &lt;osg/ShapeDrawable&gt;#include &lt;osg/Material&gt;#include &lt;osg/StateSet&gt;#include &lt;osg/Image&gt;#include &lt;osg/Texture2D&gt;#include &lt;iostream&gt;using namespace std;osg::ref_ptr&lt;osg::Geode&gt; CreateBox() &#123; osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; osg::ref_ptr&lt;osg::TessellationHints&gt; hints = new osg::TessellationHints; osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape = new osg::ShapeDrawable(new osg::Box(osg::Vec3(0.0, 0.0, 0.0), 1.0, 10.0, 10.0), hints.get()); osg::ref_ptr&lt;osg::Material&gt; material = new osg::Material; osg::ref_ptr&lt;osg::Texture2D&gt; texture2D = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = new osg::Image; hints-&gt;setDetailRatio(0.5); shape-&gt;setColor(osg::Vec4(0.5, 0.5, 0.5, 0.5)); material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4f(1.0, 1.0, 1.0, 0.5)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4f(1.0, 1.0, 1.0, 0.5)); material-&gt;setSpecular(osg::Material::FRONT_AND_BACK, osg::Vec4f(1.0, 1.0, 1.0, 0.5)); material-&gt;setShininess(osg::Material::FRONT_AND_BACK, 6.0); image = osgDB::readImageFile(&quot;Images/whitemetal_diffuse.jpg&quot;); if (image.valid()) &#123; texture2D-&gt;setImage(image.get()); &#125; //set state geode-&gt;getOrCreateStateSet()-&gt;setAssociatedModes(material.get(), osg::StateAttribute::ON); geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_BLEND, osg::StateAttribute::ON); geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON); geode-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture2D.get(), osg::StateAttribute::ON); geode-&gt;addDrawable(shape.get()); return geode;&#125;int main() &#123; osg::ref_ptr&lt;osgViewer::Viewer&gt; viewer = new osgViewer::Viewer; osg::ref_ptr&lt;osg::Group&gt; group = new osg::Group; group-&gt;addChild(CreateBox()); viewer-&gt;setSceneData(group.get()); return viewer-&gt;run();&#125;","tags":[]},{"title":"OSG的HelloWorld","date":"2021-08-19T10:43:44.583Z","path":"2021/08/19/OSG的HelloWorld/","text":"加载一个飞机模型 直接上代码： 12345678#include &lt;osgViewer/Viewer&gt;#include &lt;osgDB/ReadFile&gt;int main() &#123; osg::ref_ptr&lt;osgViewer::Viewer&gt; viewer = new osgViewer::Viewer; viewer-&gt;setSceneData(osgDB::readNodeFile(&quot;glider.osg&quot;)); return viewer-&gt;run();&#125; 看看结果 代码很好理解，首先引入了类库，在main函数中，初始化了一个viewer，在这里使用的是osg中的超级指针（还不是很懂），随后给这个viewer设置了sceneData，设置的数据是打开了一个飞机的osg文件，最后就是渲染整个场景了。 与之前接触的Cesium的一些定义是类似的，比如Viewer和Scene。 添加一些帮助事件 cmd中使用osgviewer glider.osg跑的程序，自带了一些基础功能，例如缩放、帮助、全屏、显示帧速等等。 我们写的程序则是没有键盘事件的，但是保留了缩放、旋转的功能。 先添加一些键盘的监听事件 12345678#include &lt;osgViewer/ViewerEventHandlers&gt; //添加帮助事件 viewer-&gt;addEventHandler(new osgViewer::HelpHandler); viewer-&gt;addEventHandler(new osgViewer::StatsHandler); viewer-&gt;addEventHandler(new osgViewer::WindowSizeHandler); viewer-&gt;addEventHandler(new osgViewer::ScreenCaptureHandler); viewer-&gt;addEventHandler(new osgViewer::RecordCameraPathHandler); 现在运行，就会发现s、f、h都已经有了相应的功能。如果没有反应，检查键盘是不是选择的英语（美国）,正确显示如下图。 win10似乎是需要自己添加的。 自定义一个帮助事件 这里参考源码中定义帮助页中的行规则 模拟一个事件类，注意定义的命名空间应尽可能的不与osg官方定义冲突。 1234567class PrintName : public osgGA::GUIEventHandler &#123;public: virtual void getUsage(osg::ApplicationUsage&amp; usage) const &#123; //eno为快捷键名称，emm...为对应的快捷键说明 usage.addKeyboardMouseBinding(&quot;eno&quot;, &quot;emm.......&quot;); &#125;&#125;; 给viewer添加帮助事件 1viewer-&gt;addEventHandler(new PrintName); OK，来看看结果，自定义的eno已经添加进去了。似乎还挺有趣 添加一个定时器，计算一下读取模型的时间 我们加载模型的方式需要改变一下 123456// oldviewer-&gt;setSceneData(osgDB::readNodeFile(&quot;glider.osg&quot;));// newosg::ref_ptr&lt;osg::Node&gt; node = new osg::Node;node = osgDB::readNodeFile(&quot;glider.osg&quot;);viewer-&gt;setSceneData(node.get()); 申请一个定时器类，两个时间类。这里的Timer_t相当于long long 123osg::Timer* timer = new osg::Timer;osg::Timer_t start_time = 0;osg::Timer_t end_time = 0; 计算时间 12345678#include &lt;iostream&gt;using namespace std;start_time = timer-&gt;tick();node = osgDB::readNodeFile(&quot;glider.osg&quot;);end_time = timer-&gt;tick();cout &lt;&lt; &quot;01.模型读取时间为：&quot; &lt;&lt; timer-&gt;delta_s(start_time, end_time) &lt;&lt; endl; 结果 看看另一种方法，定义两个单精度时间变量 12float start_time_f = 0;float end_time_f = 0; 计算时间 12345start_time_f = viewer-&gt;elapsedTime();node = osgDB::readNodeFile(&quot;glider.osg&quot;);end_time_f = viewer-&gt;elapsedTime();cout &lt;&lt; &quot;02.模型读取时间为：&quot; &lt;&lt; end_time_f - start_time_f &lt;&lt; endl; 看看结果 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;osgViewer/Viewer&gt;#include &lt;osgDB/ReadFile&gt;#include &lt;osgViewer/ViewerEventHandlers&gt;#include &lt;iostream&gt;using namespace std;class PrintName : public osgGA::GUIEventHandler &#123;public: virtual void getUsage(osg::ApplicationUsage&amp; usage) const &#123; usage.addKeyboardMouseBinding(&quot;eno&quot;, &quot;emm.......&quot;); &#125;&#125;;int main() &#123; osg::ref_ptr&lt;osgViewer::Viewer&gt; viewer = new osgViewer::Viewer; osg::ref_ptr&lt;osg::Node&gt; node = new osg::Node; osg::Timer* timer = new osg::Timer; osg::Timer_t start_time = 0; osg::Timer_t end_time = 0; float start_time_f = 0; float end_time_f = 0; start_time = timer-&gt;tick(); start_time_f = viewer-&gt;elapsedTime(); node = osgDB::readNodeFile(&quot;glider.osg&quot;); end_time_f = viewer-&gt;elapsedTime(); end_time = timer-&gt;tick(); cout &lt;&lt; &quot;01.模型读取时间为：&quot; &lt;&lt; timer-&gt;delta_s(start_time, end_time) &lt;&lt; endl; cout &lt;&lt; &quot;02.模型读取时间为：&quot; &lt;&lt; end_time_f - start_time_f &lt;&lt; endl; viewer-&gt;addEventHandler(new PrintName); viewer-&gt;addEventHandler(new osgViewer::HelpHandler); viewer-&gt;addEventHandler(new osgViewer::StatsHandler); viewer-&gt;addEventHandler(new osgViewer::WindowSizeHandler); viewer-&gt;addEventHandler(new osgViewer::ScreenCaptureHandler); viewer-&gt;addEventHandler(new osgViewer::RecordCameraPathHandler); viewer-&gt;setSceneData(node.get()); return viewer-&gt;run();&#125;","tags":[]},{"title":"OSG的VS环境配置","date":"2021-08-19T09:56:06.490Z","path":"2021/08/19/OSG的VS环境配置/","text":"配置VS环境 笔者使用的是vs2019+osg3.6.4的环境 项目右键，打开属性，选择VC++目录，给可执行文件目录添加路径为osg下面的bin，包含目录添加路径为osg下面的include，库目录添加为osg下面的lib目录。 在链接器—》输入—》附加依赖性中添加以下类库 123456789osgd.libosgUtild.libosgGAd.libosgViewerd.libOpenThreadsd.libosgAnimationd.libosgDBd.libosgEarthd.libosgParticled.lib 在链接器—》高级—-》目标计算机中选择一下。 一般是没有问题的 1264位：MachineX64 (/MACHINE:X64)32位：MachineX86 (/MACHINE:X86) 在属性页的配置后面的下拉框中选择release重复设置一下以上的步骤。 在VS主页上，64位将编译环境选为x64，32位选择x32","tags":[]},{"title":"OSG一些基础","date":"2021-08-19T09:29:15.878Z","path":"2021/08/19/OSG一些基础/","text":"场景节点树 节点关系图 osg::Groupgroup里有addChild()这个函数，可以添加子节点到group下面，Node则没有这个 osg::MatrixTransform可以设置一些矩阵的变换。旋转、缩放、平移之类的操作 osg::AtuoTransform一些自动的矩阵。自动缩放、自动旋转、朝着屏幕、朝着相机之类的操作 osg::PositionAttitudeTransform设置位置","tags":[]},{"title":"河南强降雨相关分析（更新ing）","date":"2021-07-27T13:17:17.927Z","path":"2021/07/27/河南强降雨相关分析（更新ing）/","text":"强降雨中心形成原因 台风“烟花” 我国当前为季风气候，偏东风盛行（正东左右45度角以内吹来的风），即使“烟花”距离还有近一千公里，但水汽已经在负热带高气压带下沉气流共同作用下，被偏东风送进了河南地区，大量水汽集结，使河南具备了强降雨的条件之一 地区原因 西太平洋副热带高压近期在日本海，大陆高压近期在中国西北地区，加上台风烟花形成三足鼎立的局面，阻挡了上游系统游动，也就导致了“烟花“的水汽不能去东西两个北上的方向，西风带低值系统在华北、黄淮地区长时间维持，”烟花“的水汽只能沿着华中华北地区北上，河南是必经之路 水汽聚集 受到东风急流及稳定的低涡切变影响，加上北有太行山，西有伏牛山的特殊地形对偏东气流的强辐合抬升效应，形成地形雨。 即使水汽运输了小一千公里，水汽的量远不如”烟花“近处的水汽量，但受地势影像，气流向低压区汇聚而上升，水汽都聚在了一起，四周水汽一起形成降雨，而将与中心就是位于太行山和伏牛山交界点的河南中西部，便有了强降雨中心 持续之久 西太平洋副热带高压、大陆高压和”烟花“形成的三角局面，使得整体的大气环流形势变得异常稳定。三处高压区域将水汽锁在了河南地区。”烟花“靠近我国后，干扰先有的大气环流方向，这样一来，就会破坏掉之前稳定的大气环流，影响河南水汽的来源，河南的强降雨才能停止或者转移北上到其他地区 由于降水持续时间比较长，且强降水发生的区域比较集中，造成西部、西北部山区山洪、地质灾害风险明显增高，黄河流域、海河流域中小河流、水库水位迅速上涨，另外还造成了大范围城市内涝、农田积涝。 降雨特点 持续时间长。 7月17日开始河南省，河南省西部、中西部地区连续四天出现大范围强降水天气，并且强降水仍将持续。 累积雨量大。 全省平均降雨量113.5毫米,郑州、焦作、新乡平均降水量分别为：357毫米、210.6毫米、194.5毫米。最大降水量出现在荥阳市环翠峪728.0毫米。 强降水范围广。 全省共有4098个雨量站降水量超过50毫米，大于100毫米的有1923个，大于250毫米的有606个。 强降水时段集中。 强降水时段主要从18日夜间开始，北部、中部、西部地区普降暴雨、大暴雨，局地特大暴雨。 具有极端性。 嵩山、偃师、新密、伊川、登封等5个站点突破建站以来日降水量历史极值。嵩山、巩义、新密、偃师、登封等5个站点突破建站以来 3 日累计降水量历史极值","tags":[]},{"title":"河南暴雨数据及灾害消息统计（截至7.22）","date":"2021-07-22T13:49:53.513Z","path":"2021/07/22/河南暴雨数据及灾害消息统计（截至7.22）/","text":"数据来自网络 数据统计7月19日08时-20日08时 全国降水实况图 7月19日08时-20日08时 河南降水量实况图 该图如果无法加载请访问在线地址：https://img1.mydrivers.com/img/20210721/a5961e28c2e2425ebaad421449f6c24b.gif 河南省各市降雨过程 2021.7.20 郑州市各区县降雨量 /代表缺值 时间\\降雨量(mm) 巩义市 登封市 荥阳市 上街区 新密市 郑州市区 新郑市 中牟县 0时 10 25 10 / 10 10 25 25 1时 50 50 25 / 10 25 10 10 2时 50 50 25 / 10 25 10 10 3时 50 50 50 / 50 50 10 10 4时 50 25 25 / 50 10 10 25 5时 50 10 10 / 75 10 10 50 6时 50 25 25 / 75 50 10 10 7时 50 25 50 / 50 25 10 10 8时 50 25 50 / 50 25 10 10 9时 10 / 25 / 10 300 10 10 10时 10 / 25 / 10 50 10 10 时 10 / 10 / 25 50 10 25 12时 10 / 25 / 50 25 50 25 13时 10 / 10 / 25 50 10 50 14时 10 / 10 / 10 25 10 10 15时 10 / 10 / 10 25 10 10 16时 10 / 10 / 10 25 25 10 17时 10 / 10 / 10 25 50 10 18时 10 / 10 / 25 10 10 10 19时 10 / 10 / 10 25 25 10 20时 10 / 25 / 25 25 25 10 21时 10 / 25 / 10 25 10 25 22时 10 / 10 / 10 10 10 10 23时 10 / 10 / 10 10 10 10 24时 (21日0时) 10 / 10 / 10 10 10 10 影像整理 图片、视频资源来自微信，不可引用请访问链接 卫星：高分三号、高分六号、风云四号B星 高分三号卫星拍摄于6月9日: 高分三号卫星拍摄于7月20日 高分三号卫星拍摄于7月20日，圈中郑州北边黄河北岸部分被淹 风云四号B星快速成像仪获取的河南及周边地区7月21日上午10：30（UTC时间2：30）高分辨率影像。(中国航天科技集团八院供图) 风云四号B星一分钟快速扫描河南暴雨情况。（视频来源：国家卫星气象中心） 视频地址1：http://mpvideo.qpic.cn/0bf23qaaaaaa24adk3xyxbqfbxgdadoaaaaa.f10002.mp4?dis_k=b1d8128f4a85b05864ccac13dec84b15&amp;dis_t=1626938761&amp;spec_id=MzA4MzMyMzkwNQ%3D%3D1626939070&amp;vid=wxv_1967748870428213252&amp;format_id=10002 视频地址2：http://mpvideo.qpic.cn/0b7854aacaaaemadj4pyvbqfb36dahxqaaia.f10002.mp4?dis_k=5fd24aae47607ab72d16fa0432c09b05&amp;dis_t=1626938761&amp;spec_id=MzA4MzMyMzkwNQ%3D%3D1626939070&amp;vid=wxv_1967752116148420609&amp;format_id=10002 今年第7号台风风云四号B星一分钟快速扫描，（来源：国家卫星气象中心） 视频地址：http://mpvideo.qpic.cn/0bf2yuaaaaaa3madnwhyxfqfbrodadcqaaaa.f10002.mp4?dis_k=a6ca84432441757df52241906c5bff5d&amp;dis_t=1626938761&amp;spec_id=MzA4MzMyMzkwNQ%3D%3D1626939071&amp;vid=wxv_1967753484397494277&amp;format_id=10002 微博信息整理2021.7.197月19日 08:44：郑州气象【雨情】07月18日06时至19日06时，我市出现阵雨、雷阵雨，局部暴雨，雨量分布不均。最大降水量出现在巩义市的四初中97.5毫米。降水量在50-99.9毫米的站点有33个，25-49.9毫米的站点有68个，10-24.9毫米的站点有50个。雨量较大的站点有（毫米）：郑州的林科所54.1、市政府50.7、中原区政府47.8、姚桥47.6、尖岗水库45.5；巩义市的四初中97.5、南岭新村90.1、巩义蝴蝶谷73.8、慈云寺72.0、巩义紫荆70.3；登封市的大冶89.8、佛垌水库89.5、西燕村水库63.3；荥阳市的石板沟82.7、环翠峪77.9、刘河陈家岗52.9；新密市的白寨60.2、牛店59.3、牌坊沟54.5；新郑市的郭店农业园54.0、后湖53.9；中牟县的赵口45.4、东枫杨40.0；航空港区的八岗14.5、三官庙12.5。【天气预报】今天白天：阴天有阵雨、雷阵雨，局地有短时强降水；今天夜里：阴天有中阵雨、雷阵雨，局地大雨；东北风：3-4级；最低气温：23-24度；最高气温：28-29度。 7月19日 09:25：郑州气象临 近 预 报 郑州市气象台2021年7月19日09:10发布临近预报：目前郑州市中原区、二七区、航空港区、新密、荥阳有片状回波，其他区域为分散性回波，最强回波强度达到55dBZ。预计未来1小时，郑州市区西南部、航空港区、荥阳、新密有阵雨、雷阵雨，局地伴有1小时20-30毫米的短时强降水。请注意防范。 7月19日 13:24：郑州气象【雨情】07月19日08时至07月19日13时，我市出现局部暴雨。最大降水量出现在巩义市的北山口71.9毫米。降水量在50-99.9毫米的站点有15个，25-49.9毫米的站点有26个，10-24.9毫米的站点有42个。雨量较大的站点有（毫米）：郑州的侯寨17.7、马寨一中17.3；巩义市的北山口71.9、康店71.3、四初中66.5、孝义65.0、巩义紫荆62.3；登封市的嵩山站27.9、君召17.7、市区16.8；荥阳市的环翠峪58.2、崔庙49.7、家子岗40.3、石板沟35.6、乔楼28.5；新密市的柿树湾59.9、尖山50.1、尖山伏羲山38.8、白寨38.5、袁庄32.1；新郑市的 望京楼水库33.4、薛店草庙马21.6、郭店农业园21.4；中牟县的九龙0.7、农业公园0.4；航空港区的八千9.9、香炉朱村3.4。【临近预报】郑州市气象台2021年7月19日13:00发布临近预报：目前较强回波位于郑州市二七区、管城区、中原区和高新区西部、航空港区、新郑、新密、巩义、中牟北部，最强回波强度达55dBZ。预计未来1小时，郑州市航空港区、二七区、高新区、中原区、管城区、惠济区、上街区、荥阳、新密、新郑、巩义、登封、中牟北部有阵雨、雷阵雨，局地伴有1小时30毫米的短时强降水。目前郑州市暴雨黄色预警中。请注意防范。 7月19日 14:31：郑州气象临 近 预 报郑州市气象台2021年7月19日14:00发布临近预报：目前较强回波位于郑州市区、航空港区、新郑、新密、巩义、登封，最强回波强度达55dBZ。预计未来2小时，全市大部有阵雨、雷阵雨，局地伴有1小时30-40毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨黄色预警中。请注意防范。 7月19日 14:38：郑州气象郑州市气象台2021年07月19日14时28分发布雷电黄色预警信号:郑州市区及所辖六县(市)已有雷电活动，未来6小时将持续，局地伴有小时雨强30-40毫米短时强降水，7级左右短时大风，请注意防范。 7月19日 16:19：郑州气象#郑州暴雨# 临 近 预 报郑州市气象台2021年7月19日16:00发布临近预报：目前较强回波位于荥阳西北部，中牟、航空港区，最强回波强度达55dBZ。预计未来2小时，全市大部有阵雨、雷阵雨，局地伴有1小时30-40毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨黄色、雷电黄色预警中。请注意防范。 7月19日 16:31：郑州气象#天气小播报# 今天夜里到明天白天郑州地区有大到暴雨，局地大暴雨天气，大家出行请避开低洼、积水路段，注意行车安全。 视频地址：http://t.cn/A6fQXWrV?m=4660710686065462&amp;u=2655176573 7月19日 17:35：郑州气象【雨情】07月19日08时至17时，我市出现大到暴雨，局地大暴雨。最大降水量出现在巩义市的小关114.2毫米。降水量在100-249.9毫米的站点有6个，50-99.9毫米的站点有42个，25-49.9毫米的站点有62个，10-24.9毫米的站点有35个。雨量较大的站点有（毫米）：郑州的侯寨44.9、尖岗水库43.5、林科所43.4；巩义市的小关114.2、新中106.6、文化站106.4、大峪沟94.8、北山口94.6；登封市的嵩山站53.0、纸坊48.5、卢店镇48.4、唐庄48.4、大冶43.8；荥阳市的虎牢关106.2、环翠峪101.4、石板沟100.5、家子岗86.6、城关86.4；新密市的柿树湾74.7、白寨74.3、尖山69.5、黄帝岭64.8、曲梁63.7；新郑市的 望京楼水库67.5、郭店农业园49.8、薛店草庙马48.4、郭店41.6、常刘社区32.1；中牟县的中牟站39.2、姚家31.8、白沙31.5；航空港区的八千47.4、香炉朱村36.4、三官庙11.7。 7月19日 19:21：郑州气象郑州市气象台2021年07月19日19时13分发布暴雨橙色预警信号:预计未来3小时内郑州市区及所辖六县(市)降雨量将达50毫米以上，局部将达100毫米以上，请注意防范。 7月19日 21:12：郑州气象【雨情】07月19日17时至21时，我市出现大到暴雨，局部大暴雨。最大降水量出现在新密市的来集118.5毫米。降水量在100-249.9毫米的站点有6个，50-99.9毫米的站点有64个，25-49.9毫米的站点有35个，10-24.9毫米的站点有32个。雨量较大的站点有（毫米）：郑州的冠军中学38.1、丽水中学33.8、侯寨25.4；巩义市的四初中98.6、巩义紫荆82.5、大峪沟74.6、北山口68.2、站街66.9；登封市的大冶68.1、嵩山站66.9、卢店镇60.8、佛垌水库54.6、西燕村水库52.6；荥阳市的崔庙56.6、环翠峪49.5、石板沟37.0、刘河陈家岗35.3、贾峪27.9；新密市的来集118.5、白寨113.6、来集社区112.5、平陌101.8、牌坊沟101.2；新郑市的后湖83.5、常刘社区79.2、郭店农业园71.8、柿树行69.6、青岗庙水库66.0；中牟县的张庄20.9、黄店9.8、千禾农场8.0；航空港区的香炉朱村53.3、八千49.7、三官庙41.3、八岗7.5。 7月19日 21:26：郑州气象临 近 预 报 郑州市气象台2021年7月19日21:00发布临近预报：目前全市均有较强回波，最强回波强度达55-60dBZ。预计未来2小时，全市大部有阵雨、雷阵雨，局地伴有1小时50-60毫米的短时强降水、8级左右的短时大风。目前郑州市暴雨橙色、雷电黄色预警中。请注意防范。 7月19日 22:12：郑州气象郑州市气象台2021年07月19日21时59分发布暴雨红色预警信号:目前，郑州市区局部降水量已达50毫米以上，预计未来3小时内，降水持续，累积降水量将达100毫米以上，请注意防范。 7月19日 23:22：郑州气象【雨情】07月19日08时至23时，我市出现大到暴雨，局部大暴雨。最大降水量出现在新密市的白寨240.6毫米。降水量在100-249.9毫米的站点有92个，50-99.9毫米的站点有44个，25-49.9毫米的站点有28个，10-24.9毫米的站点有7个。雨量较大的站点有（毫米）：郑州的侯寨116.3、尖岗水库101.0、冠军中学87.8、外语学校67.8、林科所67.6；巩义市的四初中231.0、小关210.9、大峪沟205.9、新中201.7、文化站199.7；登封市的嵩山站167.2、大冶162.6、卢店镇162.3、唐庄150.3、西燕村水库133.6；荥阳市的环翠峪204.4、崔庙187.5、石板沟164.0、家子岗142.7、虎牢关130.1；新密市的白寨240.6、黄帝岭200.5、牌坊沟198.1、曲梁183.5、岳村181.4；新郑市的后湖170.7、郭店农业园162.2、 望京楼水库144.8、常刘社区135.0、薛店草庙马128.0；中牟县的中牟站49.7、张庄46.1、姚家46.0；航空港区的八千113.3、香炉朱村105.6、三官庙70.6、八岗30.0。 2021.7.207月20日 06:48：郑州气象【雨情】07月19日06时至20日06时，我市出现暴雨到大暴雨，特大暴雨。最大降水量出现在登封市的嵩山站333.6毫米。降水量在250毫米以上的站点有21个，100-249.9毫米的站点有119个，50-99.9毫米的站点有25个，25-49.9毫米的站点有5个，10-24.9毫米的站点有2个。雨量较大的站点有（毫米）：郑州的侯寨175.7、尖岗水库175.2、冠军中学148.5、惠济143.7、林科所139.6；巩义市的四初中329.1、竹林312.0、大峪沟304.1、小关298.5、新中293.4；登封市的嵩山站333.6、西燕村水库310.2、卢店镇307.1、大冶304.9、纸坊245.9；荥阳市的环翠峪297.4、崔庙252.4、石板沟238.0、虎牢关200.4、家子岗192.4；新密市的白寨311.4、黄帝岭278.3、平陌267.0、李湾246.2、牌坊沟245.7；新郑市的后湖214.9、郭店农业园211.1、青岗庙水库204.1、柿树行200.9、 望京楼水库192.8；中牟县的白沙101.9、张庄96.6、郑庵镇86.4、中牟站81.8、姚家77.6；航空港区的八千157.3、香炉朱村149.5、三官庙118.5、八岗75.0。【天气预报】今天白天到夜里：阴天有大到暴雨，局部大暴雨，东北风：3-4级，最高气温：24-25度，最低气温：22-23度；明天白天：中到大雨，局部暴雨 7月20日 06:55：郑州气象郑州市气象台2021年07月20日06时02分发布暴雨红色预警信号:预计未来3小时内，郑州市区及所辖六县(市)降水量将达100毫米以上，请注意防范。 7月20日 09:24：郑州气象郑州市气象台2021年07月20日09时08分继续发布暴雨红色预警信号:预计未来3小时内，郑州市区及所辖六县(市)降水量将达100毫米以上，请注意防范。 7月20日 10:20：郑州气象【雨情】07月20日06时至10时，我市出现大到暴雨，局部大暴雨。最大降水量出现在巩义市的文化站132.3毫米。降水量在100-249.9毫米的站点有14个，50-99.9毫米的站点有88个，25-49.9毫米的站点有56个，10-24.9毫米的站点有9个。雨量较大的站点有（毫米）：郑州的姚桥60.1、惠济48.3、香山小学42.3、聚源小学41.4、尖岗水库40.3；巩义市的文化站132.3、新中131.0、小关120.2、沙峪沟112.3、杜甫故里106.5；登封市的嵩山站92.3、西燕村水库88.9、雅馨园艺86.3、少林水库78.4、桑楼77.5；荥阳市的石板沟128.9、环翠峪120.1、高山水厂100.6、崔庙92.6、虎牢关72.3；新密市的尖山105.9、柿树湾100.2、尖山伏羲山96.5、助泉寺94.9、牛店91.6；新郑市的唐寨水库112.0、新郑铁李80.6、辛店小李庄76.5、王刘庄67.8、新郑站67.7；中牟县的白沙59.0、东枫杨55.3、中牟站49.7、大孟45.0、张庄41.8；航空港区的香炉朱村47.5、八千44.5、三官庙36.2。【临近预报】郑州市气象台2021年7月20日10:00发布临近预报：目前全市均有较强回波，最强回波强度达55-60dBZ。预计未来2小时，全市大部强降水持续，局地伴有1小时40-50毫米的短时强降水、8级左右的短时大风。目前郑州市暴雨红色、雷电黄色预警中。请注意防范。 7月20日 12:02：郑州气象郑州市气象台2021年07月20日11时50分继续发布暴雨红色预警信号:郑州市区及所辖六县(市)未来3小时内降水持续，累积降水量将达100毫米以上。请注意防范。 7月20日 12:13：郑州气象【雨情】07月20日08时至07月20日12时，我市出现大暴雨。最大降水量出现在巩义市的西村146.1毫米。降水量在100-249.9毫米的站点有31个，50-99.9毫米的站点有66个，25-49.9毫米的站点有61个，10-24.9毫米的站点有13个。雨量较大的站点有（毫米）：郑州的惠济59.7、尖岗水库54.9、郑州站47.3、市政府45.7、姚桥43.6；巩义市的西村146.1、四初中144.0、河洛132.3、康店130.7、杜甫故里129.5；登封市的西燕村水库134.3、少林水库113.1、嵩山站112.8、纸坊93.4、市区93.0；荥阳市的石板沟129.9、高山水厂109.2、虎牢关105.4、环翠峪89.2、崔庙73.0；新密市的尖山100.6、尖山伏羲山98.7、助泉寺77.0、袁庄76.3、城关71.5；新郑市的柿树行78.7、青岗庙水库67.4、苗家沟52.7、后湖50.4、郭店农业园45.5；中牟县的姚家58.6、张庄54.3、千禾农场51.8、黄店45.7、九龙40.9；航空港区的三官庙51.3、香炉朱村44.0、八千38.0、八岗31.3。【临近预报】郑州市气象台2021年7月20日12:00发布临近预报：目前全市均有较强回波，最强回波强度达55-60dBZ。预计未来2小时，全市大部强降水持续，局地伴有1小时40-50毫米的短时强降水、8级左右的短时大风。目前郑州市暴雨红色、雷电黄色预警中。请注意防范。 7月20日 13:36：郑州气象郑州市气象台2021年07月20日13时25分继续发布雷电黄色预警信号:郑州市区及所辖六县(市)未来6小时内将发生雷电活动，局地伴有小时雨强30到60毫米的短时强降水，8级左右的短时大风，请注意防范。 7月20日 16:17：郑州气象#郑州掉雨窝了# 郑州市汛期地质灾害气象预报预警结果发布单位：郑州市自然资源和规划局 郑州市气象局（2021.07.20 20:00 — 2021.07.21 20:00）发布时间： 2021-07-20 15：40今晚到明天，郑州市地质灾害预警预报达到红色预警的地区为：荥阳、登封、新密、上街区、二七区大部，惠济区西部，新郑西北及西南部，发生地质灾害的可能性很大。郑州市地质灾害预警预报达到橙色预警的地区为：登封中南部，新密、惠济区、二七区西部，新郑西北及西南部，中原区西南部局部，发生地质灾害的可能性大。请相关区县市（市）做好地质灾害防范工作。 7月20日 16:24：郑州气象#郑州暴雨# 郑州市气象台2021年07月20日16时01分继续发布暴雨红色预警信号：郑州市区及巩义、登封、荥阳未来3小时内降水持续，累积降水量将达100毫米以上。请注意防范。 7月20日 16:45：郑州气象#天气小播报# 郑州地区强降水仍将持续，请大家出行尽量避开涵洞、低洼、积水路段，注意出行安全。 视频地址：http://t.cn/A6f8Tj2g?m=4661076522435254&amp;u=2655176573 7月20日 17:16 ：郑州气象【雨情】07月20日08时至17时，我市出现大暴雨，局部特大暴雨。最大降水量出现在二七区的尖岗水库438.0毫米。降水量在250毫米以上的站点有26个，100-249.9毫米的站点有85个，50-99.9毫米的站点有42个，25-49.9毫米的站点有16个。雨量较大的站点有（毫米）：郑州的尖岗水库438.0、郑州站366.3、外语学校353.8、侯寨346.8、中原区政府330.3；巩义市的文化站309.0、沙峪沟269.5、竹林259.0、河洛252.2、小关250.4；登封市的西燕村水库163.0、纸坊162.2、嵩山站150.5、徐庄镇144.3、登封站123.9；荥阳市的石板沟362.2、家子岗262.7、崔庙260.4、环翠峪252.8、槐林231.9；新密市的袁庄301.2、柿树湾272.4、霍雷庙267.2、尖山264.7、尖山伏羲山243.8；新郑市的后湖142.0、柿树行93.3、孟庄84.2、青岗庙水库76.9、郭店农业园68.4；中牟县的刘集116.8、大孟116.1、姚家95.2、东枫杨89.8、中牟站75.1；航空港区的三官庙65.7、香炉朱村49.6、八岗48.2、八千44.5。【临近预报】郑州市气象台2021年7月20日17:00发布临近预报：目前强降水回波位于郑州市区、登封东部，巩义南部、新密北部，最强回波强度达60-65dBZ。预计未来2小时，郑州市区、荥阳南部、新密、登封东部及南部、中牟西部、巩义大部强降水持续，局地伴有1小时30-50毫米的短时强降水、8级左右的短时大风。目前郑州市暴雨红色、雷电黄色预警中。请注意防范。 7月20日 18:54：郑州气象#郑州暴雨# 近一小时降水信息 7月20日 20:11：郑州气象#郑州暴雨# 郑州市气象台2021年07月20日20时01分继续发布雷电黄色预警信号:郑州市区及所辖六县(市)未来6小时内将发生雷电活动，局地伴有小时雨强20到40毫米的短时强降水，7级左右的短时大风，请注意防范。 7月20日 20:33：郑州气象#河南暴雨##郑州暴雨# 【雨情】07月20日08时至20时，我市出现大暴雨，局部特大暴雨。最大降水量出现在二七区的尖岗水库543.6毫米。降水量在250毫米以上的站点有49个，100-249.9毫米的站点有101个，50-99.9毫米的站点有18个，25-49.9毫米的站点有2个。雨量较大的站点有（毫米）：郑州的尖岗水库543.6、郑州站465.8、外语学校417.5、中原区政府413.2、聚源小学392.5；巩义市的文化站382.1、小关329.7、沙峪沟288.5、竹林286.7、巩义蝴蝶谷272.3；登封市的西燕村水库197.0、佛垌水库180.8、大冶170.6、纸坊165.0、徐庄镇154.2；荥阳市的石板沟437.2、崔庙311.8、环翠峪308.2、槐林297.7、家子岗294.5；新密市的白寨365.1、尖山352.9、柿树湾338.3、尖山伏羲山323.6、黄帝岭311.2；新郑市的后湖197.5、柿树行177.7、孟庄158.7、郭店农业园135.1、好想你133.4；中牟县的白沙155.3、张庄155.2、九龙150.4、刘集148.7、大孟136.5；航空港区的三官庙136.6、八千114.2、香炉朱村110.2、八岗91.5。【临近预报】郑州市气象台2021年7月20日20:00发布临近预报：目前强降水回波位于郑州中东部，预计未来2小时内向西北移动，郑州主城区雨势再次加强，局地伴有1小时30-50毫米的短时强降水、8级左右的短时大风。目前郑州市暴雨红色、雷电黄色预警中。请注意防范。 7月20日 21:48 ：郑州气象郑州市气象台2021年07月20日21时32分继续发布暴雨红色预警信号：郑州市区及中牟、新郑未来3小时内降水持续，累积降水量将达100毫米以上。请注意防范。 7月20日 22:26：郑州气象#郑州暴雨# 临近预报注意查收～ L郑州气象的微博视频 视频地址：http://t.cn/A6fRP0An?m=4661162358612171&amp;u=2655176573 2021.7.217月21日：河南日报7.21 20-21时新乡，连续两小时雨量超过100毫米 7月21日 00:02 ：郑州气象2021年7月20日23时发布目前到明天08时中牟、郑东新区、管城区及金水区东部80～100毫米，局地100～150毫米，其它地区40～60毫米。明天上午，郑州有大雨，局部暴雨，降水量20～30毫米，局部40～60毫米；明天下午，30到50毫米，局部60～80毫米。明天夜里，15～30毫米。22日，降水减弱，有阵雨、雷阵雨。 7月21日 00:15 ：郑州气象【雨情】07月20日20时至21日00时，我市出现暴雨，局地大暴雨。最大降水量出现在二七区的侯寨129.5毫米。降水量在100-249.9毫米的站点有6个，50-99.9毫米的站点有50个，25-49.9毫米的站点有33个，10-24.9毫米的站点有31个。雨量较大的站点有（毫米）：郑州的侯寨129.5、中原区政府104.6、市政府104.4、郑州站85.7、南曹75.4；巩义市的 坞罗水库17.5、夹津口17.0；登封市的佛垌水库47.4、大冶32.8、纸坊22.5；荥阳市的贾峪37.7、荥阳站25.9、石板沟25.8；新密市的白寨86.9、赵贵岗村84.9、刘寨83.6、曲梁82.8、曲梁80.7；新郑市的柿树行100.0、后湖86.4、青岗庙水库85.1、孟庄76.3、苗家沟75.7；中牟县的狼城岗126.2、东湖113.8、千禾农场98.1、农业公园95.1、黄店88.2；航空港区的三官庙44.8、八千33.5、香炉朱村27.7。【临近预报】郑州市气象台2021年7月21日00:00发布临近预报：目前强回波位于郑州市区、中牟、新郑、新密东部，预计未来2小时向西北移动，郑州主城区较强降雨持续，局地伴有1小时20～40毫米的短时强降水、8级左右的短时大风。目前郑州市暴雨红色、雷电黄色预警中。请注意防范。 7月21日 00:44：郑州气象#郑州暴雨# 郑州市气象台2021年07月21日00时25分继续发布暴雨红色预警信号:郑州市区及中牟新郑未来3小时内降水持续，累积降水量将达100毫米以上。请注意防范。 7月21日 00:45：郑州气象郑州市气象台2021年07月21日00时25分继续发布暴雨红色预警信号：郑州市区及中牟、新郑未来3小时内降水持续，累积降水量将达100毫米以上。请注意防范。 7月21日 06:50：郑州气象【雨情】07月20日06时至21日06时，我市出现特大暴雨。最大降水量出现在二七区的侯寨672.0毫米。降水量在250毫米以上的站点有107个，100-249.9毫米的站点有59个，50-99.9毫米的站点有5个。雨量较大的站点有（毫米）：郑州的侯寨672.0、尖岗水库639.8、郑州站630.0、中原区政府567.1、外语学校553.3；巩义市的文化站486.4、小关412.2、竹林360.0、沙峪沟349.0、新中338.1；登封市的佛垌水库291.9、西燕村水库286.8、大冶274.4、纸坊248.1、嵩山站237.5；荥阳市的石板沟499.6、环翠峪390.9、崔庙376.6、贾峪358.3、高山水厂350.7；新密市的白寨540.5、柿树湾477.6、尖山476.8、黄帝岭469.6、袁庄465.2；新郑市的柿树行379.6、辛店小李庄320.7、后湖318.4、孟庄307.2、唐寨水库303.1；中牟县的白沙291.8、九龙283.7、姚家268.9、黄店255.7、张庄254.4；航空港区的三官庙223.0、八千209.0、香炉朱村190.8、八岗102.4。【天气预报】21日，阴天有暴雨，局地大暴雨，降水量80～120毫米，局部150～200毫米。22日，阴天有小到中雨，降水量5～15毫米。23日，多云，有分散性阵雨，降水量1～5毫米。 7月21日 08:50：郑州气象 #郑州暴雨# 【雨情】07月21日06时至08时，我市出现小到中雨，局地大雨。最大降水量出现在中牟县的农业公园31.1毫米。降水量在25-49.9毫米的站点有4个，10-24.9毫米的站点有29个。雨量较大的站点有（毫米）：郑州的南曹24.8、林科所11.6、聚源小学9.6；巩义市的文化站3.1、站街1.6；登封市的佛垌水库10.2、卢店镇4.8；荥阳市的广武10.5、虎牢关9.9；新密市的新密12.1、来集11.2；新郑市的郭店31.0、孟庄29.5、王刘庄22.7；中牟县的农业公园31.1、狼城岗27.3、九龙20.0；航空港区的八千18.0、香炉朱村15.1。【临近预报】郑州市气象台2021年7月21日08:00发布临近预报：目前降水回波位于郑州市区、中牟、荥阳、新密、新郑，强回波位于郑州和中牟交界处。预计未来2小时内向东北方向移动，郑州雨势维持，两小时降水量10～30毫米，局地伴有1小时20毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨橙色、雷电黄色预警中。请注意防范。 7月21日 09:39：郑州气象#郑州暴雨# 郑州市气象台2021年07月21日09时19分继续发布暴雨橙色预警信号：预计未来3小时内,郑州市区及中牟降雨持续，累积降水量将达50毫米以上，请注意防范。 7月21日 12:33：郑州气象【临近预报】目前巩义、登封、新郑南部和港区有降水回波，最大回波强度55dBZ。预计未来2小时内回波向东北移动，郑州全区降水增强，两小时降水量10～40毫米，局地伴有1小时20毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨橙色、雷电黄色预警中。请注意防范。 ​​​​ 7月21日 11:50：郑州气象郑州市气象台2021年07月21日11时05分继续发布雷电黄色预警信号:郑州市区及所辖六县(市)未来6小时内将发生较强雷电活动，局地伴有小时雨强20到40毫米的短时强降水，7级左右短时大风，请注意防范。 7月21日 12:59：郑州气象#郑州暴雨# 郑州市气象台2021年07月21日12时40分发布暴雨橙色预警信号:预计未来3小时内郑州市区南部、港区、登封、新密、新郑及中牟累积降雨量将达50毫米以上且将持续，请注意防范。 7月21日 13:21：郑州气象【雨情】07月21日10时至12时，我市出现小到中雨。最大降水量出现在巩义市的芝田27.1毫米。降水量在25-49.9毫米的站点有1个，10-24.9毫米的站点有7个。雨量较大的站点有（毫米）：郑州的尖岗水库0.3、聚源小学0.2；巩义市的芝田27.1、 后林村18.3、巩义潘安园15.5；登封市的送表3.9、石道乡区域站3.6；荥阳市的刘河陈家岗0.6、高山水厂0.3；新密市的尖山2.1、新密0.9；新郑市的唐寨水库3.9、石固堆3.4；中牟县的白沙2.7、东枫杨2.1；航空港区的香炉朱村3.9、八千2.8。【临近预报】目前巩义、登封、新郑南部和港区有降水回波，最大回波强度55dBZ。预计未来2小时内回波向东北移动，郑州全区降水增强，两小时降水量10～40毫米，局地伴有1小时20毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨橙色、雷电黄色预警中。请注意防范。 7月21日 14:32：郑州气象【临近预报】目前郑州地区无明显降水回波。预计未来2小时内登封南部、新密南部、新郑南部、港区南部及中牟南部有降水，两小时降水量5～15毫米，局地伴有1小时20毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨橙色、雷电黄色预警中。请注意防范。 ​​​​ 7月21日 14:34：郑州气象【雨情】07月21日12时至14时，我市出现小雨，局部中雨。最大降水量出现在巩义市的河洛10.4毫米。降水量在10-24.9毫米的站点有1个，0.1-9.9毫米的站点有87个。雨量较大的站点有（毫米）：郑州的尖岗水库0.2、苗木场0.1；巩义市的河洛10.4、蔡沟村7.6；登封市的嵩山站4.7、徐庄镇2.7；荥阳市的高山水厂1.0、刘河陈家岗0.6；新密市的尖山1.0、牛店0.9；新郑市的唐寨水库4.8、石固堆2.8；中牟县的千禾农场1.7、黄店0.6；航空港区的香炉朱村2.8、八千2.7。 7月21日 15:53：郑州气象郑州市气象台2021年07月21日15时30分发布暴雨黄色预警信号:预计未来6小时内郑州市区及所辖六县(市)降水量将达50毫米以上，请注意防范。 7月21日 17:12：河南日报河南省气象台7月21日16时30分继续发布暴雨橙色预警：预计未来3小时内，安阳、鹤壁、焦作、许昌、漯河、平顶山、南阳、信阳、驻马店九地区和新乡地区西部及郑州地区西部、南部部分地区降水量将达到50毫米以上，局部达100毫米以上。 7月21日 17:38：郑州气象郑州市气象台2021年07月21日17时33分继续发布雷电黄色预警信号:预计未来6小时内郑州市区及所辖六县(市)将发生雷电活动，局地伴有小时雨强20到30毫米的短时强降水，7级以上阵风，请注意防范。 7月21日 18:01：河南日报【注意！河南大部仍有中到大雨】7月21日，记者从省气象台获悉，21日14时至22日14时，河南大部仍有中到大雨。其中，河南中部和北部有暴雨到大暴雨，河南西北部地区有特大暴雨（250毫米～270毫米）。郑州有暴雨、局地大暴雨，累计60毫米～100毫米、局地120～140毫米；其中，21日下午10毫米～25毫米，夜间50毫米～90毫米，22日上午5毫米～25毫米；最大小时降雨量20毫米～40毫米。O22日14时至23日14时 ，河南中西部有小到中雨，局地大雨；郑州阵雨转多云，降雨量1毫米～5毫米。预计今明两天河南降雨仍将持续，河南中部和北部有暴雨到大暴雨，致灾风险极高，各地需继续做好洪涝、地质灾害、城市内涝灾害防御以及河堤、库坝等的巡查工作，并防范强降雨对救灾各项工作的不利影响，同时做好卫生防疫工作。淮河、海河流域需密切关注上游来水情况。 7月21日 18:16：郑州气象【雨情】07月21日16时至18时，我市出现阵雨。最大降水量出现在登封市的西燕村水库16.1毫米。降水量在10-24.9毫米的站点有3个，0.1-9.9毫米的站点有50个。雨量较大的站点有（毫米）：郑州的惠济1.1、金艺小0.7；巩义市的文化站6.8、慈云寺5.7；登封市的西燕村水库16.1、嵩山站12.2；荥阳市的张庄8.2、虎牢关0.7；新密市的尖山6.4、助泉寺0.6；新郑市的常刘社区0.2、唐寨水库0.2；中牟县的黄店0.1、赵口0.1；航空港区的香炉朱村0.1。【临近预报】目前强回波位于许昌及郑州西部，未来2小时内，强回波北移，郑州西部、南部有阵雨、雷阵雨，局地伴有1小时20-40毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨黄色、雷电黄色预警中。请注意防范。 7月21日 18:18：河南日报#河南灾情致25人死亡7人失联#7月21日，河南省政府新闻办召开“河南省防汛应急”新闻发布会，据不完全统计，16日以来，此轮强降雨造成全省89个县（市、区）560个乡镇1240737人受灾，因极值暴雨致25人死亡7人失联。全省已紧急避险转移16325人，紧急转移安置164710人；农作物受灾面积75千公顷，成灾面积25.2千公顷，绝收面积4.7千公顷；直接经济损失54228.72万元。 7月21日 19:44：郑州气象#郑州暴雨##河南暴雨#气象灾害预警信号 郑州市气象台2021年07月21日19时27分发布暴雨红色预警信号:预计未来3小时内，郑州市区、巩义、荥阳、新密、新郑降水持续，累积降水量将达100毫米以上，请注意防范。 7月21日 19:55：河南日报【气象灾害预警！】郑州市气象台2021年07月21日19时27分发布暴雨红色预警信号:预计未来3小时内，郑州市区、巩义、荥阳、新密、新郑降水持续，累积降水量将达100毫米以上，请注意防范。防御指南:1政府及相关部门按照职责做好防暴雨应急和抢险工作;2.停止集会、停课、停业(除特殊行业外):3.做好山洪、滑坡、泥石流等灾害的防御和抢险工作。 7月21日 20:28：郑州气象【雨情】07月21日18时至20时，我市出现阵雨，局部大到暴雨。最大降水量出现在巩义市的巩义蝴蝶谷46.6毫米。降水量在25-49.9毫米的站点有4个，10-24.9毫米的站点有21个，0.1-9.9毫米的站点有76个。雨量较大的站点有（毫米）：郑州的惠济17.3、冠军中学13.2；巩义市的巩义蝴蝶谷46.6、文化站30.8、北山公园25.7；登封市的观星台6.1、玫瑰园3.5；荥阳市的高山水厂30.0、刘河陈家岗18.0、石板沟17.7；新密市的来集18.7、来集社区18.7；新郑市的苗家沟19.1、石固堆18.6；中牟县的韩寺20.7、千禾农场20.5、姚家13.2；航空港区的三官庙2.3、八岗2.3。【临近预报】目前强回波位于郑州中部、东部，回波中心强度55-60dBZ,未来2小时内，强回波北移，郑州市区、登封、荥阳、新郑、中牟有中雨，局地伴有1小时20-40毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨红色、雷电黄色预警中。请注意防范。 7月21日 22:23：郑州气象#郑州暴雨##河南暴雨#【雨情】07月21日20时至22时，我市出现小雨，局地中雨。最大降水量出现在中牟县的东湖19.5毫米。降水量在10-24.9毫米的站点有4个，0.1-9.9毫米的站点有98个。雨量较大的站点有（毫米）：郑州的马寨一中1.7、林科所1.3；巩义市的站街0.2、杜甫故里0.1；登封市的卢店镇1.7、佛垌水库1.5；荥阳市的高山水厂11.6、广武7.1；新密市的霍雷庙2.7、袁庄2.6；新郑市的唐寨水库4.2、郭店2.6；中牟县的东湖19.5、农业公园12.0；航空港区的三官庙1.2、八岗0.7。【临近预报】目前郑州地区有分散性降水回波，未来2小时内，郑州地区有分散性阵雨。目前郑州市雷电黄色预警中。请注意防范。 7月21日 22:24：河南日报河南省气象台7月21日22时05分继续发布暴雨红色预警：鹤壁地区和安阳、新乡、开封、周口四地区西部部分地区降水量已达50毫米以上，预计未来3小时内，安阳、鹤壁、新乡、焦作四地区和周口地区西部与开封地区西部北部及商丘地区北部降水持续，累积降水量将达100毫米以上。 7月21日 22:28：郑州气象#河南暴雨##郑州暴雨# 郑州市气象台2021年07月21日22时25分发布暴雨黄色预警信号:预计未来6小时内，郑州市区及所辖六县(市)累积降水量将达50豪米以上，请注意防范。 2021.7.22今天 00:17：郑州气象【雨情】07月21日22时至22日00时，我市出现小到中雨。最大降水量出现在惠济区的惠济10.2毫米。降水量在10-24.9毫米的站点有1个，0.1-9.9毫米的站点有70个。雨量较大的站点有（毫米）：郑州的惠济10.2、冠军中学6.8；巩义市的 坞罗水库1.5、河洛1.1；登封市的佛垌水库0.1；荥阳市的虎牢关1.3、槐林0.8；新密市的市水利局2.8、大隗0.1；新郑市的唐寨水库2.3、后湖0.3；中牟县的韩寺1.4、赵口0.9；航空港区的三官庙0.2。【临近预报】目前郑州地区有分散性降水回波，未来2小时内，郑州地区有分散性阵雨。目前郑州市雷电黄色预警中。请注意防范。 7月22日 01:14：郑州气象临 近 预 报 郑州市气象台2021年7月22日01:10发布临近预报：目前强回波位于郑州经开区、郑东新区、港区、中牟、新郑，回波中心强度55-60dBZ，未来1小时内，强回波北移，郑州市区中东部、中牟、新郑、新密东部、荥阳西部、巩义东部、上街区有短时强降水，局地伴有1小时20-40毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨黄色、雷电黄色预警中。请注意防范。 7月22日 02:18：郑州气象郑州市气象台2021年07月22日02时15分发布暴雨橙色预警信号：预计未来3小时内,郑州地区东部、南部累积降雨量将达50毫米以上，请注意防范。 7月22日 02:33：郑州气象【雨情】07月22日00时至02时，我市出现小到中雨，局地大雨。最大降水量出现在中牟县的九龙32.7毫米。降水量在25-49.9毫米的站点有1个，10-24.9毫米的站点有8个，0.1-9.9毫米的站点有74个。雨量较大的站点有（毫米）：郑州的南曹5.0、四十七中2.3；巩义市的河洛0.7、大峪沟0.1；登封市的大冶0.6、徐庄镇0.2；荥阳市的王村2.5、虎牢关2.4；新密市的大隗10.6、赵贵岗村10.5；新郑市的孟庄17.7、柿树行5.0；中牟县的九龙32.7、白沙17.1、张庄13.9；航空港区的香炉朱村17.1、三官庙10.9。【临近预报】目前郑州东部、南部有较强降水回波，回波中心强度55-60dBZ，未来2小时内，强回波北移，郑州市区及东部、南部降水持续，局地伴有1小时20-40毫米的短时强降水。目前郑州市暴雨橙色预警、雷电黄色预警中。请注意防范。 7月22日 04:14：郑州气象【雨情】07月22日02时至04时，我市局部出现短时强降水。最大降水量出现在中原区的中原区政府44.1毫米。降水量在25-49.9毫米的站点有8个，10-24.9毫米的站点有30个，0.1-9.9毫米的站点有75个。雨量较大的站点有（毫米）：郑州的中原区政府44.1、市政府34.5、尖岗水库31.9；巩义市的文化站0.3、小关0.1；登封市的观星台17.5、徐庄镇13.7；荥阳市的刘河陈家岗5.0、贾峪4.9；新密市的尖山35.5、牌坊沟29.7、白寨27.9；新郑市的柿树行4.8、孟庄4.5；中牟县的刘集34.8、白沙24.3、赵口19.0；航空港区的八岗4.1、三官庙1.3。【临近预报】郑州市气象台2021年7月22日04:10发布临近预报：目前强回波位于新密、荥阳、郑州，回波中心强度50-55dBZ，未来2小时内，强回波北移，郑州市区西部、北部、荥阳、新密、登封南部局部有1小时20-40毫米的短时强降水、7级左右的短时大风。新郑、中牟有阵雨。目前郑州市暴雨橙色、雷电黄色预警中。请注意防范。 7月22日 05:22：郑州气象郑州市气象台2021年07月22日05时16分继续发布暴雨橙色预警信号：预计未来3小时内,郑州市区及所辖六县（市）累积降雨量将达50毫米以上，请注意防范。 7月22日 05:49：郑州气象郑州市气象台2021年07月21日05时43分继续发布雷电黄色预警信号:郑州市区及所辖六县(市)未来6小时内有雷电活动，并伴有小时雨强20到30毫米的短时强降水，7级以上阵风，请注意防范。 7月22日 06:42：郑州气象#河南暴雨##郑州暴雨#【雨情】07月21日06时至07月22日06时，我市出现中到大雨，局部暴雨。最大降水量出现在新密市的柿树湾87.3毫米。降水量在50-99.9毫米的站点有43个，25-49.9毫米的站点有66个，10-24.9毫米的站点有37个，0.1-9.9毫米的站点有15个。雨量较大的站点有（毫米）：郑州的中原区政府75.2、惠济73.5、市政府65.5、丽水中学65.0、南曹61.3；巩义市的小关71.6、巩义蝴蝶谷69.5、文化站59.8、新中55.5、北山公园36.4；登封市的嵩山站36.9、西燕村水库36.2、大冶32.6；荥阳市的石板沟57.8、高山水厂50.7、家子岗45.8、贾峪45.4、广武43.0；新密市的柿树湾87.3、平陌村79.3、平陌77.5、牌坊沟75.5、白寨71.8；新郑市的孟庄63.5、郭店44.8、石固堆41.6、柿树行40.2、苗家沟39.9；中牟县的九龙79.0、白沙71.2、刘集66.8、农业公园65.4、狼城岗53.4；航空港区的香炉朱村44.3、八千35.8、三官庙31.7。【临近预报】目前登封、新密、新郑、荥阳、郑州市区、中牟有较强降水回波，回波中心强度55dBZ，未来2小时内，回波东北移动，郑州地区降水持续，局地伴有1小时20-30毫米的短时强降水。目前郑州市暴雨橙色预警、雷电黄色预警中。请注意防范。【天气预报】今天白天到夜里：阴天有小到中雨偏东风：3-4级最高气温：28-29度最低气温：23-24度明天白天：多云间阴天，有分散性阵雨、雷阵雨 7月22日 06:59：河南新闻广播【郑州雨情】07月21日06时至07月22日06时，郑州市出现中到大雨，局部暴雨。最大降水量出现在新密市的柿树湾87.3毫米。降水量在50-99.9毫米的站点有43个，25-49.9毫米的站点有66个，10-24.9毫米的站点有37个，0.1-9.9毫米的站点有15个。雨量较大的站点有（毫米）：郑州的中原区政府75.2、惠济73.5、市政府65.5、丽水中学65.0、南曹61.3；巩义市的小关71.6、巩义蝴蝶谷69.5、文化站59.8、新中55.5、北山公园36.4；登封市的嵩山站36.9、西燕村水库36.2、大冶32.6；荥阳市的石板沟57.8、高山水厂50.7、家子岗45.8、贾峪45.4、广武43.0；新密市的柿树湾87.3、平陌村79.3、平陌77.5、牌坊沟75.5、白寨71.8；新郑市的孟庄63.5、郭店44.8、石固堆41.6、柿树行40.2、苗家沟39.9；中牟县的九龙79.0、白沙71.2、刘集66.8、农业公园65.4、狼城岗53.4；航空港区的香炉朱村44.3、八千35.8、三官庙31.7。 【临近预报】目前登封、新密、新郑、荥阳、郑州市区、中牟有较强降水回波，回波中心强度55dBZ，未来2小时内，回波东北移动，郑州地区降水持续，局地伴有1小时20-30毫米的短时强降水。目前郑州市暴雨橙色预警、雷电黄色预警中。请注意防范。 【天气预报】今天白天到夜里：阴天有小到中雨偏东风：3-4级最高气温：28-29度最低气温：23-24度明天白天：多云间阴天，有分散性阵雨、雷阵雨 7月22日 07:18：河南日报【#河南安阳发布暴雨红色预警# 】河南省安阳市气象台今天04时05分升级发布暴雨红色预警信号：安阳曲沟已出现100毫米以上降水量，可能造成一定影响。请防范强降雨可能引发的城市内涝、山洪等灾害。请一定注意防护 7月22日 07:27：河南日报目前安阳、焦作和鹤壁、新乡两地区西部及郑州西南部仍有强降水回波，回波中心强度55dBz左右。预计未来上述地区强降水持续。注意防范。今天白天，豫北中西部和郑州西南部局地仍有大暴雨或特大暴雨!全省天气预报：22日06时-22日20时豫北的中西部和郑州地区西南部等地有中到大雨，局地大暴雨或特大暴雨（200～250毫米）。郑州有小到中阵雨、西部局部有大雨或暴雨，累计降雨量20～60毫米；最大小时降雨量20～40毫米。22日20时-23日20时河南中西部有小到中雨，局地大雨。郑州阴天间多云，有分散阵雨、雷阵雨。（河南气象） 7月22日 07:42：河南新闻广播#河南雨情# 【新乡雨情信息】7月21日08时至22日07时，新乡市北中部出现大暴雨、特大暴雨，共有42个站点达到特大暴雨（≥250mm），45个站点达到大暴雨（100-250mm），49个站点达到暴雨（50-100mm）。雨量（单位：mm）最大的5个站点依次为：卫辉塔岗531.7、市区的牧野乡514.5、凤凰山495.6、辉县河西460.7、辉县石门水库443.5；市气象局394.7。最大小时雨强出现在新乡市区的牧野乡149.9mm（20-21时）和牧野131.1mm（19-20时）。 【天气预报】从雷达上看，郑州及其西南方向不断有新回波生成、发展，并持续向东北方向移动，将阶段性影响我市。目前，新乡市区将近有1小时的间歇， 1小时后，将开始下一轮降水，预计雨量40-60mm；辉县和卫辉北部仍有暴雨、大暴雨，雨量60-100mm。今天下午新乡市有小到中阵雨、雷阵雨，雨量10-25mm。 7月22日 08:06：河南新闻广播【河南省气象台继续发布暴雨红色预警】河南省气象台2021年07月22日07时50分继续发布暴雨红色预警：安阳、鹤壁、新乡三地区部分地区降水量已达50毫米以上，预计未来3小时内，安阳、鹤壁、新乡、焦作、平顶山五地区降水持续，累积降水量将达100毫米以上。请注意防范。 7月22日 08:11：河南新闻广播#河南雨情# 【新乡市特大暴雨过程情况说明】7月17日08时到22日06时，新乡市出现特大暴雨，最大降水量907mm，新乡市175个站点中700mm以上的有14个站点，600-700mm有26个站点，500-600mm有26个站点，400-500mm有37个站点。最大1小时雨强为149.9mm，最大两小时雨强为267.4mm，最强降水时段出现在20日05时到22日05时，降水量812.0mm。 新乡市有气象记录以来，历史上曾发生两次最强极端天气过程：（1）2000年7月5-7日，我市出现连续性大暴雨，过程最大降水总量583.1mm；（2）2016年7月9日我市出现特大暴雨，过程降水总量450.2 mm，最大小时雨强132.7 mm。 由此可见本次降水过程是新乡市有气象记录以来的最强极端降水过程。 新乡市此次降水过程与郑州市降水过程相比，最大降水总量、最大小时雨强、最大两小时雨强、最强时段降水总量均与郑州相当（最大降水总量郑州931.5mm，新乡907.0mm；一小时雨强郑州201.9mm，新乡149.9mm；两小时雨强郑州262.5mm，新乡267.4mm；最强降水时段郑州48小时807.6mm，新乡812.0mm）。 7月22日 08:13：河南新闻广播#河南雨情# 【安阳市气象台继续发布暴雨红色预警】安阳市气象台2021年7月22日07时05分继续发布暴雨红色预警信号：安阳部分地区已出现100毫米以上降水量且降水持续，可能造成一定影响。请防范强降雨可能引发的城市内涝、山洪等灾害。 7月22日 08:26：河南新闻广播【河南省气象台继续发布雷电黄色】河南省气象台2021年07月22日08时15分继续发布雷电黄色预警：预计未来6小时内，黄河以北和平顶山、郑州、南阳、三门峡、周口、开封六地区和商丘、信阳两地区东部部分地区有雷电活动，局部伴有1小时30到50毫米的短时强降水、8级左右短时大风等强对流天气。 7月22日 08:34：郑州气象#河南暴雨##郑州暴雨#【雨情】07月21日08时至22日08时，我市出现暴雨。最大降水量出现在新密市的柿树湾78.0毫米。降水量在50-99.9毫米的站点有28个，25-49.9毫米的站点有67个，10-24.9毫米的站点有48个。雨量较大的站点有（毫米）：郑州的中原区政府70.7、惠济68.0、丽水中学61.6、市政府60.3、冠军中学54.2；巩义市的小关70.6、巩义蝴蝶谷69.0、文化站57.1、新中55.5、北山公园35.3；登封市的西燕村水库51.0、登封站48.7、纸坊47.7、嵩山站45.0、卢店镇32.3；荥阳市的石板沟53.0、高山水厂47.5、家子岗40.5、贾峪40.0、城关36.5；新密市的柿树湾78.0、新密71.7、牌坊沟71.3、平陌村71.2、平陌70.4；新郑市的孟庄35.8、石固堆33.4、柿树行30.5；中牟县的白沙64.9、九龙61.0、刘集59.7、赵口42.2、东枫杨39.0；航空港区的香炉朱村29.2、三官庙21.7、八千18.0。【临近预报】 郑州市气象台2021年7月22日08:20发布临近预报：目前强回波位于新密、荥阳南、郑州东部、登封东南部，回波中心强度40-45dBZ，未来2小时内，强回波东北移，郑州市区、新郑、中牟有阵雨，局地有1小时20毫米的短时强降水、7级左右的短时大风。目前郑州市暴雨橙色、雷电黄色预警中。请注意防范。 7月22日 08:59：河南日报【注意防范！#河南继续暴雨红色预警#：#安阳鹤壁新乡3小时内降水持续#】河南省气象台2021年07月22日07时50分继续发布暴雨红色预警：安阳、鹤壁、新乡三地区部分地区降水量已达50毫米以上，预计未来3小时内，安阳、鹤壁、新乡、焦作、平顶山五地区降水持续，累积降水量将达100毫米以上。 7月22日 09:38 ：河南新闻广播河南省普降暴雨、大暴雨，昨天夜间，新乡市区牧野站2小时降水267.4毫米，超过郑州20日2小时最大262.5毫米的降雨量，最强降水时段出现在20日05时到22日05时，降水量812.0mm。 7月22日 10:16：郑州气象【雨情】07月22日08时至10时，我市出现阵雨。最大降水量出现在新密市的市水利局2.5毫米。降水量在0.1-9.9毫米的站点有52个。雨量较大的站点有（毫米）：郑州的马寨一中0.6、市气象局0.2；登封市的佛垌水库1.4、玫瑰园1.3；荥阳市的贾峪0.7、槐林0.1；新密市的市水利局2.5、新密2.3；新郑市的唐寨水库0.5、后湖0.1；中牟县的刘集2.2、农业公园1.3；航空港区的八岗0.1。【临近预报】 郑州市气象台2021年7月22日10:05发布临近预报：目前有分散性回波，较强回波位于新郑，回波中心强度30-35dBZ，未来2小时内，郑州市区，新郑有分散性阵雨。请注意防范。 7月22日 10:52 ：河南新闻广播【河南：#66座水库超汛限水位# 最大降雨量984毫米 】7月22日，河南省水文水资源局发布消息：7月21日8时至22日8时，安阳、鹤壁、新乡、焦作、郑州、开封、许昌、平顶山、漯河、南阳、驻马店、信阳市西部普降中到大雨，局部暴雨、大暴雨，鹤壁、新乡市降特大暴雨。最大点雨量鹤壁市新村水文站615mm，安阳县马投涧雨量站595mm。降雨量超500mm站点34处，超400mm站点97处。平均降雨量：全省48mm，鹤壁市398mm，安阳市242mm，新乡市203mm，焦作市107mm，许昌市65mm，漯河市57mm，周口、平顶山、郑州、开封、驻马店、南阳市21～49mm，信阳、濮阳、济源市13～17mm，其他市小于8mm。 7月18日8时至22日8时，累积最大点雨量辉县市龙水梯雨量站984mm、郑州市中原区尖岗水库站905mm。累积平均降雨量：全省174mm，鹤壁市556mm，郑州市517mm，新乡市493，安阳市384mm，焦作市378mm，许昌、平顶山、漯河、开封、济源市200～300mm。 受降雨影响，淇河、大沙河、共产主义渠出现超保洪水，卫河、惠济河、颍河、洪河出现超警洪水。 22日8时，全省有河口村、鸭河口、盘石头、小南海、出山店、五岳、板桥、宿鸭湖、鲇鱼山、白沙、昭平台、白龟山、孤石滩、燕山14座大型水库及田岗、宝泉、石门水库、石包头、正面、塔岗、陈家院、三交口、汤河、琵琶寺、南谷洞、白墙、玉马、尖岗、常庄、李湾、五星、彰武、双泉、马鞍石、弓上、石门（林州）、唐岗、蟒河口、坞罗、大沟口、老鸦河、兔子湖、潭山、火石山、下宋、少林、券门、澎河、腾口、安沟、河陈、楚楼、河王、老观寨、佛耳岗、石门（西峡）、辛庄、廖庄、冢岗庙、龙王沟、彭李坑、陡坡、打磨石岩、打磨岗、高丘、夺丰52座中型水库超汛限水位。 7月22日 10:57：河南新闻广播#雨情速递# 目前强降水回波主要在豫北地区，回波中心强度45～55dBz。预计未来上述地区强降水持续。 今天白天，豫北的中西部和郑州地区西南部等地有中到大雨，局地#大暴雨或特大暴雨# （150～200毫米）。郑州有小到中阵雨、西部局部有大雨或暴雨，累计降雨量20～60毫米；最大小时降雨量20～40毫米。今天夜里，河南中西部有小到中雨，局地大雨。郑州阴天间多云，有分散阵雨、雷阵雨。 7月22日 11:05：河南日报据河南新乡防汛抗旱指挥部，新乡市近日遭遇当地有气象记录以来的最强极端降水过程。7月17日8时到22日6时，新乡出现特大暴雨，最大降水量907毫米。截至21日22时30分，新乡遇极强降雨47万余人受灾。 7月22日 11:10 ：河南新闻广播【安阳宗村红河断坝 消防紧急救援】今天早晨（7月22日）5时50分，安阳消防救援人员赶到龙安区宗村新村，解救被水围困人员。当地红河断坝水流湍急 消防员利用绳索成功救出4名被困群众转移至安全地带。 7月22日 11:43 ：河南日报紧急提醒！郑州西三环建设路高架桥下东西向辅道下已塌方 7月22日 11:46：河南新闻广播【河南省气象台继续发布暴雨红色预警】河南省气象台2021年07月22日11时00分继续发布暴雨红色预警：安阳、鹤壁、新乡、焦作四地区部分地区降水量已达50毫米以上，预计未来3小时内，鹤壁地区和安阳、新乡两地区西部及焦作地区北部降水持续，累积降水量将达100毫米以上。请注意防范。 7月22日 12:13：郑州气象郑州市气象台2021年07月22日11时50分解除2021年07月22日05时43分继续发布的雷电黄色预警信号。 7月22日 12:19：郑州气象【雨情】07月22日10时至07月22日12时，我市出现分散性阵雨。最大降水量出现在中牟县的郑庵镇、新郑市的唐寨水库0.4毫米。降水量在0.1-9.9毫米的站点有10个。雨量较大的站点有（毫米）：郑州的市气象局0.1、惠济0.1；新密市的市水利局0.3、曲梁0.1；新郑市的唐寨水库0.4、常刘社区0.1；中牟县的郑庵镇0.4。【天气预报】今天下午阴天,傍晚到夜里阴天有阵雨；东南风3-4级转东北风2-3级；最高气温：27-28度；最低气温：24-25度。 7月22日 12:42 ：河南日报#河南此轮强降雨已致33人遇难8人失踪#16日以来，此轮强降雨造成河南全省103个县（市、区）877个乡镇300.4万人受灾，因灾遇难33人，失踪8人。 7月22日 12:46：河南新闻广播#河南雨情# 【郑州暴雨橙色预警信号解除】郑州市气象台今天上午11时50分解除了在05时43分继续发布的雷电黄色预警信号。统计数据显示，今天上午10时至12时，郑州市出现分散性阵雨。最大降水量出现在中牟县的郑庵镇、新郑市的唐寨水库0.4毫米。降水量在0.1-9.9毫米的站点有10个。 郑州市气象台预报显示：郑州今天下午阴天,傍晚到夜里阴天有阵雨；东南风3-4级转东北风2-3级；最高气温：27-28度；最低气温：24-25度。 7月22日 13:00：河南新闻广播【新乡市气象局发布最新雨情信息】今天（7.22）中午12点，新乡市气象局发布最新雨情信息：7月21日20时至22日12时，新乡市北中部出现大暴雨、特大暴雨，共有18个站点达到特大暴雨（≥250mm）。最大的5个站点依次为：卫辉塔岗362.3、凤泉凤凰山359.7、辉县石圪节345.9、辉县水利局344.5、辉县国家站343.0。最大小时雨强出现在新乡市区的牧野乡149.9mm（20-21时）和关堤乡119.6mm（20-21时）。 目前较强回波位于新乡辉县市、卫辉市和延津县北部，未来3小时内上述地区仍将有大到暴雨，雨量30-50mm。其它地区是分散性阵雨、雷阵雨。 7月22日 13:22：河南新闻广播#河南雨情# 【雨量速递丨鹤壁全市平均降水量601.5毫米】7月17日8时-22日12时：鹤壁市出现历史罕见的持续性强降水天气过程，出现暴雨、大暴雨，局部特大暴雨天气。全市平均降水量601.5毫米,最大降水站点出现在淇滨区科创中心1113.5毫米。 2021年7月21日20时-22日12时:鹤壁市大部分地区出现大到暴雨、局部大暴雨。最大雨量站点淇滨区科创中心378.8mm，最大小时雨强淇滨区科创中心67.4mm/h。具体雨情如图： 目前仍有降水回波维持在鹤壁市上空。预计今天下午鹤壁市有中到大雨，局部暴雨，夜里阴有阵雨，偏东风3～4级，温度23～26℃。23-24日多云。（河南台记者张宇鹏 鹤壁台） 中国新闻周刊【#国家电网回应郑州大面积断电#：全力抢修 预计23点恢复 】#郑州预计23点恢复供电# 7月21日，河南暴雨致多地大面积断网断电。国家电网回应@中国新闻周刊 称，系恶劣天气引发用电故障，目前正加急抢修，预计21日23点恢复供电。","tags":[]},{"title":"android+baidu sdk 显示地图+切换地图","date":"2021-07-22T10:53:31.510Z","path":"2021/07/22/android+baidu sdk 显示地图+切换地图/","text":"获取开发密钥(AK) 登录百度账号 进入API控制台 点击“创建应用”开始申请开发密钥 填写应用名称，注意应用类型选择“Android SDK”、正确填写SHA1 和 程序包名 Android Studio配置 在项目中集成BaiduMap SDK，下载开发包 开发包拷贝至工程，添加jar文件，打开解压后的开发包文件夹，将其拷贝至工程的app/libs目录下 在app目录下的build.gradle文件中android块中配置sourceSets标签，如果没有使用该标签则新增，详细配置代码如下： 12345sourceSets &#123; main &#123; jniLibs.srcDir &#x27;libs&#x27; &#125; &#125; 注意：Jar文件和so文件的版本号必须一致，并且保证Jar文件与so文件是同一版本包取出的。 往工程中添加jar文件，在libs目录下，选中BaiduLbs_Android.jar右键，选择Add As Library 显示地图 配置AndroidManifest.xml文件 在中加入开发密钥（AK） 12345&lt;application&gt; &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;0GLoGxs9hOhfMgxee9XvGggBn0TR7CSO&quot; /&gt; &lt;/application&gt; 在外部添加如下权限声明 123456789&lt;!-- 访问网络，进行地图相关业务数据请求，包括地图数据，路线规划，POI检索等 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;!-- 获取网络状态，根据网络状态切换进行数据请求网络转换 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;!-- 读取外置存储。如果开发者使用了so动态加载功能并且把so文件放在了外置存储区域，则需要申请该权限，否则不需要 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 写外置存储。如果开发者使用了离线地图，并且数据写在外置存储区域，则需要申请该权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 在布局文件中添加地图容器 12345&lt;com.baidu.mapapi.map.MapView android:id=&quot;@+id/bmapView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clickable=&quot;true&quot; /&gt; 地图初始化 新建一个自定义的DemoApplication （继承Application类），在其onCreate方法中完成SDK的初始化。 在AndroidManifest.xml文件中声明该Application 1android:name=&quot;DemoApplication&quot;&gt; 在MainActivity.java的onCreate函数中获取地图控件引用 12mMapView = findViewById(R.id.bmapView);mBaiduMap = mMapView.getMap(); 在MainActivity.java中添加管理MapView生命周期函数代码 切换地图 在activity_main.xml中添加RadioGroup，在RadioGroup内添加三个RadioButton和一个Button 设置宽高参数并添加点击事件给Radio组 在MainActivity.java中添加Radio组点击事件的处理函数 在MainActivity.java中添加Button的点击事件的处理函数，清除地图缓存数据，支持清除普通地图和卫星图缓存，再次进入地图页面生效。 在MainActivity.java的onCreate函数中构建地图状态，实例化经纬度center和缩放等级zoom对象 12345MapStatus.Builder builder = new MapStatus.Builder();LatLng center = new LatLng(34.368774, 107.882718);float zoom = 11.0f; 将zoom赋值给center的zoom属性，将center赋值给builder的target属性，通过地图状态对象(builder)实例化地图状态更新对象 12345builder.target(center).zoom(zoom);MapStatusUpdate mapStatusUpdate = MapStatusUpdateFactory.newMapStatus(builder.build());mBaiduMap.setMapStatus(mapStatusUpdate); 7. 运行查看效果","tags":[]},{"title":"【研】遥感考点汇总","date":"2021-07-22T10:53:31.508Z","path":"2021/07/22/【研】遥感考点汇总/","text":"考点一：遥感的基本概念 广义：指各种非接触的、远距离的探测技术，即不直接接触物体本身,在远处通过传感器探测和接收来自目标物体的电磁信息，经过信息的传输及其处理分析，识别物体的属性及分布等特征的技术。 狭义：指从远处，高空，乃至外层空间的平台上，利用可见光、红外，微波等，通过摄影、扫描等各种方式，获取来自地球表层各类地物的电磁波信息，对这些信息进行加工处理，从而识别地面物质的性质和运动状态的综合技术。 考点二：遥感平台与传感器遥感平台： 地面平台：&lt;300米，波谱测试，试验研究用地物细节图像 航空平台：100-30000米，飞机、飞艇、气球等 航天平台：在超出大气的地球附近空间或太阳系各行星飞行间的飞行器。高度：百千万公里。人造地球卫星、探空火箭、宇宙飞船、航天飞机、太空站等。 宇航遥感 卫星轨道参数 卫星轨道面与赤道面的相对位置 升交点赤经Ω ：升交点和赤道面春分点的夹角 近地点角距 ：轨道平面近地点和升交点的夹角 轨道倾角 ：轨道面和赤道面的夹角 卫星过近地点时刻：卫星与近地点之间的角距 卫星轨道的形状 卫星轨道长半轴 卫星轨道扁率 传感器： 按工作方式：主动遥感、被动遥感 按传感器的：可见光遥感、微波遥感 按成像方式： 摄影成像传感器 扫描成像传感器 点扫描成像（光机扫描）：Landsat 线推扫成像（固体自扫描）：SPOT 雷达成像传感器 （天线扫描） 非图像传感器 无论哪种类型遥感传感器,它们都由以下基本部分组成： 收集器:收集地物辐射来的能量。具体的元件如透镜组、反射镜组、天线等。 探测器:将收集的辐射能转变成化学能或电能。具体的元器件如感光胶片、光电管、光敏和热敏探测元件、共振腔谐振器等。 处理器:对收集的信号进行处理。如显影、定影、信号放大、变换、校正和编码等。具体的处理器类型有摄影处理装置和电子处理装置。 输出器:输岀获取的数据。输出器类型有扫描晒像仪、阴极射线管、电视显像管磁带记录仪、彩色喷墨仪,等等。 扫描成像类传感器： 是逐点逐行以时序方式获取的二维图像，有两种： 一对物面扫描的成像仪（如：红外扫描仪、 MSS 多光谱扫描仪、成像光谱仪等） 。 二对像面扫描的成像仪（如：线阵列 CCD 推扫式成像仪、电视摄像机等） 。 landsat（美）、spot（法）、irs（印度）卫星 特点：多波段扫描 Landsat1-3（MSS多光谱扫描仪） 结构： 扫描反射镜（摆动频率、视场角） 反射镜组：收集能量的 成像板（24+2玻璃纤维元） MSS 4-7 空间分辨率 79 * 79 MSS 8 空间分辨率 240 * 240 热红外波段 没有蓝波段：受大气影响大，不能合成真彩色 探测器：将辐射能转变为电信号输出 输出：数字影像（2340行 * 2340列）、采样后影像分辨率（57m * 57m） 成像过程 从左至右，垂直飞行方向逐点扫描，得到一条相应于地面的图像线 飞机向前运动，第二次扫描得到第二条扫描线 扫描线的衔接 扫描周期：73.42s 速度：6.5km/s 扫描瞬间。 像元的地面分辨率=瞬时视场 * 卫星高=79m 六个探测元：474 * 79 m 扫描一次 总视场：11.56° 地宽：185km 分辨率（———（一）33min） 影像特征： 几何：全景变形，空间分辨率79m 波谱：Landsat1-3有5个波段，MSS4（绿）、MSS5（红）、MSS6（红外）、MSS7（红外）、MSS8（热红外） 合成假彩色识别地物 TM专题制图仪 探测器（光机扫描）： 100个，分七个波段错开排列 TM1-5、7有16个，30m * 30m TM6有4个，120m * 120m 扫描 增加了一个扫描改正器，使扫描垂直于飞行轨道 往返双向扫描 影像特征： 几何：全景变形，空间分辨率30m 光谱： 通道 波长 特征 TM1 0.45-0.52 清洁水、针叶林 TM2 0.52-0.6 植物 TM3 0.63-0.69 土壤、地质边界 TM4 红外 0.7-0.9 植物（红外反射高峰） TM5 红外 1.55-1.75 干旱、NDVI TM6 热红外 10.4-12.6 植物、热惯量 TM7 红外 2.08-2.35 植物、地质 ETM+增强型专题制图仪（L7） 增加全色波段，分辨率15m ETM+6波段分辨率提高到60m 辐射定标精度较L5提高一倍 SPOT系列卫星 属性 装载了HRV 属于CCD线阵列推扫式成像 不可能合成真彩色，没有蓝波段 反射镜左右倾斜最大为27°，可立体观测，邻轨立体 SPOT1/2/3 两部HRV（高分辨率）影像仪 在P（全色）模式和M（多光谱）模式下工作 幅宽60km 成像 以推扫方式获取沿轨道的连续图像条带多光谱型的HRV（固体自扫描） 三个谱段，每个有3000个CCD元件组成 每个元件形成的像元对地20 * 20m 全色的HRV 波段范围：0.51-0.73微米，6000个CCD元件组成一行 对地10 * 10m 比较 SPOT4 全色波段0.51-0.73微米改为061-0.68微米 增加一个SWIR（短红外）波段 增强了影响纹理的清晰度 水域、湖泊更清晰 对土壤、植被的湿度敏感，可以分辨土壤类型和植被的生长期 植被长势好，生长茂密，颜色鲜艳 载有植物探测器 广角的地面观测仪（带宽200km） 1km的空间分辨率 载有POAM3，极地臭氧和烟雾测量仪 数据存储能力 星载记录器记录能力从22min提高到40min 增加了一个10G的固态，延长设计寿命，可靠性提高 精确定位，卫星位置精确到10cm，实时位置精确到几十米 SPOT5 主载HRG几何成像、立体成像装置 分辨率在P模式下从10m到5m和2.5m，重用S1-3的0.51-0.73微米 在M模式下所有的3个可见光波段的分辨率从20m提高到10m 地面带宽120km 获取同规立体影像 定位精度提高3-5倍，满足1：5万地形图 采用多组陀螺仪测算卫星姿态，利用恒星定位技术调整姿态，使卫星姿态参数高度准确 成像 两幅5m影像处理生成2.5m图像 影像特征 几何：没有全景变形 波谱：PAN0.49-0.69，多光谱：绿，红，近红外，短波红外。 与TM2-4相同，波谱响应曲线用于识别地物 中巴地球资源卫星 在轨高度778km，一圈T为100.26min 配置相机（02） 2.36m分辨率，27宽幅的高分辨率全色相机 19.5m分辨率，113km幅宽的多光谱CCD相机 258m分辨率，890km幅宽的宽视场成像仪 资源三号 1台分辨率优于2.1m的正视全色TDI CCD相机 2台优于3.5m的前视、后视全色TDI CCD相机 1台优于5.8m的正视多光谱相机 雷达成像传感器： SAR（合成孔径雷达）类卫星 雷达成像原理（天线扫描） 被动微波遥感（受太阳光限制）和主动微波遥感 后向散射回波：天线将微波短脉冲，侧向发射出去，以窄的扇形波束扫过地面一条窄带。微波遇目标后发生反射和散射。 每发射一个脉冲形成一条影响线，而与平台运行速度同步移动的胶片完成航向地面覆盖，形成连续条带状雷达影像。 极化方式 雷达波束具偏振性，又称极化。 若雷达波的偏振方向垂直于入射面称为水平极化（H） 若雷达波的偏振方向平行于入射面称为垂直极化（V） 同向极化 水平发射、水平接收（HH） 垂直发射、垂直接收（VV） 交叉极化 水平发射、垂直接收（HV） 垂直发射、水平接收（VH） 侧视雷达图像的特征：（传感器二） 几何特征：造成山体前倾，朝向传感器的山坡影像被压缩，而背向传感器的山坡被拉长，还会出现不同地物点重影现象。 色调特征： 与入射角有关： 朝向飞机方向的坡面—反射强烈—很亮 朝天顶方向—弱些—较亮 背向飞机方向—反射很弱(没回波)—很暗 与粗糙程度有关 地面地物微小起伏小于雷达波波长—镜面漫反射—很暗 地面微小起伏大于或等于发射波长—漫反射—较亮 “角隅反射”—–反射波强度更大—很亮 其他：有较强的穿透能力 真实孔径雷达 RA-SLR 工作原理 地面各点到飞机的距离不同，接收机接收到许多信号，以它们到飞机距离的远近，先后依序记录。 信号的强度与辐照带内各种地物的特性、形状和坡向等有关。 距离分辨率：在脉冲发射的方向上，能分辨两个目标的最小距离 地距分辨率：越远的地物越能分清。采用脉冲压缩技术以减小脉冲宽度，以提高分辨率，但t过窄能量太弱,对测目标不利。 斜距分辨率 方位分辨率：相邻的两束脉冲之间，能分辨两个目标的最小距离。越近的地物越能分清。 要提高分辨率，在入一定时，要提高RB。须加大D或缩短R，而在平台上安装过长天线不现实、缩短斜距又要限制雷达的作用距离。 合成孔径雷达 SA-SLR 原理：用一个小天线作为单个辐射单元,将此单元沿一直线不断移动。模拟线性天线阵，应用多普勒效应和数据处理技术，用一个小天线合成一个大孔径(天线)使方位分辨率提高几十至几百倍 方位分辨率：只与实际使用的天线孔径有关，短一些，分辨率会高，太短会影响微波的发射。 INSAR相干雷达 INSAR就是利用SAR在平行轨道上对同一地区获取两幅（或两幅以上）的单视复数影像来形成干涉，进而得到该地区的三维地表信息。 该方法充分利用了雷达回波信号所携带的相位信息，获得同一区域的重复观测数据（复数影像对），综合起来形成干涉，得到相应的相位差，结合观测平台的轨道参数等提取高程信息。心 考点三：遥感图像处理遥感数据接收后，由接收部门进行初（粗）纠正，仅作系统误差的改正，但处理后的还有很大的残差（系统误差和偶然误差） 几何校正 粗纠正 以TM纠正为例，根据成像方程获取投影中心坐标、传感器姿态角、扫描角 精纠正 消除图像中的几何变形 过程： 模型的选择与参数的确定 像素坐标的变换 像素亮度值进行重采样 精度评价 方法： 多项式：地形起伏面积不大的区域，地理编码的图像 变换公式： x，y为某像素原始图像坐标 X，Y为同名像素的地面坐标 纠正内容 一次项纠正：因平移、旋转、比例尺变化等引起的线性变形。 二次项纠正：一次项变形的基础上，改正二次非线性变形。 三次项纠正：改正更高次的非线性变形。 求系数：最小二乘法 控制点的要求 在图像上为明显的地物点，易于判读 在图像上均匀分布 数量足够 灰度值的重采样 坐标值不为整数点没有灰度值，把邻近点位上亮度值对该点的灰度贡献积累起来。 双三次卷积法（周围16个点）—计算量大 线性内插法（4）—-平滑对灰度值有一定的影响 最邻近法—辐射的保证都很好，几何位置的差别 加入高差改正的CCD线阵影像多项式纠正 先改正因地形引起的变形，然后用一般多项式来拟合，改正其他的变形。 重采样时则相反，先根据多项式参数求得未受高差影响的像点指标，然后加上投影差，从而获得真实的像点坐标。 共线方程：像点，投影中心，定位点之间的关系，正射影像。 需要有DEM信息，建立在图像坐标与地面坐标严格数学变换关系的基础上，对成像空间几何形态的直接描述。 框幅式图像共线方程，六个外方位元素（POS系统/后方交会获取） 单像空间后方交会以单景图像为基础，从该图像所覆盖范围内若干已知地面控制点和其同名像点坐标，根据共线方程，解求该图像获取时的外方位元素。每一个同名点可以列出2个方程，因此至少需要3个已知地面控制点和相应的像点坐标通过最小二乘平差就可以解算6个外方位元素。 有理函数：图像传感器参数未知时 一般由图像提供者提供，为了保密需要，隐藏了传感器参数 提供有理系数,有理函授模型与共线方程是等价的 误差一般不超过0.1像素。 如果图像提供者提供了有理函数的系数，直接用有理函数模型对图像进行纠正。 纠正过程： 根据成像方式确定图像坐标和地面坐标之间的数学模型 根据地面控制点和对应像点坐标进行平差计算变换参数，评定精度 对原始图像进行几何变换计算和值重采样 对纠正结果进行精度评定 辐射校正 消除或改正成像过程中附加在传感器输出的辐射能量中的各种噪声的过程。 辐射误差： 传感器本身的性能 地形和光照条件变化 大气的散射和吸收 实验室定标 光谱定标：确定遥感传感器每个波段中心波长和带宽，以及光谱响应函数。 辐射定标（传感器定标） 绝对定标：通过各种标准辐射源，在不同波谱段建立成像光谱仪入瞳处的光谱辐射亮度值与成像光谱仪输出的数字量化值之间的定量关系 相对定标：确定场景中各像元之间、各探测器之间、各波谱之间以及不同时间测得的辐射量的相对值。 机上和星上定标 机上定标用来检查飞行中的遥感器定标情况，采用内定标的方法，即辐射定标源、定标光学系统都在飞行器上，在大气层外。可以选择太阳作为基准光源，通过太阳定标系统对星载成像光谱仪器进行绝对定标。 场地定标 遥感器正常运行条件下，选辐射定标场地，通过地面同步测量对遥感器的定标，可以实现全孔径、全视场、全动态范围的定标，考虑了大气传输和环境的影响。 可以实现对于遥感器运行状态下与获取地面图像完全相同条件的绝对校正，可以提供遥感器整个寿命期间的定标，对遥感器和模型进行正确定检验。 优点：实现了对遥感器运行状态下与获取地面图象完全相同条件的绝对校正。 不足：需要测量和计算空中遥感器时顶的大气环境和地物反射率。 太阳高度角和地形影响引起的辐射误差校正 通过两个波段的比值基本消除 大气校正 基于地面场地数据或辅助数据 将地面测定的结果与卫星图像对应的亮度值进行回归分析 大气模型 需要有关大气假设或成像时刻的大气参数（气压、温度、水汽、臭氧等）气体中的悬浮物类型，高度，太阳高度角，传感器的视角等 基于波段 回归分析法：将两个带比较波段亮度值进行会归分析，得到的差别就是大气的影响。 直方图法：若图像中存在亮度为零的目标，如深海水体、阴影等，只有在没有受大气影响的情况下，其亮度值才可能为零 图像融合 目的：提高分类精度 提高空间分辨率 改善配准精度 增强目标特征 提高分类精度 信息互补 考点四：遥感影像分类 监督分类 确定感兴趣的类别数 特征变换和特征选择 选择训练样区（准确性、代表性和统计性） 确定判决函数和判决规则 根据判决函数和判决规则对非训练样区的图像区域进行分类 K-均值聚类法 准则：点到类别中心的距离的平方和最小。 思想：通过迭代，逐次移动各类的中心，直至得到最好的聚类结果为止。 步骤： 选择m个类的初始中心 按照到类中心距离最小的原则对像元分类 重新计算类中心 类中心不变，算法结束；否则返回(2) IOSDATA算法聚类分析 步骤： 初始化； 选择初始中心； 按一定规则(如距离最小)对所有像元划分； 重新计算每个集群的均值和方差；按初始化的参数进行分裂和合并； 结束，迭代若干次数或者两次迭代之间类别均值变化小于阈值 否则，重复3-5； 确认类别，精度评定. 平行管道法聚类分析 它以地物的光谱特性曲线为基础，同类地物在特征空间上表现为以特征曲线为中心，以相似阈值为半径的管子 实质上是一种基于最邻近规则的试探法。 监督分类与非监督分类的结合 选择一些有代表性的区域进行非监督分类。 获得多个聚类类别的先验知识。 特征选择。选择最适合的特征图像进行后续分类。 使用监督法对整个影像进行分类。 输出标记图像。 分类后的处理 为什么？ 用光谱信息对影像逐个像元地分类，在结果的分类地图上会出现“噪声” 。分类是正确的，但某种类别零星分布于地面，占的面积很小 ，希望用综合的方法使它从图面上消失。 分类平滑技术 采用邻区处理法。 平滑时中心像元值取周围倒数的类别。 混淆矩阵（计算） 行：错分。用户精度 列：漏分。制图精度 1234Kappa系数 = （ Pa - Pe ）/ （ 1 - Pe ）Pa = （ P11+P22+...+Pnn）/ ( P )Pe = ( P1+ * P+1) + ( P2+ * P+2) + ... +( Pn+ * P+n) / P^2 提高分类精度 分类前预处理 校正（辐射、几何） 变换 空间信息提取（纹理） 分类树与分层分类 一次分类不能满足精度要求时，进行多次分类 混合分类 监督法与非监督法 多种信息复合 遥感信息非遥感信息 与GIS集成 GIS与遥感数据复合分类 间接支持分类 用于选样区，检验样区，纠正等 基于目标的遥感图像分类 考点五：遥感技术应用 遥感应用：根据遥感数据的性质和特点，对遥感数据进行处理与解译，得到遥感信息，并对遥感信息分析与处理，最后得到遥感应用产品。 环境灾害检测中的应用 快速监测洪涝灾情 数据获取（正常高分辨率遥感数据） 对水敏感的波段（SPOT、TM，需要有太阳） 改用主动式雷达图像监测水域的变化 监测沙尘暴 沙尘暴天气卫星图片特征分析 云系特征 云顶反照率 影像高度 面积计算 森林火灾监测 臭氧层监测 臭氧对0.3 um以下的紫外区的电磁波吸收严重，可以用紫外波段来测定臭氧层的臭氧含量变化。 在2.74mm处一个吸收带，因此可用频率为11083MHz的地面微波辐射计或射电望远镜来测定臭氧在大气中的垂直分布。 臭氧层由于吸收太阳紫外线而增温，因此又可使用红外波段来探测。 海洋赤潮监测 赤潮水体有两个吸收峰和两个反射峰。 两个吸收峰,其中一个在440～460 nm的蓝光波段，一个在650～670 nm的红光波段 两个反射峰,其中一个在560～580nm的绿光波段（悬浮物引起），一个在690～ 710nm（赤潮生物引起）的红光波段。 测绘中的应用 利用卫星影像修测地形图 速度快、费用低。 地形一般不会发生大变化，主要修测城镇居民地、道路交通、水系及部分地物类型。 陆地地形图测绘 邻轨立体影像 SPOT图像的高程信息提取方法 SPOT卫星上的HRV推扫式扫描仪，是通过控制仪器的一个平面反射镜旋转角度的方法，实现轨道间的立体摄影。SPOT卫星图像提取高程的方法，可以利用一级产品，在光学机械式立体测图仪或解析测图仪上提取高程信息，也可使用数字测图仪获取高程信息。 浅水区的地形测绘 电磁波对水有一定的透射能力，因此传感器除了接受到水面的反射、辐射外，在某种情况下还接受到透过水层底面上反射回来的电磁波，这就有可能用这种信息来测量水深或水底地形。 研究主要集中在两个方面: 水对哪些波区的电磁波有透射特性，透射强度与水深的关系 水质对电磁波透射和反射的影响 水深&lt;—模型—&gt;透射强度和水质 南极冰面地形地貌测绘 地面高程信息提取 问题： 南极地区自然环境和气候条件恶劣 人工测量无法进行 航空摄影有困难（同名点难获取，高程信息） 卫星影像克服了以上困难,但大多制作平面影像图·目前只有等高距500m或1000m的地形图并且精度很差 利用热图像来提取南极冰盖表面的高程信息 温度（红外影响）&lt;—模型—&gt;高程 冰貌信息提取 通过对图像的辅助目视判读方法实现。 主要依据各种冰川类型在图像上的空间特征和光谱特征进行判读。 对于TM七个波段，在冰上反映冰貌空间和光谱特征最好的是TM4,3,2。TM1只能区分冰雪与非冰雪的界线，TM5,7可调查湿度、冰雪溶解特点等，TM6如前所述提取冰面高乘信息。 地质调查中的应用 地质构造解译 遥感卫星图像上对各种地貌类型显示的十分清楚，如山地和平原的交界、支流河谷的线性排列、洪积扇、断裂、褶皱等等。 卫星影片上还能发现一些沉积岩层下的隐状岩体或松散沉积物下的隐伏构造。由于卫片视域范围大，能将模糊的断断续续的构造特征以宏观的角度从图像上判析出来。 岩性分类 调查地质灾害 农林牧等方面的应用 农作物估产 分析作物冠层及其背景的反射光谱特征，引入和计算植被指数 进一步确定植被指数与叶面积指数之间的关系及与作物产量的关系 确定值土比，并根据植土比分析遥感植被指数与作物种植面积的关系 分析遥感植被指数与植土比和叶面指数的综合关系，并据此进行作物估产 土壤解译 光谱反射率 土壤本身特性对土壤反射率的影响 土壤指数 在森林立地类型调查中的应用 一定的空间位置与之相关环境因子的总和，凡具有相同或相似的林木环境和生长效果的地段谓之一种立地类型 立地因子 —–&gt; 水热因子（热红外影响）+土壤因子（土壤主分量）+植被因子（NDVI） 考古方面的应用 遥感图像是对地物的宏观反映，用来考古调查能避免野外工作花费大量时间、经费和精力，减轻劳动强度。此外，遥感图像可使我们得到一个整体的观念，具有指导性，避免野外工作的盲目性。 遥感考古是一种非破坏性的研究，它无法在不触及文化遗迹的情况下精确确定遗迹的位置、形状、大小等。对现已埋没地表下的古沟渠、古河道或大型建筑物等，在信息丰富的遥感资料上有时能很清楚的反映出来。 航片或卫片具有很强的资料性，特别对那些文化发源地区，已被后期发掘破坏掉的遗迹，可保留原貌，供以后恢复和进一步研究使用。 旅游资源开发中的应用 检测保护 应用遥感技术可以监测与探测旅游资源与旅游环境所遭受的不同形式、不同程度的破坏，以便采取措施使其不再遭受破坏或对已破坏的部分提供修复和重建的依据，如利用近景摄影的方法可将古迹空间特数据及色泽保存起来，一旦遭破坏可根据保存的数据按原样复原。 探测南极陨石分布","tags":[]},{"title":"（Vue bug记录）关于Vue ui打开控制面板的时候，遇到GUI卡住没有自动弹出管理器","date":"2021-07-22T10:53:31.505Z","path":"2021/07/22/[Vue bug记录] 关于Vue ui打开控制面板的时候，遇到GUI卡住没有自动弹出管理器/","text":"问题：Vue ui打开控制面板的时候，卡在这个界面 解决在你cmd打开的默认目录下输入explorer %cd%，打开.vuerc文件（记事本或者文本编辑器都可以），把第一个使用淘宝镜像的设置改为true 问题2在经历上面的修改后的若干天后，又出现了 解决2和上一个解决相同操作，改为false，或者换个网络","tags":[]},{"title":"（完美解决！）关于Vue+Leaflet添加market时，图片不显示的问题","date":"2021-07-22T10:53:31.503Z","path":"2021/07/22/（完美解决！）关于Vue+Leaflet添加market时，图片不显示的问题/","text":"解决1重新引用一下icon，这样做的问题是引用的图片，默认点位和图片的左上角重合，会有偏移量。通过设置iconAnchor，改变偏移量[icon长的一半，宽]，这样默认icon的角点和坐标的偏移量会缩小到2px内。要去精度高的需要在调一调 12345678910import icon from &#x27;leaflet/dist/images/marker-icon.png&#x27;const DefaultIcon = L.icon(&#123; iconUrl: icon, iconAnchor: [10, 41] &#125;) L.Marker.prototype.options.icon = DefaultIcon const marker = L.marker(that.centerPoint, &#123; icon: DefaultIcon &#125;).addTo(that.mapObj) 解决2 (完美！！！)找到leaflet.css文件覆盖以下样式 1234/* Default icon URLs */.leaflet-default-icon-path &#123; background-image: url(https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/images/marker-icon.png);&#125; 实测好久终于解决了！！！！！！","tags":[]},{"title":"逻辑关系词","date":"2021-07-22T10:53:31.461Z","path":"2021/07/22/逻辑关系词/","text":"1. 对比 转折： 12but, however, yet, by contrast, onthe contrary, contrarily, on the other hand,unfortunately, unexpectedly 让步： 12although, though, even though, even if , even, in spite of,despite, nevertheless, much as,while ,whereas , as 其他 1rather than,instead of, against , unlike,not...but, In fact 2. 因果123because , in that , as, since,for，as a result of，so that,lead to，consequently，owing to , due to, as a result,so, thus, therefore, hence; perhaps 3. 举例12for example/instance, such as,to take an example, to illustrate, in particularaccording to = on the basis of 4. 递进12also, then, besides, in addition,additionally, moreover, what&#x27;s more, furthermore, indeed = sure enough , above all 5. 条件12if, only if , unless , with other wise , suppose/ing, provide/ed , as soon as , as long as, in case 6. 并列12and, and also , neither...nor.. , either...or , not only...but also , likewise , similarly, equally , in the same way , meanwhile","tags":[]},{"title":"空间查询、属性查询","date":"2021-07-22T10:53:31.454Z","path":"2021/07/22/空间查询、属性查询/","text":"效果图空间查询：框选查询结果： 属性查询： 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;template&gt; &lt;div id=&quot;home&quot;&gt; &lt;!--面包屑导航区域--&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;&gt;Home&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;Query&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;QueryTask&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;el-row :gutter=&quot;20&quot;&gt; &lt;el-col :span=&quot;15&quot;&gt; &lt;div class=&quot;grid-content bg-purple&quot;&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;9&quot;&gt; &lt;div class=&quot;grid-content bg-purple&quot;&gt; &lt;el-row&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-add-location&quot; circle plain id=&quot;draw-point&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle plain id=&quot;draw-line&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit-outline&quot; circle plain id=&quot;draw-polygon&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-close&quot; circle plain id=&quot;draw-dischoose&quot;&gt;&lt;/el-button&gt; &lt;/el-row&gt; &lt;div class=&quot;demo-input-suffix&quot;&gt; &lt;el-input placeholder=&quot;属性查询&quot; prefix-icon=&quot;el-icon-search&quot; clearable v-model=&quot;selecttext&quot; id=&quot;select&quot;&gt; &lt;/el-input&gt; &lt;/div&gt; &lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot;&gt; &lt;template v-for=&quot;(item, index) in columnData&quot;&gt; &lt;el-table-column :label=&quot;item.label&quot; :prop=&quot;item.prop&quot; :key=&quot;index&quot;&gt;&lt;/el-table-column&gt; &lt;/template&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as esriLoader from &#x27;esri-loader&#x27;import $ from &#x27;jquery&#x27;export default &#123; data() &#123; return &#123; lendgeVisible: true, selecttext: &#x27;&quot;地址&quot; LIKE \\&#x27;%大学\\&#x27;&#x27;, columnData: [], tableData: [] &#125; &#125;, mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.28&#x27; &#125;) const that = this this.createMap(that) &#125;, methods: &#123; createMap: function (that) &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;dojo/dom&#x27;, &#x27;dojo/on&#x27;, &#x27;esri/tasks/QueryTask&#x27;, &#x27;esri/tasks/query&#x27;, &#x27;dojo/query&#x27;, &#x27;esri/Color&#x27;, &#x27;esri/toolbars/draw&#x27;, &#x27;esri/symbols/SimpleMarkerSymbol&#x27;, &#x27;esri/symbols/SimpleLineSymbol&#x27;, &#x27;esri/symbols/SimpleFillSymbol&#x27;, &#x27;esri/graphic&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, ArcGISDynamicMapServiceLayer, dom, on, QueryTask, Query, query, Color, Draw, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Graphic]) =&gt; &#123; const filts = [&#x27;城市名&#x27;, &#x27;监测点&#x27;, &#x27;地址&#x27;, &#x27;纬度&#x27;, &#x27;经度&#x27;, &#x27;AQI&#x27;] var queryTask = new QueryTask(&#x27;http://localhost:6080/arcgis/rest/services/Basic/China_POI/MapServer/0&#x27;) const lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3) const markerSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 10, lineSymbol, new Color([215, 224, 203])) const fillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol) var map = new Map(&#x27;mapDiv&#x27;, &#123; center: [108.934518, 34.35333], zoom: 5, logo: false, basemap: &#x27;oceans&#x27; &#125;) var layer = new ArcGISDynamicMapServiceLayer(&#x27;http://localhost:6080/arcgis/rest/services/Basic/China_POI/MapServer&#x27;) map.addLayer(layer) on(dom.byId(&#x27;select&#x27;), &#x27;keypress&#x27;, () =&gt; &#123; map.graphics.clear() var query = new Query() query.where = $(&#x27;#select&#x27;).val() queryTask.execute(setQuery(query), showQueryResult) &#125;) // 空间查询 var toolbar = new Draw(map) $(&#x27;#draw-point&#x27;).click((event) =&gt; &#123; map.graphics.clear() toolbar.activate(Draw.POINT, &#123; showTooltips: true &#125;) &#125;) $(&#x27;#draw-line&#x27;).click((event) =&gt; &#123; map.graphics.clear() toolbar.activate(Draw.POLYLINE, &#123; showTooltips: true &#125;) &#125;) $(&#x27;#draw-polygon&#x27;).click((event) =&gt; &#123; map.graphics.clear() toolbar.activate(Draw.POLYGON, &#123; showTooltips: true &#125;) &#125;) $(&#x27;#draw-dischoose&#x27;).click((event) =&gt; &#123; toolbar.deactivate() map.graphics.clear() that.columnData = &#x27;&#x27; &#125;) // 绘图事件 on(toolbar, &#x27;draw-complete&#x27;, (result) =&gt; &#123; toolbar.deactivate() var query = new Query() query.geometry = result.geometry queryTask.execute(setQuery(query), showQueryResult) &#125;) // 设置筛选公共参数 function setQuery(query) &#123; query.returnGeometry = true query.outFields = filts return query &#125; // 显示 function showQueryResult(queryResult) &#123; // console.log(queryResult) setgraphic(queryResult) setTable(queryResult) &#125; function setSym(type) &#123; switch (type) &#123; case &#x27;esriGeometryPoint&#x27;: return markerSymbol case &#x27;esriGeometryLine&#x27;: return lineSymbol case &#x27;esriGeometryPolygon&#x27;: return fillSymbol &#125; &#125; function setgraphic(queryResult) &#123; for (let i = 0; i &lt; queryResult.features.length; i++) &#123; var graphic = queryResult.features[i] graphic.setSymbol(setSym(queryResult.geometryType)) map.graphics.add(graphic) &#125; &#125; function setTable(queryResult) &#123; var coldata = [] var filed = queryResult.fieldAliases for (var item in filed) &#123; var col = &#123; prop: &#x27;&#x27;, label: &#x27;&#x27; &#125; col.prop = item col.label = filed[item] coldata.push(col) &#125; that.columnData = coldata var data = [] for (let i = 0; i &lt; queryResult.features.length; i++) &#123; data[i] = queryResult.features[i].attributes &#125; that.tableData = data &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt; .MapClass &#123; width: 100%; height: 830px; &#125; .el-row &#123; margin-bottom: 20px; &amp;:last-child &#123; margin-bottom: 0; &#125; &#125; .el-col &#123; border-radius: 4px; &#125; .bg-purple-dark &#123; background: #99a9bf; &#125; .bg-purple &#123; background: #d3dce6; &#125; .bg-purple-light &#123; background: #e5e9f2; &#125; .grid-content &#123; border-radius: 4px; min-height: 36px; &#125; .row-bg &#123; padding: 10px 0; background-color: #f9fafc; &#125;&lt;/style&gt;","tags":[]},{"title":"基于Vue的GIS组件GISView的API文档","date":"2021-07-22T10:53:31.435Z","path":"2021/07/22/基于Vue的GIS组件GISView的API文档/","text":"GISView API 基于Vue的GIS组件 版本：1.2.x 2021.04.28 npm传送门GISView API文档 起步 初始化vue项目 1vue tese demo 安装组件库 1npm install gisview 引用组件 1234import &#x27;gisview/dist/gisview.css&#x27;import GW from &#x27;gisview&#x27;Vue.use(GW) 依赖组件 12import &#x27;leaflet/dist/leaflet.js&#x27;import &#x27;@supermap/iclient-leaflet&#x27; 三维依赖。推荐第一种方式 1234567// index.html引用，下载WebGL包到public&lt;link href=&quot;Cesium/Widgets/widgets.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;Cesium/Cesium.js&quot;&gt;&lt;/script&gt;// ES6模块化引用，可能出现地球初始化闪烁import &#123;S3MTilesLayer&#125; from &#x27;../Build/Cesium/Cesium.js&#x27;import from &#x27;../Build/Cesium/Widgets/widgets.css&#x27; main.js 1234567import &#x27;gisview/dist/gisview.css&#x27;import &#x27;leaflet/dist/leaflet.css&#x27;import &#x27;leaflet/dist/leaflet.js&#x27;import &#x27;@supermap/iclient-leaflet&#x27;import GW from &#x27;gisview/dist/gisview.umd.js&#x27;Vue.use(GW) 示例场景和开发框架稍后放至github及gitee上 Map系列 需要new一个map对象当作参数传入 1. Arcgis矢量服务12// 默认加载一幅arcgisonline的矢量服务&lt;gw-load-vector-arc&gt;&lt;/gw-load-vector-arc&gt; 值 含义 类型 默认值 校验 id Dom名称 String map 是 mapObj map对象 Arcgis规范下的map对象 包含属性extent和logo值的Map对象 有 image-url 服务地址 String &#39;&#39; 是 extent 范围 Object 北京城区偏北 对象内部不校验 basemap 底图 String &#39;&#39; 是 logo esri logo Boolean false 是 overview 鹰眼图 Boolean false 是 expandFactor 鹰眼比例 Number 2 是 attachTo 鹰眼位置 String top-right 是 divCss Css样式 String &#39;&#39; 是 12345678910111213data() &#123; return &#123; mapObj: &#123;&#125;, extent: &#123; able: true, xmin: 114, ymin: 40, xmax: 118, ymax: 41, wkid: 4326 &#125; &#125; &#125; 1234567891011// 默认值&lt;gw-load-vector-arc :map-obj.sync=&quot;mapObj&quot; imageUrl: &quot;http://server.arcgisonline.com/arcgis/rest/services/World_Topo_Map/MapServer&quot; :extent: &quot;extent&quot; :logo: &quot;false&quot; div-css: &#x27;width: 90%; height: 90%;background-color: azure;&#x27; :overview=&quot;true&quot; :expandFactor: 2 attachTo: &#x27;bottom-left&#x27;&gt;&lt;/gw-load-vector-arc&gt; 2. Arcgis影像服务12// 默认加载一副arcgisonline的影像服务&lt;gw-load-image-arc&gt;&lt;/gw-load-image-arc&gt; 值 含义 类型 默认值 校验 id Dom名称 String map 是 mapObj map对象 Arcgis规范下的map对象 包含logo值的Map对象 有 image-url 服务地址 String &#39;&#39; 是 extent 范围 Object 北京城区偏北 对象内部不校验 logo esri logo Boolean false 是 overview 鹰眼图 Boolean false 是 expandFactor 鹰眼比例 Number 2 是 attachTo 鹰眼位置 String top-right 是 divCss Css样式 String &#39;&#39; 是 3. 空间查询123456&lt;gw-query-task-arc :query-task-url=&quot;queryTaskUrl&quot; :map-obj=&quot;map&quot; :filts=&quot;filts&quot; :query-result.sync=&quot;queryResult&quot;&gt;&lt;/gw-query-task-arc&gt; 值 含义 类型 默认值 校验 queryTaskUrl 查询服务 String 无 有 map-obj map对象 Arcgis规范下的map对象 无 有 filts 查询字段 Array&lt;String&gt; 无 有 queryResult 接收查询结果 Object &#123;&#125; 不接收 4. 唯一值渲染1234567&lt;gw-unique-render-arc v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :render-url=&quot;renderUrl&quot; :filt-field=&quot;filtValue&quot; :tip=&quot;tip&quot;&gt;&lt;/gw-unique-render-arc&gt; 12345678910data() &#123; return &#123; asyncData: false, map: &#123;&#125;, renderUrl: &#x27;http://localhost:6080/arcgis/rest/services/Basic/China_POI/MapServer/0&#x27;, filtField: &#x27;jishu&#x27;, tip: &#x27;AQI级数唯一值渲染&#x27; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Arcgis规范下的map对象 无 有 render-url 渲染服务 String 无 有 filt-field 渲染值参数 String 无 有 tip 提示词 String 唯一值渲染 有 5. 简单渲染1234567&lt;gw-simple-render-arc v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :render-url=&quot;renderUrl&quot; :size-info=&quot;sizeInfo&quot; :tip=&quot;tip&quot;&gt;&lt;/gw-simple-render-arc&gt; 1234567891011121314151617181920data() &#123; return &#123; asyncData: false, map: &#123;&#125;, renderUrl: &#x27;http://localhost:6080/arcgis/rest/services/Basic/China_POI/MapServer/0&#x27;, sizeInfo: &#123; // 分级字段 field: &#x27;pm2_5&#x27;, valueUnit: &#x27;unknown&#x27;, // 符号大小 minSize: 1, maxSize: 50, // 分级数值范围 minDataValue: 0, maxDataValue: 500 &#125;, tip: &#x27;pm2.5简单渲染&#x27; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Arcgis规范下的map对象 无 有 render-url 渲染服务 String 无 有 size-info 符号分级参数 Object 无 有 tip 提示词 String 简单渲染 有 6. 分级渲染1234567&lt;gw-classbreaks-render-arc v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :filt-field=&quot;filtField&quot; :render-url=&quot;renderUrl&quot; :tip=&quot;tip&quot;&gt;&lt;/gw-classbreaks-render-arc&gt; 12345678910data() &#123; return &#123; asyncData: false, map: &#123;&#125;, renderUrl: &#x27;http://localhost:6080/arcgis/rest/services/Basic/China_POI/MapServer/0&#x27;, filtField: &#x27;AQI&#x27;, tip: &#x27;AQI分级渲染&#x27; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Arcgis规范下的map对象 无 有 render-url 渲染服务 String 无 有 filt-field 渲染值参数 String 无 有 tip 提示词 String 分级渲染 有 7. 热力图渲染1234567&lt;gw-heatmap-render-arc v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :filt-field=&quot;filtField&quot; :render-url=&quot;renderUrl&quot; :tip=&quot;tip&quot;&gt;&lt;/gw-heatmap-render-arc&gt; 12345678910data() &#123; return &#123; asyncData: false, map: &#123;&#125;, renderUrl: &#x27;http://localhost:6080/arcgis/rest/services/Basic/China_POI/MapServer/0&#x27;, filtField: &#x27;pm2_5&#x27;, tip: &#x27;热力图渲染&#x27; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Arcgis规范下的map对象 无 有 render-url 渲染服务 String 无 有 filt-field 渲染值参数 String 无 有 tip 提示词 String 热力图渲染 有 8. Tile图层加载123456&lt;gw-load-tile-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :layer-url=&quot;layerUrl&quot; @click=&quot;fn&quot;&gt;&lt;/gw-load-tile-lt&gt; 12345678910111213data() &#123; return &#123; asyncData: false, map: &#123;&#125;, layerUrl: &#x27;http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=7&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&#x27; &#125;&#125;,methods: &#123; fn(e) &#123; // 地图动作函数 &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 layer-url tile服务 String 无 有 click 点击函数 function 无 无 9. 闪烁点12345&lt;gw-twinkle-point-sm-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :data-url=&quot;dataUrl&quot;&gt;&lt;/gw-twinkle-point-sm-lt&gt; 12345678data() &#123; return &#123; asyncData: false, map: &#123;&#125;, layerUrl: &#x27;http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=7&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&#x27;, dataUrl: &#x27;https://iserver.supermap.io/iserver/services/data-DynamicData/rest/data&#x27; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 data-url 数据服务 String 无 有 闪烁样式未上图 10. 加载图层123456789&lt;gw-load-layer-sm-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :layer-obj.sync=&quot;layerObj&quot; :layer-type=&quot;layerType&quot; :layer-url=&quot;layerUrl&quot; :layer-options=&quot;layerOptions&quot; @click=&quot;fn&quot;&gt;&lt;/gw-load-layer-sm-lt&gt; 12345678910data() &#123; return &#123; asyncData: false, map: &#123;&#125;, layerObj: &#123;&#125;, layerType: &#x27;TiledMap&#x27;, layerUrl: &#x27;https://iserver.supermap.io/iserver/services/map-world/rest/maps/World&#x27;, layerOptions: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 layer-type 服务类型 矢量 / 影像 / 百度 / 天地图 / 瓦片 ’TiledMap‘ 有 layer-url 数据服务 String 无 有 layer-options 扩展项 Object 参考iClient规范 无 有 layerType 类型 TiledMap 矢量 ImageMap 影像 BaiduTile 百度地图 TiandituTile 天地图 WMTS 瓦片地图 11. 鹰眼图1&lt;gw-mini-map-sm-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; &gt;&lt;/gw-mini-map-sm-lt&gt; 12345678data() &#123; return &#123; asyncData: false, map: &#123;&#125;, miniUrl: &#x27;https://iserver.supermap.io/iserver/services/map-world/rest/maps/World&#x27;, miniOptions: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 mini-url 鹰眼图地址 String 无 有 mini-options 配置项 Object &#123; position: undefined &#125; 有 有Bug，待回复，4.9 解决，有引用，显示无官方样式及右下角缩小标，待回复。4.12 12. 缩放1&lt;gw-zoom-map-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot;&gt;&lt;/gw-zoom-map-lt&gt; 123456data() &#123; return &#123; asyncData: false, map: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 options 扩展项 Object &#123;&#125; 是 13. 比例尺1&lt;gw-scale-map-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot;&gt;&lt;/gw-scale-map-lt&gt; 123456data() &#123; return &#123; asyncData: false, map: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 options 扩展项 Object &#123;&#125; 是 14. 切换底图12345&lt;gw-switch-layer-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :base-maps=&quot;baseMaps&quot;&gt;&lt;/gw-switch-layer-lt&gt; 12345678910111213141516171819202122232425data() &#123; return &#123; asyncData: false, map: &#123;&#125;, baseMaps: [] &#125;&#125; init(that) &#123; var baseMaps = [] // baseMaps[底图名称，地图服务链接，服务类型，扩展项] baseMaps.push([ &#x27;China&#x27;, &#x27;https://iserver.supermap.io/iserver/services/map-china400/rest/maps/China&#x27;, &#x27;TiledMap&#x27;, &#123;&#125; ]) baseMaps.push([ &#x27;ChinaDark&#x27;, &#x27;https://iserver.supermap.io/iserver/services/map-china400/rest/maps/ChinaDark&#x27;, &#x27;TiledMap&#x27;, &#123;&#125; ]) that.baseMaps = baseMaps &#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 base-maps 底图对象集合 Array [] 是 15. 绘制工具组12345&lt;gw-draw-group-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :options=&quot;options&quot;&gt;&lt;/gw-draw-group-lt&gt; 1234567data() &#123; return &#123; asyncData: false, map: &#123;&#125;, options: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 options 扩展项 Object &#123;&#125; 是 16. 捕捉绘制12345&lt;gw-capture-draw-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :options=&quot;options&quot;&gt;&lt;/gw-capture-draw-lt&gt; 1234567data() &#123; return &#123; asyncData: false, map: &#123;&#125;, options: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 options 扩展项 Object &#123;&#125; 是 17. 服务区分析123456&lt;gw-service-area-find-sm-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :service-url=&quot;serviceUrl&quot; :center-point=&quot;centerPoint&quot;&gt;&lt;/gw-service-area-find-sm-lt&gt; 123456789data() &#123; return &#123; asyncData: false, map: &#123;&#125;, serviceUrl: &#x27;https://iserver.supermap.io/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun&#x27;, centerPoint: [-3375, 5605] &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 service-url 分析服务 String 无 有 center-point 服务区经纬度 Array 无 有 18. 缓冲区分析1234567&lt;gw-buffer-analyst-sm-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :service-url=&quot;serviceUrl&quot; :parameters=&quot;parameters&quot; :analyst-result.sync=&quot;analystResult&quot;&gt;&lt;/gw-buffer-analyst-sm-lt&gt; 12345678910111213data() &#123; return &#123; asyncData: false, map: &#123;&#125;, serviceUrl: &#x27;https://iserver.supermap.io/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst&#x27;, parameters: &#123; dataset: &#x27;RoadLine2@Changchun&#x27;, filter: &quot;NAME=&#x27;团结路&#x27;&quot; &#125;, analystResult: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 service-url 分析服务 String 无 有 parameters 分析参数 Object 无 有 analyst-result 接收分析结果 Object &#123;&#125; 不接收 dataset 数据源中的数据集 String 无 无 filter 过滤条件 String 无 无 19. 泰森多边形分析1234567&lt;gw-voronoi-analyst-sm-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :service-url=&quot;serviceUrl&quot; :parameters=&quot;parameters&quot; :analyst-result.sync=&quot;analystResult&quot;&gt;&lt;/gw-voronoi-analyst-sm-lt&gt; 123456789101112data() &#123; return &#123; asyncData: false, map: &#123;&#125;, serviceUrl: &#x27;https://iserver.supermap.io/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst&#x27;, parameters: &#123; dataset: &#x27;Factory@Changchun&#x27; &#125;, analystResult: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 service-url 分析服务 String 无 有 parameters 分析参数 Object 无 有 analyst-result 接收分析结果 Object &#123;&#125; 不接收 dataset 数据源中的数据集 String 无 无 20. 表面分析1234567&lt;gw-surface-analyst-sm-lt v-if=&quot;asyncData&quot; :map-obj.sync=&quot;map&quot; :service-url=&quot;serviceUrl&quot; :parameters=&quot;parameters&quot; :analyst-result.sync=&quot;analystResult&quot;&gt;&lt;/gw-surface-analyst-sm-lt&gt; 1234567891011121314151617181920data() &#123; return &#123; asyncData: false, map: &#123;&#125;, serviceUrl: &#x27;https://iserver.supermap.io/iserver/services/spatialanalyst-sample/restjsr/spatialanalyst&#x27;, parameters: &#123; polygonset: [ [4510338, -2010338], [4510338, 1063524], [3150322, 1063524], [3150322, -2010338] ], dataset: &#x27;SamplesP@Interpolation&#x27;, resolution: 9000, zValueFieldName: &#x27;AVG_TMP&#x27; &#125;, analystResult: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData 渲染开关 Boolean false 不接收 map-obj map对象 Map对象 无 有 service-url 分析服务 String 无 有 parameters 分析参数 Object 无 有 analyst-result 接收分析结果 Object &#123;&#125; 不接收 polygonset 分析区域 Array 无 无 dataset 数据源中的数据集 String 无 无 resolution 分辨率 Number 无 无 zValueFieldName 用于提取操作的字段 String 无 无 21. 叠加分析1234567&lt;gw-overlayer-analyst-sm-lt v-if=&quot;asyncData2&quot; :map-obj.sync=&quot;map&quot; :service-url=&quot;serviceUrl&quot; :parameters=&quot;parameters&quot; :analyst-result.sync=&quot;analystResult&quot;&gt;&lt;/gw-overlayer-analyst-sm-lt&gt; 1234567891011121314data() &#123; return &#123; asyncData2: false, map: &#123;&#125;, serviceUrl: &#x27;https://iserver.supermap.io/iserver/services/spatialanalyst-sample/restjsr/spatialanalyst&#x27;, parameters: &#123; sourceDataset: &#x27;BaseMap_R@Jingjin&#x27;, operateDataset: &#x27;Neighbor_R@Jingjin&#x27;, tolerance: 0 &#125;, analystResult: &#123;&#125; &#125;&#125; 值 含义 类型 默认值 校验 asyncData2 渲染开关，和图层不同，控制叠加顺序 Boolean false 不接收 map-obj map对象 Map对象 无 有 service-url 分析服务 String 无 有 parameters 分析参数 Object 无 有 analyst-result 接收分析结果 Object &#123;&#125; 不接收 sourceDataset 源数据集 String 无 无 operateDataset 操作数据集 String 无 无 tolerance 容限 Number 0 无 Scene系列 需要new一个viewer对象挂载在window上 1.设置相机参数1234&lt;gw-fly-to-view v-if=&quot;asyncData&quot; :camera-params=&quot;cameraParams&quot;&gt;&lt;/gw-fly-to-view&gt; 12345678910111213141516171819202122232425data() &#123; return &#123; asyncData: false, cameraParams: &#123; destination: &#123; longitude: 114.2158, latitude: 22.4169, height: 419 &#125;, orientation: &#123; direction: &#123; x: 0.5945902470233576, y: -0.4793925407032518, z: 0.6454806194323606 &#125;, up: &#123; x: -0.1629169048778112, y: 0.7143202157541026, z: 0.6805914424014209 &#125;, heading: 5.899584294129949 &#125; &#125; &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 cameraParams 相机参数 Object 无 有 destination WGS84世界坐标系中的最终位置 Object 无 无 longitude 以度为单位的经度值 Number 无 无 latitude 以度为单位的纬度值 Number 无 无 height 以米为单位的椭球高 Number 0.0 无 orientation 属性集合 Object 无 无 direction 方位 Number 无 无 up 上方向 Number 无 无 heading 方位角 Number 无 无 pitch 俯仰角 Number 无 无 roll 滚动角 Number 无 无 2. 叠加BingMap地图1234&lt;gw-add-bingmap-image-provider v-if=&quot;asyncData&quot; :image-data=&quot;imageData&quot;&gt;&lt;/gw-add-bingmap-image-provider&gt; 123456789data() &#123; return &#123; asyncData: false, imageData: &#123; url: &#x27;https://dev.virtualearth.net&#x27;, key: UrlC.URL_CONFIG.BING_MAP_KEY &#125; &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 imageData 地图服务参数 Object 无 有 3. 叠加地形图1234&lt;gw-add-terrain-provider v-if=&quot;asyncData&quot; :terrain-url=&quot;terrainUrl&quot;&gt;&lt;/gw-add-terrain-provider&gt; 123456data() &#123; return &#123; asyncData: false, scmUrl: UrlC.URL_CONFIG.SCENE_XGPARK &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 terrain-url STK地形服务 String 无 有 4. 叠加OpenStreetMap地图1234&lt;gw-add-openstreetmap-image-provider v-if=&quot;asyncData&quot; :image-data=&quot;imageData&quot;&gt;&lt;/gw-add-openstreetmap-image-provider&gt; 12345678data() &#123; return &#123; asyncData: false, imageData: &#123; url: &#x27;https://a.tile.openstreetmap.org/&#x27; &#125; &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 imageData 地图服务参数 Object 无 有 5. 叠加图层组1234&lt;gw-add-image-provider-group v-if=&quot;asyncData&quot; :image-data-set=&quot;imageDataSet&quot;&gt;&lt;/gw-add-image-provider-group&gt; 1234567891011121314151617data() &#123; return &#123; asyncData: false, imageDataSet: [ &#123; name: &#x27;墨卡托投影坐标系&#x27;, url: UrlC.URL_CONFIG.SUPERMAP_IMG_MEC, value: &#x27;MEC&#x27; &#125;, &#123; name: &#x27;经纬度坐标系&#x27;, url: UrlC.URL_CONFIG.SUPERMAP_IMG_WGS, value: &#x27;WGS&#x27; &#125; ] &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 imageDataSet 图层组默认选中第一个 Array 无 lengt != 0 name 图层名称 String 无 无 url 图层服务 String 无 无 value 标拾 String 无 无 6. 时态动画1234&lt;gw-image-providers-animation v-if=&quot;asyncData&quot; :image-urls=&quot;imageUrls&quot;&gt;&lt;/gw-image-providers-animation&gt; 12345678910111213data() &#123; return &#123; asyncData: false, imageUrls: [ UrlC.URL_CONFIG.TENSE_IMG0, UrlC.URL_CONFIG.TENSE_IMG1, UrlC.URL_CONFIG.TENSE_IMG2, UrlC.URL_CONFIG.TENSE_IMG3, UrlC.URL_CONFIG.TENSE_IMG4, UrlC.URL_CONFIG.TENSE_IMG5 ] &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 imageUrls 影像服务数组 Array 无 lengt &gt; 3 7. 地形开挖1234&lt;gw-terrain-excavation v-if=&quot;asyncData&quot; :stk-url=&quot;stkUrl&quot;&gt;&lt;/gw-terrain-excavation&gt; 1234567data() &#123; return &#123; asyncData: false, stkUrl: &#x27;https://www.supermapol.com/realspace/services/3D-stk_terrain/rest/realspace/datas/info/data/path&#x27; &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 stkUrl 开挖图层 String 无 有 8. 通视分析1234&lt;gw-general-analyst v-if=&quot;asyncData&quot; :cbd-url=&quot;cbdUrl&quot;&gt;&lt;/gw-general-analyst&gt; 123456data() &#123; return &#123; asyncData: false, cbdUrl: UrlC.URL_CONFIG.SCENE_CBD &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 cbd-url CBD模型服务 String 无 有 9. 淹没模型分析1234&lt;gw-flood-model-analyst v-if=&quot;asyncData&quot; :scm-url=&quot;scmUrl&quot;&gt;&lt;/gw-flood-model-analyst&gt; 123456data() &#123; return &#123; asyncData: false, scmUrl: UrlC.URL_CONFIG.SCENE_XGPARK &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 scm-url s3m模型服务 String 无 有 10. 淹没地形分析1234&lt;gw-add-terrain-provider v-if=&quot;asyncData&quot; :terrain-url=&quot;terrainUrl&quot;&gt;&lt;/gw-add-terrain-provider&gt; 123456data() &#123; return &#123; asyncData: false, terrainUrl: UrlC.URL_CONFIG.STK &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 terrain-url STK地形服务 String 无 有 11. 填挖方分析12345&lt;gw-cut-fill-analyst v-if=&quot;asyncData&quot; :scene-url=&quot;sceneUrl&quot; :spatial-data-url=&quot;spatialDataUrl&quot;&gt;&lt;/gw-cut-fill-analyst&gt; 123456789data() &#123; return &#123; asyncData: false, sceneUrl: &#x27;http://www.supermapol.com/realspace/services/3D-dxyx_ios2/rest/realspace&#x27;, spatialDataUrl: &#x27;http://www.supermapol.com/realspace/services/spatialAnalysis-dxyx_ios/restjsr/spatialanalyst/datasets/DEM@%E5%9B%9B%E5%A7%91%E5%A8%98%E5%B1%B1/terraincalculation/cutfill.json?returnContent=true&#x27; &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 scene-url 场景服务 String 无 有 spatial-data-url 空间数据服务 String 无 有 12. 三维标绘1&lt;gw-plotting-util-primitive v-if=&quot;asyncData&quot;&gt;&lt;/gw-plotting-util-primitive&gt; 12345data() &#123; return &#123; asyncData: false &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 13. GLTF模型123456&lt;gw-add-gltf-entities v-if=&quot;asyncData&quot; :gltf-url=&quot;gltfUrl&quot; :position=&quot;position&quot; :is-zoom-to=&quot;isZoomTo&quot;&gt;&lt;/gw-add-gltf-entities&gt; 123456789101112131415data() &#123; return &#123; asyncData: false, gltfUrl: &#x27;http://support.supermap.com.cn:8090/webgl/examples/webgl/SampleData/gltf/man/walk.gltf&#x27;, position: &#123; destination: &#123; longitude: 116.731444, latitude: 39.528856, height: 0 &#125; &#125;, isZoomTo: true &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 gltf-url GLTF模型地址 String 无 有 position 模型位置Cesium.Cartesian3.fromDegrees的经纬度及高程值 Object 无 有 isZoomTo 是否缩放至 Boolean true 有 14. KML文件12&lt;!-- 添加到当前位置 --&gt;&lt;gw-add-kml-data v-if=&quot;asyncData&quot; :kml-url=&quot;kmlUrl&quot;&gt;&lt;/gw-add-kml-data&gt; 123456data() &#123; return &#123; asyncData: false, kmlUrl: &#x27;http://support.supermap.com.cn:8090/webgl/examples/webgl/SampleData/kml/crane.kml&#x27; &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收 kml-url KML文件地址 String 无 有 15. 下载场景1&lt;gw-download-picture v-if=&quot;asyncData&quot;&gt;&lt;/gw-download-picture&gt; 12345data() &#123; return &#123; asyncData: false &#125;&#125; 值 含义 类型 默认值 校验 viewer 全局viewer对象，挂载到window Object 无 无 asyncData 渲染开关 Boolean false 不接收","tags":[]},{"title":"WebGIS期末复习","date":"2021-07-22T10:53:31.372Z","path":"2021/07/22/WebGIS期末复习/","text":"第一章 绪论 WebGIS起源与发展 起源： 1993年，施乐公司帕洛阿尔托研究中心开发了一个基于Web的地图浏览器。 1994年，加拿大发布了加拿大第一个在线国家地图集。 1995年，加利福尼亚大学开发了亚历山大数字图书馆、美国研发了全国地理数据仓库，可查询地图。 1995年，美国人口普查局发布了它的TIGER制图服务，把海量全国人口信息做成在线地图。 1995年，加州大学伯克利分校的博士研发了GRASSLinks，在桌面地理信息系统GRASS和Web服务器之间编写接口实现。 MapQuest发布面向大众的在线地图，寻找宾馆、饭店，是现在在线地图的早期代表。 发展： 1996年，进入互联网时代。主要的地理信息系统软件商都相继推出Web服务站和服务点，并介绍自己的因特网发展计划，如ESRI、Intergraph、MapInfo、Betley。 1997年，分布式地理信息（DGI）和基于Web的地理信息系统（Web GIS）出现。一些基于Web浏览器的GIS软件如：GeoMedia、MapGuide、IMS等商业Web GIS软件相继问世并不断发展。 1999年，组件式因特网地理信息系统开始研究:用EJB方法开发可重用的Web GIS服务器，用JavaBeans技术开发Web GIS客户机的应用界面，及用与GIS的图形操作功能相结合的方法开发Web GIS组件。 2005年，谷歌地图和谷歌地球推出，后来百度和微软也推出互联网地图服务，使大众真正体验到互联网地图服务的益处。 WebGIS概念和优点 概念：是Internet和www技术应用于GIS开发的产物，是利用Web技术来扩展和完善GIS的一项新技术。其核心是将GIS功能嵌入到满足HTTP和TCP/IP标准的Internet应用体系中，实现Internet环境下地理信息的有效管理与处理。 优点： 基于Internet/Intranet标准 分布式服务体系结构 发布速度快，范围广，维护方便 数据来源丰富、分布存储 平台无关 用户界面友好 系统建设投资少 系统安全性 系统协同性 WebGIS功能 空间数据发布 空间查询检索和联机处理 空间数据可视化 空间模型分析服务 Web资源共享 WebGIS发展前沿，与新技术结合 地理标记语言-网络环境下开放的空间数据交换格式 超文本链接标示语言（HTML）是目前Web上通用的标记语言。但是标准HTML语言在可扩展性、结构和有效性等方面存在严重不足。HTML语言对复杂的空间数据的描述也仅仅局限于文本，对于图形数据就无能为力了。 地理标记语言（Geography Markup Language）GML是由Open GIS联盟制定的基于XML的对地理信息（包括地理特征的几何和属性）的传输和存储的编码规范，GML是一个简单的基于文本的地理特征编码标准。 正如XML语言将Web页面的内容及其表现分离一样， GML也将在地理信息世界中将内容及其表现形式分离开来，GML所关注的是地理数据内容的表现。它用地理特征(Features)来描述世界。本质上讲特征只是一系列的属性和几何体。属性有其名称、类型、属性值的描述。几何体是由基本的几何建模体如：点、线、曲线、面、多边形等所组成。GML已经可以对很复杂的地理实体进行编码]。 开放式地理信息系统 开放的WebGIS的首先应该包括数据的开放，即分布在异构数据库中的信息能共享 “互操作性：不同地理信息系统软件之间连接、信息交换没有障碍。 “可扩展性：硬件方面，可在不同软件、不同档次的计算机上运行，其性能和硬件平台的性能成正比；软件方面增加新的地学空间数据和地学数据处理功能。 “技术公开性：开放的思想主要是对用户公开，公开源代码及规范说明是重要的途径之一。 “可移植性：独立于软件、硬件及网络环境，不需修改便可在不同的计算机上运行。 兼容性、可实现性、协同性等 一体化的空间数据管理与分析 在关系型数据库中引入面向对象技术，建立对象关系型数据库(ORDB)或纯对象数据库(OODB)，对象与底层表示分离，空间属性与非空间属性定位平等，实现了属性数据和空间数据一体化管理。既实现了一体化管理，同时以面向对象技术处理地理空间数据，提高了地理空间数据运算效率，是目前WebGIS的较为理想的数据库管理平台 基于分布式计算的WebGIS 地球信息的特征是分布的，并具有基础性、共享性和综合性。目前出现的分布式计算技术可使地理信息的计算应用于社会各领域，成为信息基础设施的重要内容。一个数据库的内容能被存储和维护在不同的地点，而远程用户则能够方便地并可应用网上特殊的处理方法对这个数据库进行操作。 由于地理信息本质上是分布的，而用户又需要对分布的地理信息完成浏览、查询、分析等操作，这就要求WebGIS需要解决如何实现地理信息客观上分布与实际操作、应用中集中的问题。具体地说，在WebGIS的服务器端，不同地域、不同行业的数据生产部门对应专门的数据服务器。通过对每一个数据服务器数据的及时更新，实现整个WebGIS数据的更新与共享。从这方面说，地理信息必须是分布式存储的。 在用户端，通过图形界面完成对远程分布式地理数据的获取、显示、分析操作。WebGIS的数据共享、分析与处理不仅仅是用户端对单个图幅或单一数据源的操作，而是来自分布式数据源的地理信息在用户端几何、拓扑与属性的统一。从这方面说，分布式地理信息的处理又是集中统一的。 网络虚拟地理环境 在地理信息系统中，结合三维可视化技术与虚拟现实技术(Virtual Reality)，完全再现地理环境的真实情况，把所有管理对象都置于一个真实的三维世界里，真正做到了管理意义上的”所见即所得”。虚拟现实技术的应用将使工程人员能通过全球网或局域网按协作方式进行三维模型的设计、交流和发布，从而进一步提高生产效率并削减成本。 地理虚拟建模语言（GeoVRML）是用虚拟建模语言（VRML）为基础来描述地理空间数据。其目的是让用户通过一个在Web浏览器安装的标准的VRML插件来浏览地理参考数据、地图、和三维地形模型。它的出现将为在网络环境下实现虚拟地理环境提供一个良好的数据规范平台，将大大促进网络虚拟地理环境的应用。 移动通信技术扩展GIS应用 当前用于地理信息交互的语言还不足以完成真正的”设备无关接口”的互操作。各种移动设备对于从GI（地理信息）服务器所获得的信息的表现方式是各不相同的，对于用户输入方式也不相同（例如，电话拨号，键盘输入，手写输入，语音输入）因此，对于不同的移动设备需要一种统一的标记语言。WML，由于某些局限并不是最好的答案。通用的XML或者由其派生的一种语言将成为各种GI移动设备的统一语言。 虚拟现实技术与地理信息系统的结合，其控制端基于webgis建立。Buy+阿里巴巴于2016年4月推出的全新购物方式，使用VR技术，利用计算机图形系统和辅助传感器，生成可交互的三维购物环境。其中有一种是模拟逛街得三维交互场景，可以通过vr去你想去的任何地方任何商场；虚拟旅游利用虚拟现实技术，通过模拟或超现实景，构建一个虚拟的三维立体旅游环境，网友足不出户，就能在三维立体的虚拟环境中遍览遥在万里之外的风光美景，形象逼真，细致生动。应用计算机技术实现场景的三维模拟，借助一定的技术手段使操作者感受目的地场景。 第二章 WebGIS 基础技术 WebGIS相关技术 超文本传输协议(Hypertext Transfer Protocol，HTTP) 超文本标记语言 (Hypertext Markup Language，HTML) 统一资源定位器(Uniform Resource Locator，URL) JavaScript ASP.NET、JSP、PHP Ajax JSON、XML SVG（Scalable Vector Graphics） WebGL（Web Graphics Library） WebSocket WebGIS基本架构 Web应用系统： 数据层 地理数据库：是某区域内关于一定地理要素特征的数据集，是WebGIS应用的基础支撑， WebGIS应用的价值往往取决于其数据的质量 逻辑层 WebGIS服务器：WebGIS架构中最重要的部分。一个WebGIS应用的能力和质量在很 大程度上取决于其所使用的WebGIS服务器 ,其功能、可定制的程度、可扩展性及性能 是关系到WebGIS应用能否成功的重要因素 表现层 客户端在WebGIS应用中扮演着两个角色：一方面，它代表整个系统的最终用户界面,负责与用户交互,如收集用户输人、向服务器发送请求、把结果显示给用户。另一方面，客户端特别是胖客户端，还可以运行 一些分析等处理任务 空间数据格式json、geojson、Xml、GML的解读，json与xml之间的转换，可以练习期中考试题目。 第三章 WebGIS 基本原理 基于服务器模式的WebGIS实现方式，各自优缺点 CGI 优点： “瘦”客户端，即不需要在客户端安装任何软件，在客户端使用的是支持标准HTML的Web浏览器，操作结果以静态的GIF或JPEG图像的形式表现，客户端与平台无关。 跨平台能力，CGI方式被多种操作系统的Web服务器支持，因此，CGI模式在服务器端具有跨平台的能力。 缺点： 增加了网络传输的负担。用户的每一步操作，都需要将请求通过网络传送给GIS服务器；GIS服务器将操作结果形成图像，通过网络返回给用户。因而网络的传输量大大增加了。 服务器的负担重。所有的操作都必须由GIS服务器解释执行，因而服务器的负担加重。 同步请求问题多。由于CGI脚本处理所有来自Web浏览器的输入和解释GIS服务器的所有输出。当多用户同时发出请求时，系统的功能将受到影响。 静态图像，在浏览器上显示的静态图像，用户既不能直接在客户端进行放大、缩小操作，又不能通过几何图形如点、线、面来选择显示其关心的地物。 Server API 优点：克服CGI方式的低效率问题而研制的 Java Servlet：Java开发的面向Web服务器的小应用程序 优点：以线程的方式执行，效率比CGI方式高，开发方式更灵活、可以跨平台使用 PS：CGI或者Server API，虽然增强了客户端的交互性，但是用户得到的信息依然是静态的。用户不能操作单个地理实体以及快速缩放地图，因为在客户端，整个地图是一个实体，任何GIS操作，如放大、缩小、漫游等操作都需要服务器完成并将结果返回。当网络流量较高时，系统反应变慢。解决该问题的一个办法是利用插件技术,对于WebGIS而言，插件处理和传输的是矢量格式空间数据，其数据量较小，这样就加快了用户操作的反应速度，减少了网络流量和服务器负载。插件的不足之处在于，象传统应用软件一样，它需要先安装，然后才能使用，给使用造成了不方便。 瘦客户端：负责向服务器发送请求优点： 除Web浏览器外，用户不需要安装任何GIS软件和插件； 绝大部分的地理操作由GIS服务器解释执行,客户端不需配置功能强大的计算机,在低端计算机上也可以正常运行。 缺点： 服务器负担重，绝大部分地理操作依赖GIS服务器完成； 交互性弱，用户界面往往使用普通HTML和部分简单的JavaScript构建,表现力欠佳。 基于客户端的WebGIS实现方式，各自优缺点 GIS Plug-in 优点： 无缝支持与GIS数据的连接。 GIS操作速度快。 服务器和网络传输的负担轻。。 缺点： GIS Plug-in与平台相关。 GIS Plug-in与GIS数据类型相关。 需要事先安装。 更新困难。 Plug-in方式使用已有的GIS操作分析资源的能力弱，处理大型的GIS分析能力有限 ActiveX 优点：任何符合ActiveX标准的控件都可以嵌入到网页中，在浏览器中显示。Plug-in只能在某一具体的浏览器中使用。 Java Applet：Applet每次随网页一起被加载到客户端，浏览器调用Java虚拟机执行Applet程序。 优点： 被加载到客户端的内存中，用户退出Applet页面，Applet就被收回，不占用客户端磁盘空间。 Applet不能访问本地文件系统，保证了系统安全。 缺点： “胖客户”端 Applet不能访问本地文件系统，限制了一些功能 Serverlight 胖客户端：通过在客户端计算机上安装相应的Web浏览器插件(如Flash和Silverlight等），或通过采用客户端本地（或嵌入式）应用程序来实现。优点： 用户交互速度快，很多数据和程序都是在客户端，不需要把所有请求都送到服务器来完成； 服务器负担轻。 缺点: 需要事先完成相应安装。用户需要下载安装GIS插件或本地应用程序，在一些政府、军队等安全要求较髙的单位,安装插件和本地程序通常需要经过事先批准，使用这种架构是受限制的。 面临网络带宽和客户机计算能力的限制。通常情况下，在互联网上传输上百兆、千兆的数据，或在客户端执行高强度的地理分析计算，往往是不可行的。 第四章 地理Web服务 ArcGIS地理服务类型及功能 服务 功能 地图服务 要素访问。用于访问地图中的适量要素 地理数据访问。最终用户可在在ArcMap中执行复制和数据提取。 地理处理。用于从工具箱或工具图层中访问地理处理模型。 使用地图文档创建XML要素 制图，用于访问地图文档的内容 移动数据访问、网络分析 创建符合OGC WCS、WFS、WMS规范的服务 地理编码服务 地理编码，用于访问地址定位器 地理数据服务 用于访问地理数据库的内容以进行数据查询、提取和复制 创建符合OGC WCS规范的服务 几何服务 在应用程序中提供了一种工具。用于执行几何计算（如投影计算和密度计算） 地理处理服务 地理处理。用于从工具箱或工具图层中访问地理处理模型。 Globle服务 Globle。用于访问Globle文档内容 影像服务 成像。用于访问栅格数据集或镶嵌数据集的内容，包括像素值、属性、元数据和波段。 JPIP。在使用JPEG2000文件并通过ITTVIS配置了JPIP服务器时提供了数据流功能。 创建符合OGC WCS规范的服务 创建符合OGC WMS规范的服务 搜索服务 搜索。用于搜索企业范围内共享的文件夹和地理数据库 OGC规范服务类型及功能 WMS：Web地图服务，是将具有地理空间信息的数据制作成地图提供给用户 GetCapabilies：对服务信息内容和可接受参数的描述 GetMap：返回一个地图影像 GetFeatureInfo：返回显示在地图的某些特定要素的信息，客户端能查询地图上某些要素的信息 WMTS：Web地图切片服务，返回给客户端是固定大小的瓦片，客户端根据索引号来获取每一张瓦片，而后拼接成地图进行展示，由于瓦片的规则是固定的，服务端可以预先缓存对应的瓦片，客户端需要时直接返回即可，因而WMTS是可缓存的。 GetCapabilities：获取服务的元信息 GetTile：获取切片 GetFeatureInfo：获取点选的要素信息 WFS：Web要素服务，除了能返回一张地图图像之外，也可以返回绘制该地图图像所使用的真实地理数据 GetCapabilities：请求服务的元数据 DescribeFeatureType：返回图层描述信息 GetFeature：用于获取要素数据 WCS：Web覆盖服务，面向空间影像数据，它将包含地理位置值的地理空间数据作为“覆盖”在网上相互交换 GetCapabilities：返回描述服务和数据集的XML文档 GetCoverage：使用通用的覆盖格式返回地理位置的值或属性 DescribeCoverageType：允许客户端请求由具体的WCS服务器提供的任一覆盖层的完全描述 WPS：Web处理服务，暴露基于URL接口来实现客户端通过WebService对此类方法的调用、并返回数据 ArcGIS和OGC规范地理服务对应 Web Service概念、原理及组成部分 概念：Web Service可看作是一些模块化的应用程序，这些应用程序能在Web上描述、发布、定位和调用。 原理： 组成部分： 地图切片概念、原理，与动态地图服务相比有何优势？ 概念：地图切片是采用预先生成的方法存放在服务器端，然后根据用户提交的不同请求，把相应的地图瓦片发送给客户端的过程，是一种多分辨率 层次模型，从瓦片金字塔的底层到顶层，分辨率越来越低，但表示的地理范围不变 原理 在进行切片之前首先要确定切图的起点（Tiling scheme origin point）、图片宽度和高度，设置起点（WGS84下默认是（-400,400））的目的在于保证同一坐标系下的切片地图可以完美的叠加在一起。 在默认的Tiling scheme origin下和图片大小的情况下进行地图切片，可以根据用户设置的比例尺来计算地图数据在整个网格中的行列号，计算公式如下： 12col=(int)Math.floor((point.x1-this.x1)/256/plottingResolution);row=(int)Math.floor((Math.abs(point.y1-this.y1))/256/plottingResolution); 其中point是当前坐标，this是origin点坐标，plottingResolution指当前Level的地图的地图分辨率。 如果要计算plottingResolution，可以根据用户输入的levelScale得到当前条件下的地图分辨率： 1Scale=1：(96*2*Math.PI*6378137*resolution/360/0.0254); 优点： 速度快，预先配色，显示效果佳，满足高并发访问，适合做底图。 瓦片地图缓存非常高效，如果你曾经查看过某一区域的瓦片，当你再次查看该区域的瓦片时，浏览器可能使用之前缓存的相同的瓦片，而不用重新下载一次。 瓦片地图可以渐进加载。中心区域的瓦片可能优先于边缘区域的瓦片加载，你可以移动或定位某一点，即使当前地图边缘区域还未加载。 简单易用。所以很容易在服务器、网络、桌面或移动设备上实现技术集成。 需要额外占用磁盘空间，需要预先生成切片，无法自定义地图。 减轻服务器、网络负担，增加用户体验。 第五章 WebGIS技术应用方法 SVG格式数据的解读 &lt;svg xml:space=&quot;preserve&quot; width=&quot;5.5in&quot; height=&quot;5in&quot;&gt; &lt;rect style=&quot;fill:#ff13e2;&quot; width=&quot;250&quot; height=&quot;100&quot;/&gt; &lt;text style=&quot;fill:blue;&quot; y=&quot;15&quot;&gt;Hello World!&lt;/text&gt; &lt;a xlink:href=&quot;http://www.hfut.edu.cn/&quot;&gt; &lt;path d=&quot;M250 150 L150 350 L350 350 Z&quot;/&gt; &lt;/a &gt; &lt;/svg&gt; 例中的SVG首先画了一个矩形，然后写了一段文字，接着利用路径元素画了一个三角形。 M = moveto Z = closepath L = lineto 矩形&lt;rect&gt;、圆&lt;circle&gt;、椭圆&lt;ellipse&gt;、直线&lt;line&gt;,折线&lt;polyline&gt;和多边形&lt;polygon&gt;、Bezier曲线元素标记为&lt;path&gt; SVG在WebGIS中的作用 在这个体系结构下，有一种简单的应用模式，即事先利用一些工具把GIS数据转换成SVG文档，供客户调用和显示。目前，ArcGIS9.0已提供了将地图数据直接转换成SVG文档的功能。 另一种较复杂的模式，是根据客户的请求，通过SVG文档转换，在GIS 数据库中提取数据并动态地转换成SVG文档，通过Web服务器传给客户端。 由于目前主流浏览器如IE等还不能直接支持SVG，需要SVG插件，如(Adobe的SVG插件)，尽管SVG插件具有很强的图形表现能力，能够满足一般图像操作的需要，但对于地图的显示和操作，功能就显得很不够。 当前流行的Web可视化技术有哪些，在WebGIS如何发挥作用 Canvas，Webgl。 HTML5 Canvas为WebGIS基本地理要素的表现提供了良好的支持,通过Canvas API提供的函数库可以在Canvas中绘制出WebGIS表现所需要的多种样式的点、线、面、影像以及文字，通过对绘制顺序和绘制时属性设置的不同展现不同的叠加效果，并且根据使用者的需求选择不同样式的图例，提高了灵活性与互操作性。可见，HTML5 Canvas可以作为客户端快速展现复杂的地理数据，并且在展现地理数据的灵活性与互操作性方面优于传统的切片技术。同时，在绘制大数据量、多图层的情况下使用HTML5 Canvas绘制矢量图形相比传统地图切片技术在网页加载速度上也有明显优势。 webGL是一种3D绘图协议，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，GIS开发人员就可以借助系统显卡来在浏览器里更流畅地展示三维地图。 与虚拟地理环境（VR）技术的结合，其核心技术是VR，主要通过虚拟建模语言（VRML）把GIS数据转换到VR中，为人们提供一个逼真的模拟环境。GIS用户在计算机上就能处理真三维的客观世界，在客观世界的虚拟环境中将能更加有效地管理和分析空间实体数据。VRGIS的关键技术是3D和4D的建模技术、数据模型的研究、海量数据的存贮和管理、三维显示技术与可视化技术的集成、面向对象的空间数据库研究及其与三维实时显示技术的集成等。VRGIS目前的研究主要集中于虚拟城市。 GeoVRML就是以VRML为基础，为了解决VRML在支持地学方面不足的缺感而建立得。GeoVRML是- -种符合地理学要求的有效的3D文件交换格式，是可以内置于浏览器中的插入式软件，利用GeoVRML,应用服务器可以按照客户端的请求，抽取数据库服务器中的地理信息空间数据，并将空间数据转换成GeoVRML格式的文本交换文件，传回客户端，供用户浏览使用。每当用户下载完毕场景文件后,对场景的各种显示以及简单的操作(例如放大、缩小、移动)都可以在客户端浏览器中由GeoVRMEL插件独立执行，而不需要在和服务器进行数据传输，因此可以大大地减少网络负荷。同时，由于显示的功能是由客户端独立计算，因此可以保证图像的显示质量，能满足用户的基本需要。 系统开发 掌握map类库的使用方法，加载地图的方法； 掌握常用类型layers的用法； 掌握Graphic图形的使用用法； 掌握Query查询；","tags":[]},{"title":"Vue开发过程中的小问题","date":"2021-07-22T10:53:31.369Z","path":"2021/07/22/Vue开发过程中的小问题/","text":"动态渲染的组件样式需要动态引入。","tags":[]},{"title":"Vue环境的配置及语法检查（VsCode）","date":"2021-07-22T10:53:31.367Z","path":"2021/07/22/Vue环境的配置及语法检查（VsCode）/","text":"吐槽一下，可以下滑直接正文我的webstorm又双叒叕的不能用了，都已经频繁到每日激活码了，还是给我封封封的。 听说可以申请教育版，但是貌似我们学校不可以，就很气。 好吧，转战VsCode。 不是说VsCode不香，因为平时工作的环境用的vscode，vue的项目格式化的配置又不同于工作中的要求，加上vue的学习习惯，博主果断选择双环境，最后还是没能抗住贫穷。 改用Vscode，少不了配置一波。幸好vue初始化项目的配置文件很完整，只需要做一些改动就可以。 正文： 安装插件。参考各位大佬的博客，装了Eslint和Vetur 接着又参考各种配置文件，Vetur一直没有作用，咱也不知道是个啥情况。果断方案二 在项目根目录下创建.prettierrc.json，添加下面内容 1234567&#123; &quot;tabWidth&quot;: 2, &quot;useTabs&quot;: false, &quot;singleQuote&quot;: true, &quot;semi&quot;: false, &quot;trailingComma&quot;: &quot;none&quot;&#125; 到这里，项目是可以绿码跑过了。解决了，最后一行的尾随符号，结尾分号，Tab大小等问题 然后开始Eslint的配置，毕竟没有红波浪，心里挺没谱 安装后发现配置文档的设置，项目初始化的时候做好了，但是红波浪还是没有出来 随便打开一个Vue文件，看看右下角，把Eslint的禁用打开。Allow就可以了。 再看看，红波浪是不是有了。","tags":[]},{"title":"vue + @supermap_iclient-leaflet 加载切片出现未定义错误","date":"2021-07-22T10:53:31.356Z","path":"2021/07/22/vue + @supermap_iclient-leaflet 加载切片出现未定义错误/","text":"问题如图： 解决参考超图技术社区的帖子，重新安装了好几遍，还是没有解决。分析之后，调试一番，我想是因为调用自己的组件的时候还没有引用超图的组件。修改了调用顺序之后完美解决 关于小伙伴们重新安装若干次后成功，我觉得应该是打包，异步加载的原因","tags":[]},{"title":"v-model语法糖在vue组件开发中的传值问题","date":"2021-07-22T10:53:31.354Z","path":"2021/07/22/v-model语法糖在vue组件开发中的传值问题/","text":"v-model语法糖在vue组件开发中的传值问题 给组件使用v-model指令,实质上相当于给组件传递了value属性以及监听了input事件 1&lt;xx-input v-model=&quot;active&quot;&gt; 等价与 1&lt;xx-input :value=&quot;active&quot; @input=&quot;value =&gt; &#123; active= value &#125;&quot;/&gt; 所以在子组件中接受v-model传过来的值的时候，props中的名称必须为value，并且返回值到父组件的时候this.$emit(&#39;input&#39;, this.newValue)名称必须为input","tags":[]},{"title":"最大流问题------Ford-Fulkerson算法（增广路径）","date":"2021-07-22T09:54:49.075Z","path":"2021/07/22/最大流问题------Ford-Fulkerson算法（增广路径）/","text":"Ford-Fulkerson算法（增广路算法）增广路定理：设容量网络 G(V, E) 的一个可行流为 f, f 为最大流的充要条件是在容量网络中不存在增广路。 从任何的一个可行流开始，寻找增广路对网络进行增广，直到网络中不存在增广路径。 怎么证明当无法再寻找到增广路径时，就证明当前网络是最大流网络呢？ 最大流最小割定理：网络的最大流等于最小割。 证明： 任意一个流 &lt;= 任意一个割 自来水厂通水，水流从自来水厂到家，形成一个流。 当小偷偷走其中的几个管道，相当于形成一个割。 这时，几个管道的缺失部分都会有水流出来，流出的水的和 == 原来的流。 几个管道的容量加起来就是割 那么流必定小于割 当一个流 == 一个割 ，就构造出和最大流的割 达到最大流时，必定没有增广路，即残留网络中源汇点之间没有通路。 （ 源点能到的点 ） -&gt; （ 源点到不了的点 ） 的边必定会满流，否则就能增广。 这些中间的满流边之和就是最大流 把这些满流边作为割。 最大流等于最小割 假设残留网络Gf不存在增广路，所以在残留网络中不存在从源点到汇点的路。 S集合 = 残留网络中源点能够到达的点。 T集合 = 残留网络中源点不能够到达的点 (S,T)构成割(S,T) f(u,v)=c(u,v)。即满流边。 f(u,v)&lt;c(u,v)时，源汇点之间有连通路，与v属于T矛盾。 所以当找不到增广路时，此时f一定是最大流。","tags":[]},{"title":"在Ubuntu上安装java环境","date":"2021-07-22T09:54:49.072Z","path":"2021/07/22/在Ubuntu上安装java环境/","text":"JDK的安装 1. 下载安装包 提取码：nmrf2. 创建目录存放jvm 123cd /usr/libsudo mkdir jvmcd ~ #进入hadoop主目录 3. 将下载好的压缩包放在系统中，并在终端cd，我放在了主目录的下载下面 12cd 下载sudo tar -zxvf ./jdk-8u162-linux-x64.tar.gz -C /usr/lib/jvm 4. 配置环境变量 12cd ~vim ~/.bashrc 5. 进入了vim编辑器，可见光标在最开始，敲击i进入编辑模式，粘贴shift+ctrl+v以下代码到最开始 1234export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_162export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 6. esc退出编辑模式，键入：wq保存退出文件7. 让配置立即生效 1source ~/.bashrc 8. 查看java版本 1java -version","tags":[]},{"title":"遥感原理与应用【Ⅱ】","date":"2021-07-22T09:54:49.070Z","path":"2021/07/22/遥感原理与应用【Ⅱ】/","text":"1、电磁波的是3个特性在遥感中的应用大（小）———— 频率（波长）———— 小（大）————————————————————————Y射线 X射线 紫外线 可见光 红外线 微波 无线电 三个特性： 波粒二重性（波动性、粒子性） 波动性包括干涉、衍射、偏振等现象 以离散形式存在。其离散单元成为光子或量子。 波长与光子能量成反比关系 波长越短光子能量越大，则穿透力越强 应用 干涉：干涉雷达指采用干涉测量技术的合成孔径雷达 相干条件：两列频率相同、震动方向相同、相位差恒定的波。 衍射：设计遥感仪器和提高遥感图像几何分辨率、数字影像的处理 光通过有限大小的障碍物时偏离直线路径的现象 偏振（极化）：雷达遥感系统常用四种极化方式——HH、VV、HV、VH 水平极化（H）：电场方向平行于电磁波投射的平面 垂直极化（V）：垂直于水平极化的方向 HH、VV：同向极化 HV、VH：交叉极化 自然光（非偏正光）振动方向不变光振动面是一个固定平面 2、黑体辐射（三个特性） 一个物体对于任何波长的电磁辐射都全部吸收（能量由温度决定） 特性： 辐射通量密度随波长连续变化，每条曲线只有一个最大值。 温度越高，总的辐射通量密度越大，不同温度的曲线不同且不相交 随着温度的升高，辐射最大值所对应的波长向短波方向移动（维恩位移定律 ） 热红外遥感探测和识别原理 斯忒藩-玻尔兹曼公式：绝对黑体表面上，单位面积发出的总辐射能与绝对温度的四次方成正比。 3、大气窗口电磁波通过大气衰减较小，透过率较高的波段 紫外、可见光、近红外：白天探测 近红外：白天夜间，地质遥感 中红外：探测高温目标，森林火灾 远红外：探测地物的发射率及温度 4、地物反射类型 镜面反射 漫反射 方向反射5、反射波谱曲线物体的 反射波谱特性曲线 ：反射波谱是某物体得反射率（或反射辐射能）随波长变化的规律、以波长为横坐标，反射率为纵坐标所得到的曲线 植被 在可见光波段：（叶绿素吸收） 0.45μm蓝波段有一个吸收谷 0.55μm绿波段有一个反射峰 0.67μm红波段有一个吸收谷 在近红外波段：(近红外穿透叶绿素，被多孔薄壁组织反射) 0.76μm反射率迅速增大，在1.1处达到峰值，形成植被的独有特征。 影响植被波谱曲线的因素： 植被类型 生长季节 植被病虫害 根据植被波谱曲线特征的差异，区分植被的类型和生长状态。 水体 反射特性: 在蓝绿波段具有反射率 在近红外、中红外波段完全吸收 影响水体波谱曲线的因素： 水中含有泥沙，在可见光波段反射率会增加，峰值出现在黄红区。 水中还有绿色植被时，近红外波段反射率明显提高。 影响地物光谱反射率变化的因素： 时间效应： 地物的光谱特性一般随时间季节变化。 空间效应： 处在不同地理位置和区域的同种地物具有不同的光谱特性。 太阳高度，大气条件，环境状况 地形（阴影、坡度），气候、植物的病变6、遥感平台 地面平台、航空平台、航天平台。 7、卫星轨道6参数卫星轨道面与赤道面的相对位置 升交点赤经Ω ：升交点和赤道面春分点的夹角 近地点角距 ：轨道平面近地点和升交点的夹角 轨道倾角 ：轨道面和赤道面的夹角 卫星过近地点时刻 卫星轨道的形状 卫星轨道长半轴 卫星轨道扁率8、卫星姿态角 滚动角：绕X轴旋转的姿态角 俯仰角：绕Y轴旋转的姿态角 航偏角：绕Z轴旋转的姿态角 9、传感器分类按工作方式： 主动遥感 被动遥感 按成像方式： 摄影成像传感器 x 扫描成像传感器 雷达成像传感器 x 非图像传感器 10、扫描类型的传感器逐点逐行地以时序方式获取二维图像 对地面扫描的成像仪 特点：对地面直接扫描成像 - 红外扫描仪 - 多光谱扫描仪 - 成像扫描仪 瞬间在像面上先形成一条线图像 / 二维影像，然后对影像扫描成像 线阵列CCD推扫式成像仪 电视摄影机11、MSS多光谱扫描仪 Landsat含24+2个探测元，按波段排列成四列，每列由六个探测元，每个探测元的地面观察面积为79m×79m。陆地卫星2、3上增加一个热红外通道，分辨率为240m×240m，仅用两个探测元构成。每个波段由六个相同大小的探测元与飞行方向平行排列，这样在瞬间看到的地面大小474m×79m，又由于扫描总视场为11.56度，地面宽度为185km，因此扫描一次每个波段获取六条扫描图像，其地面范围为474m×185km。又因卫星速度6.5km/s，在扫描一次的时间里卫星正好往前移动474m，因此扫描现恰好衔接。 扫描行不垂直于飞行轨道 从西向东扫描 12、数字图像的存储BSQ：按波段顺序依次排列，保证了像素空间位置的连续性。BIL：以行为单位分块，像素的空间位置在列的方向上是连续的。BIP：以像素为核心，为图像数据波谱的存取提供最佳性能。 BSQ：按波段顺序依次排列的数据格式，即先按照波段顺序分块排列，在每个波段块内，再按照行列顺序排列。通一波段的像素保存在一个快中，保证了像素空间位置的连续性。 BIL：以行为单位分块，在每个块内，按照波段顺序排列像素。同一行不同波段的数据保存在一个数据块中。像素的空间位置在列的方向上是连续的。 BIP：以像素为核心，同一像素不同波段数据保存在一起。每个块内为当前像素不同波段的像素值。该格式为图像数据波谱的存取提供最佳性能。 13、遥感图像的构像方程遥感图像几何处理的目的？ &gt; 遥感任务是获取地物的空间信息和属性信息； &gt; 在利用遥感图像提取信息的过程中，要求将所有提取的信息 表达在某一个规定的图像投影参照系统内； &gt;遥感图像成图时，因为各种因素的影响，图像本身的 几何形状与其对应的地物形状不一致。 &gt;遥感图像的几何处理：统一坐标系，解决遥感图像的几何变形问题， 消除遥感图像的几何误差，获得所提取地物的几何位置。 1、通用构像方程设地面点P在地面坐标系中的坐标为(X, Y ,Z)P，P在传感器坐标系中的坐标为(U V W)P，传感器投影中心S在地面坐标系中的坐标为(X Y Z)S，A为传感器坐标相对于地面坐标系统的旋转矩阵，则通用构像方程为： 主要坐标系： 传感器坐标系S-UVW，S为传感器投影中心，作为传感器坐标系的坐标原点，U轴的方向为遥感平台的飞行方向，W轴为传感器指向地底点方向的负方向，V轴垂直于WU平面，该坐标系描述了像点在空间的位置。 地面坐标系O-XYZ，主要采用地心坐标系统。当传感器对地成像时， Z轴与原点的天顶方向一致，XY平面与Z轴垂直。 图像（像点）坐标系o-xyf，(x,y)为像点在图像上的平面坐标，f为传感器成像时的等效焦距，方向与S-UVW一致。 2、中心投影构像方程中心投影：等比例缩放中心投影构像方程：中心投影像片坐标与地面点大地坐标的关系 共线方程：描述像点、对应地物点和传感器中心之间的关系 共线方程物理意义：当地物点P、对应像点p和投影中心S位于同一条直线上时，上式公式成立。 为什么说中心投影构像方程是遥感构像方程的基础？ 答：框幅式影像属于纯中心投影构像， 全景影像属于多中心等焦距圆柱投影， 多光谱影像属于多中心扫描投影， HRV影像属于多中心推扫扫描投影， 合成孔径侧视雷达属于多中心斜距投影。 14、几何变形 静态误差：传感器相对于地球表面呈静止状态时所具有的各种变形误差。 动态误差：由于地球的旋转等因素所造成的图像变形误差。 内部变形误差：由于传感器自身的性能技术指标偏移标准数值所造成的。 外部变形误差：由传感器以外的各种因素所造成的误差，如传感器的外方位元素变化，传播介质不均匀，地球曲率，地形起伏以及地球旋转等因素引起的变形误差。 15、几何处理1. 粗加工处理作用：消除传感器误差 2. 精纠正处理消除图像中的几何变形，产生一副符合某种地图投影或图形表达要求的新图像 环节： 像素坐标的变换，即将图像坐标转变为地图或地面坐标 对坐标变换后的像素亮度值进行重采样。 处理过程： 根据图像的成像方式确定图像坐标和地面坐标之间的数学模型 根据地面控制点和对应像点坐标进行平差计算变换参数，平定精度。 对原始图像进行几何变换计算，像素亮度重采样。 纠正方法： 基于多项式的遥感图像纠正 基于共线方程的遥感图像纠正 基于有理函数的遥感图像纠正 16、基于多项式的遥感图像纠正多项式纠正直接对图像变形的本身进行数字模拟。对各种类型传感器图像的纠正是适用的。 利用地面控制点的图像坐标和其同名点的地面坐标通过平差原理计算多项式中的系数，然后用该多项式对图像进行纠正。 常用的多项式有一般多项式、勒让德多项式以及双变量分区插值多项式等。 多项式系数求解： 可预测的图像变形参数构成； 利用已知控制点的坐标值按最小二乘法原理求解 多项式的项数（即系数个数）N与其阶数n有着固定的关系：N=(n+1)(n+2)/2 一次项纠正：可以纠正图像因平移、旋转、比例尺变化和仿射变形等引起的线性变形。 二次项纠正时：在改正一次项各种变形的基础上，改正二次非线性变形。 三次项纠正：改正更高次的非线性变形。 例题： 多项式纠正步骤： 利用已知地面控制点求解多项式系数 地面控制点（GCP）：图像的配准以地面坐标在地图或遥感图像上相对应的点为匹配标准，这些对应的点称为地面控制点。 地面控制点数目的确定 地面控制点选取原则 图像上为明显的地物点，易于判读（道路交叉口、河流转弯处等）。 图像上均匀分布（图像的边缘部分选取控制点，尽量满幅均匀选取）。 数量要足够（特征变化大的地区，多选控制点）。 遥感图像的纠正变换 纠正后数字图像范围的确定 直接法和间接法纠正 数字图像亮度值的重采样 17、图像亮度值的重采样最邻近像元法 优点：简单容易，计算简单。 缺点：图像的灰度具有不连续性。 双线性内插法 优点：对灰度不连续现象或线状特征的块状化有明显的改善，对图像起到平滑作用 缺点：使对比度明显的分界线变得模糊。 双三次卷积法 优点：精度高。 缺点：计算量大。 18、辐射误差传感器接受的电磁波能量包含三部分： 太阳光经大气衰减后照射到地面，经地面反射后，又经大气第二次衰减进入传感器的能量。 大气散射、反射、辐射的能量 地面本身辐射的能量经大气后进入传感器的能量。 内容： 传感器本身的性能引起 ==》 辐射定标 大气的散射和吸收引起 ==》 大气校正 地形影响和光照条件的变化引起的辐射误差 ==》 太阳高度角、日地距离矫正和地形影响引起的辐射误差矫正。 19、辐射定标辐射定标：指传感器探测值的标定过程、方法，用以确定传感器入口处的准确辐射值。 辐射定标分为绝对定标和相对定标。绝对定标：要建立传感器测量的数字信号与对应的辐射能量之间的数量关系。 绝对定标方法：传感器定标、星上定标、场地定标 优点：实现了对遥感器运行状态下与获取地面图像完全同条件的绝对校正 缺点：需要测量和计算空中遥感器过顶时的大气环境和地物反射率。 20、大气校正大气的影响：大气对阳光和来自目标的辐射产生吸收和散射。 大气校正的方法 基于辐射传输方程的大气校正 基于地面场地数据或辅助数据进行辐射校正 利用某些不受大气影响或影响小的特性来校正其他波段的大气影响。 辐射校正：指消除或改正遥感图像成像过程中附加在传感器输出的辐射能量中的各种噪声的过程。 21、遥感图像辐射增强一、图像灰度直方图 反映了一幅图像中灰度级与其出现概率之间的关系。 可以看成一个随机分布密度函数，其分布状态用灰度均值和标准差来衡量。 可以判断图像质量 二、图像反差调整 线性变换：按比例拉伸原始图像灰度等级范围。 目的：提高图像对比度。 特点：一对一关系，像元总数不变。 ![](https://img-blog.csdnimg.cn/201904150738009.png) 直方图均衡化 将随机分布的图像直方图修改成均匀分布的直方图，其实质是对图像进行非线性拉伸，重新分配图像像元值，使一定灰度范围内的像元的数量大致相等。 特点：各级灰度值所占图像的面积近似相等 原图像上频率小的灰度级被合并、频率高的灰度级被保留 增强图像上大面积地物与周围地物的反差 具体增强效果不能控制，只能全局均衡 直方图正太化 将随机分布的原图像直方图修改成高斯分布的直方图 直方图匹配 密度分割 密度分割与直方图均衡类似。原始图像的灰度值被分成等间隔的离散的灰度级，每一级有其灰度值。 其他非线性变换 对数变换、指数变换、平方根变换、标准偏差变换、直方图周期性变换。 灰度反转 结果：原来亮的地方变暗，原来暗的地方变亮。 22、图像融合目的：提高分类精度 提高空间分辨率 改善配准精度 增强目标特征 提高分类精度 信息互补 23、景物特征及其判读标志1. 光谱特征地物的反射波谱特性一般是用一条连续的曲线表示 2. 空间特征形状：指各种地物的外形和轮廓 大小：地物尺寸、面积、体积在图像上按比例缩小后的相似性记录 图形：自然或人造复合地物所构成的图形 阴影：由于地物高度Z的变化，阻挡太阳光照射而产生的阴影。表示地物隆起高度，侧面形状 位置：地物存在的地点和所处的环境 纹理：同类地物聚集分布。光滑的、波纹的、斑纹的、线性、不规则的纹理特征。 类型：各大类别组成系统。水系系统、地貌系统、地质构造系统等，在各自类型中，根据形状、结构、图形分为许多种类。 3. 时间特征24、影响景物特征及其判读的因素 地物本身的复杂性 大类地物特征 / 光谱特征不同 同类地物特征 / 光谱特征类似 同种地物由于自身因素或外界环境因素影响导致光谱信息不同 传感器特性的影响 几何分辨率：传感器瞬时视场内所观察到的地面场元的宽度 辐射分辨率：传感器能区分两种辐射强度最小差别的能力 光谱分辨率：探测波段宽度、波段数、各波段波长范围和间隔 时间分辨率：对同一地区重复获取图像所需的时间间隔 目视能力 空间分辨能力：与眼睛分辨角、影像距离人眼距离、照明条件、图像形状和反差等有关。 灰阶分辨能力：取决于视网膜上的视杆细胞的灵敏度 色别和色阶分辨能力：RGB的分辨能力 25、特征变换什么？将原有的m量值集合通过某种变换，然后产生n（ m &gt;= n ）个特征 为什么？ 减少参加分类的特征图像的数目 从原始信息中抽取能更好进行分类的特征图像 分类 主分量变化 哈达玛变换 比值变换 缨帽变换 性质均方误差最小的最佳正交线变换 主分量变换步骤 计算 均值向量M和协方差矩阵C 计算 矩阵C的特征值和特征向量、 特征值的排序（大到小） 选择前几个特征值（及对应特征向量）构造变换矩阵Φn 根据Y=ΦnX变换，得到新特征影像，即结果。缨帽变换经验性线性特征变换 什么是特征选择？ 选择一组最佳的特征影响分类 从原有的m个测量值集合中，按某一准则选择出n个特征 定量选择方法： 距离测度 散布矩阵测度 类内散矩阵 类间散布矩阵 总体散布矩阵监督分类过程（1）确定感兴趣的类别数（2）特征变换和特征选择（3）选择训练样区（准确性、代表性和统计性）（4）确定判决函数和判决规则（5）根据判决函数和判决规则对非训练样区的图像区域进行分类K-均值聚类法准则：点到类别中心的距离的平方和最小。思想：通过迭代，逐次移动各类的中心，直至得到最好的聚类结果为止。 步骤： 选择m个类的初始中心 按照到类中心距离最小的原则对像元分类 重新计算类中心 类中心不变，算法结束；否则返回(2)IOSDATA算法聚类分析 步骤： 初始化； 选择初始中心； 按一定规则(如距离最小)对所有像元划分； 重新计算每个集群的均值和方差；按初始化的参数进行分裂和合并； 结束，迭代若干次数或者两次迭代之间类别均值变化小于阈值 否则，重复3-5； 确认类别，精度评定. 平行管道法聚类分析 它以地物的光谱特性曲线为基础，同类地物在特征空间上表现为以特征曲线为中心，以相似阈值为半径的管子 实质上是一种基于最邻近规则的试探法。 26、 监督分类与非监督分类的结合 选择一些有代表性的区域进行非监督分类。 获得多个聚类类别的先验知识。 特征选择。选择最适合的特征图像进行后续分类。 使用监督法对整个影像进行分类。 输出标记图像。 27、分类后的处理为什么？用光谱信息对影像逐个像元地分类，在结果的分类地图上会出现“噪声” 。分类是正确的，但某种类别零星分布于地面，占的面积很小 ，希望用综合的方法使它从图面上消失。 分类平滑技术采用邻区处理法。平滑时中心像元值取周围倒数的类别。 28、混淆矩阵（计算）行：错分。用户精度列：漏分。制图精度 Kappa系数 = （ Pa - Pe ）/ （ 1 - Pe ） Pa = （ P11+P22+…+Pnn）/ ( P )Pe = ( P1+ * P+1) + ( P2+ * P+2) + … +( Pn+ * P+n) / P^2 29、提高分类精度 分类前预处理 校正（辐射、几何） 变换 空间信息提取（纹理） 分类树与分层分类 一次分类不能满足精度要求时，进行多次分类 混合分类 监督法与非监督法 多种信息复合 遥感信息非遥感信息 与GIS集成 GIS与遥感数据复合分类 间接支持分类 用于选样区，检验样区，纠正等 基于目标的遥感图像分类","tags":[]},{"title":"遥感原理与应用 【I】","date":"2021-07-22T09:54:49.068Z","path":"2021/07/22/遥感原理与应用 【I】/","text":"态度决定一切。小时候常听，长大了才懂。 目录1、电磁波的是3个特性在遥感中的应用2、电磁波谱3、黑体辐射（三个特性）4、大气对辐射的影响5、大气窗口6、一般物体的发射辐射7、光谱反射率8、反射波谱曲线9、假彩色10、为什么天是蓝色的？11、遥感平台12、卫星轨道6参数13、传感器分类14、扫描成像传感器15、MSS多光谱扫描仪16、CCD线阵列传感器17、成像光谱仪18、遥感传感器记录地物电磁波的图像形式19、数字图像的存储20、遥感图像的构像方程21、几何变形22、传感器外方位元素变化的影响24、大气折射引起的图像变形25、地球自转引起的图像变形26、基于多项式的遥感图像纠正27、图像亮度值的重采样28、辐射误差29、大气校正30、遥感图像辐射增强31、图像融合 ———————————————正文———————————————————– 1、电磁波的是3个特性在遥感中的应用三个特性： 波粒二重性（波动性、粒子性） 波动性包括干涉、衍射、偏振等现象 以离散形式存在。其离散单元成为光子或量子。 波长与光子能量成反比关系 波长越短光子能量越大，则穿透力越强 应用 干涉：干涉雷达指采用干涉测量技术的合成孔径雷达 相干条件：两列频率相同、震动方向相同、相位差恒定的波。 衍射：设计遥感仪器和提高遥感图像几何分辨率、数字影像的处理 光通过有限大小的障碍物时偏离直线路径的现象 偏振（极化）：雷达遥感系统常用四种极化方式——HH、VV、HV、VH 水平极化（H）：电场方向平行于电磁波投射的平面 垂直极化（V）：垂直于水平极化的方向 HH、VV：同向极化 HV、VH：交叉极化 自然光（非偏正光）振动方向不变光振动面是一个固定平面 2、电磁波谱电磁波在真空中传播的波长或频率递增或递减顺序排序 电磁波包括：γ射线、X射线、紫外线、可见光、红外线、微波 遥感应用波段： 紫外线：0.01~0.38μm，对油污染敏感 可见光：0.38~0.76μm， 红外线：0.76~1000μm，（近、中、远、超远） 微波：1mm~1m，穿透性好，不受云雾影响 应用 遥感就是根据感兴趣的地物的波谱特性，选择相应的电磁波段通过传感器探测不同的电磁波谱的发射或反射能量而成像的。 3、黑体辐射（三个特性） 一个物体对于任何波长的电磁辐射都全部吸收（能量由温度决定） 特性： 辐射通量密度随波长连续变化，每条曲线只有一个最大值。 温度越高，总的辐射通量密度越大，不同温度的曲线不同且不相交 随着温度的升高，辐射最大值所对应的波长向短波方向移动（维恩位移定律 ） 热红外遥感探测和识别原理 斯忒藩-玻尔兹曼公式：绝对黑体表面上，单位面积发出的总辐射能与绝对温度的四次方成正比。 4、大气对辐射的影响 地球大气 对流层、平流层、电离层、大气外层 大气对太阳辐射的吸收、散射、反射 （1）大气对遥感波段的影响（吸收） 可见光波段：分子散射 紫外、红外、微波：大气吸收 （2）散射：电磁波与物质相互作用后，电磁波传播方向发生改变，并向各个方向散开。 主要发生在可见光，只改变传播方向 对遥感图像，降低了传感器接收数据的质量，造成图像模糊不清。 米氏散射、均匀散射、瑞利散射 思考：为什么微波遥感具有穿透能力？ 微波波长比粒子的直径大很多，属于瑞利散射， 波长越长散射强度越小，所以微波才可能由最小散射，最大投射， 而被称为具有穿云透雾的能力。 晴好的天气可见光通过大气时发生瑞利散射，蓝光比红光散射多； 当天空有云层或雨时，满足均匀反射条件， 各波长散射强度相同，天空云呈现白色，此时散射最大， 可见光难以通过云层，即阴天不利于用可见光进行遥感探测地物。 ５、大气窗口 电磁波通过大气衰减较小，透过率较高的波段 紫外、可见光、近红外：白天探测 近红外：白天夜间，地质遥感 中红外：探测高温目标，森林火灾 远红外：探测地物的发射率及温度 6、一般物体的发射辐射依据光谱发射率随波长的变化形式，将地物分为： 绝对黑体：发射率等于1 灰体：发射率小于1，各波长处的发射率相等 选择性辐射体，发射率小于1，各波长发射率不同 绝对白体，发射率为0。 影响发射率的因素：地物的性质、表面状况、温度（比热，热惯量）。 比热大、热惯量大以及具有保温作用的地物一般发射率大 任何材料的吸收率等于发射率 发射率 + 反射率 = 1 ７、光谱反射率物体在特定波长上的辐射通量与该波长的入射通量之比。 8、反射波谱曲线以波长为横坐标，反射率为纵坐标所得到的曲线 植被 在可见光波段：（叶绿素吸收） 0.45μm蓝波段有一个吸收谷 0.55μm绿波段有一个反射峰 0.67μm红波段有一个吸收谷 在近红外波段：(近红外穿透叶绿素，被多孔薄壁组织反射) 0.76μm反射率迅速增大，在1.1处达到峰值，形成植被的独有特征。 影响植被波谱曲线的因素： 植被类型 生长季节 植被病虫害 根据植被波谱曲线特征的差异，区分植被的类型和生长状态。 水体 反射特性: 在蓝绿波段具有反射率 在近红外、中红外波段完全吸收 影响水体波谱曲线的因素： 水中含有泥沙，在可见光波段反射率会增加，峰值出现在黄红区。 水中还有绿色植被时，近红外波段反射率明显提高。 城市道路、建筑 反射特性 红外波段较可见光波段反射强。 石棉瓦较其他材料反射强。 沥青较其他材料反射弱。 土壤 反射特性 自然状态下土壤的反射波谱曲线没有明显的峰值和谷值。 与土壤质地组成有关。 土壤含水量增加，反射率下降 - 影响地物光谱反射率变化的因素： - 时间效应： 地物的光谱特性一般随时间季节变化。 - 空间效应： 处在不同地理位置和区域的同种地物具有不同的光谱特性。 - 太阳高度，大气条件，环境状况 - 地形（阴影、坡度），气候、植物的病变 9、假彩色（B）Band2 --&gt; 绿光波段 （G）Band3 --&gt; 红光波段 （R）Band4 --&gt; 近红外波段 植被 绿色与红色相加为品红，但红多绿少，因此品红偏红，植被在影像中大致呈红色。 水体 水体的反射主要在蓝绿光波段，绿波段被赋蓝，因此水库呈蓝偏黑。 10、为什么天蓝阳光在穿过大气层时，波长较长的红光、橙光、黄光都能穿透大气层，直接射到地面，而波长较短的蓝、紫、靛等色光，很容易被悬浮在空气中的微粒阻挡，从而使光线散射向四方，使天空呈现出蔚蓝色。 11、遥感平台地面平台、航空平台、航天平台。 12、卫星轨道6参数卫星轨道面与赤道面的相对位置 升交点赤经Ω ：升交点和赤道面春分点的夹角 近地点角距 ：轨道平面近地点和升交点的夹角 轨道倾角 ：轨道面和赤道面的夹角 卫星过近地点时刻：卫星与近地点之间的角距 卫星轨道的形状 卫星轨道长半轴 卫星轨道扁率 13、传感器分类按工作方式： 主动遥感 被动遥感 按成像方式： 摄影成像传感器 x 扫描成像传感器 雷达成像传感器 x 非图像传感器 14、扫描成像传感器 红外扫描仪-分辨率 瞬时视场：在扫描成像过程中一个光敏探测元件通过望远镜系统投射到地面上的直径或对应的视场角度。 注意： 垂直观测时分辨率，即星下点空间分辨率 对于一个使用着的传感器，β在设计时已确定，地面分辨率变化只与航高有关。航高越大，a指越大，地面分辨率差 观测视线倾斜时，即非星下点时 扫描仪空间分辨率是变化的，产生全景畸变。 红外扫描仪-扫描线的衔接 假定旋转棱镜扫描一次的时间为t，探测器地面分辨率为a，若要使两条扫描带的重叠度为0，但又不能有空隙，必须 W = a/t Wt&gt;a 出现扫描漏洞 Wt&lt;a 出现扫描重叠 红外扫描仪-影响特征 热红外像片上的色调变化与相应的地物的辐射强度变化呈函数关系。 地物发射电磁波的功率和地物的发射率成正比，与地物温度的四次方成正比。 15、MSS多光谱扫描仪 Landsat含24+2个探测元，按波段排列成四列，每列由六个探测元，每个探测元的地面观察面积为79m×79m。陆地卫星2、3上增加一个热红外通道，分辨率为240m×240m，仅用两个探测元构成。每个波段由六个相同大小的探测元与飞行方向平行排列，这样在瞬间看到的地面大小474m×79m，又由于扫描总视场为11.56度，地面宽度为185km，因此扫描一次每个波段获取六条扫描图像，其地面范围为474m×185km。又因卫星速度6.5km/s，在扫描一次的时间里卫星正好往前移动474m，因此扫描现恰好衔接。 扫描行不垂直于飞行轨道 从西向东扫描 16、CCD线阵列传感器HRV（高分辨率可见光扫描仪）是一种CCD线阵列传感器，又称为线阵列推扫式扫描仪。 不需要扫描镜的摆动，像缝隙式摄影机那样，以“推扫”方式获取连续条带影像。 将若干个CCD元器件排成一行，称为CCD线阵列传感器。 CCD上植入的微小光敏物质称作像素。一块CCD上包含的像素数越多，其提供的画面分辨率也就越高。 目前发射高分辨率卫星几乎均为线阵列 CCD工作原理 仪器中的平面反射镜将地面辐射来的电磁波反射到反射镜组 电磁波聚焦在CCD线阵列元件上 CCD输出端输出时间序列视频信号，以推扫的方式获取沿轨道方向的连续图像条带。 HRV-CCD优点 CCD线阵上的每个点同时曝光，保证了每个点上都有最大限度的曝光时间。 机械部件大大简化，运行稳定，几何精度比较高。 灵敏度高，可以探测到地面0.5％的反射变化信息。 突破了光/机扫描仪要求探测元件的响应速度足够快的要求。 17、成像光谱仪成像光谱仪其构造与像面扫描仪或物面扫描仪相近，但通道多。光谱分辨率高，可以获得接近连续的光谱。 特点：波段更窄，波段数更多 面阵探测器加推扫式扫描仪的成像光谱仪： 它利用线阵列探测器进行扫描，利用色散元件和面阵探测器完成光谱扫描，利用线阵列探测器及其沿轨道方向的运动完成空间扫描。 线阵列探测器加光机扫描仪的成像光谱仪： 它利用点探测器收集光谱信息，经色散元件后分成不同的波段，分别在线阵列探测器的不同元件上，通过点扫描镜在垂直于轨道方向的面内摆动以及沿轨道方向的运动完成空间扫描，而利用线探测器完成光谱扫描。 18、遥感传感器记录地物电磁波的图像形式 （1）光学图像- 一个二维的连续的光密度函数 - 像片上的密度随坐标x,y变化而变化 特点：光照位置和光照强度均为连续变化的。 （2）数字图像- 一个二维的离散的光密度（或亮度）函数 - 以矩阵f（x，y） ( x=0,1,…,m-1;y=0,1, …,n-1)表示 - 空间坐标（x,y）和密度上都已离散化 （3）光学图像与数字图像的转换1.光学图像转化为数字图像 采样：数字化坐标值。 - 采样间隔越大，所得图像像素数越少，空间分辨率低，质量差，严重时出现马赛克效应； - 采样间隔越小，所得图像像素数越多，空间分辨率高，图像质量好，但数据量大。 dx和dy采样窗口，Δx和Δy为采样间隔 量化：无穷多个离散值约简为有限个离散值（整数来表示） 图像数字化：- 连续图像 - 扫描线AB亮度分布 - 采样和量化 - 数字扫描线 数字图像转化为光学图像 通过显示终端设备显示出来，利用数模转换设备将数字信号以模拟方式表现出来 通过照相或打印的方式输出，彩色打印机。 19、数字图像的存储BSQ：按波段顺序依次排列，保证了像素空间位置的连续性。BIL：以行为单位分块，像素的空间位置在列的方向上是连续的。BIP：以像素为核心，为图像数据波谱的存取提供最佳性能。 BSQ：按波段顺序依次排列的数据格式，即先按照波段顺序分块排列，在每个波段块内，再按照行列顺序排列。通一波段的像素保存在一个快中，保证了像素空间位置的连续性。 BIL：以行为单位分块，在每个块内，按照波段顺序排列像素。同一行不同波段的数据保存在一个数据块中。像素的空间位置在列的方向上是连续的。 BIP：以像素为核心，同一像素不同波段数据保存在一起。每个块内为当前像素不同波段的像素值。该格式为图像数据波谱的存取提供最佳性能。 20、遥感图像的构像方程遥感图像几何处理的目的？ &gt; 遥感任务是获取地物的空间信息和属性信息； &gt; 在利用遥感图像提取信息的过程中，要求将所有提取的信息 表达在某一个规定的图像投影参照系统内； &gt;遥感图像成图时，因为各种因素的影响，图像本身的 几何形状与其对应的地物形状不一致。 &gt;遥感图像的几何处理：统一坐标系，解决遥感图像的几何变形问题， 消除遥感图像的几何误差，获得所提取地物的几何位置。 1、通用构像方程设地面点P在地面坐标系中的坐标为(X, Y ,Z)P，P在传感器坐标系中的坐标为(U V W)P，传感器投影中心S在地面坐标系中的坐标为(X Y Z)S，A为传感器坐标相对于地面坐标系统的旋转矩阵，则通用构像方程为： 2、中心投影构像方程中心投影：等比例缩放 中心投影构像方程：中心投影像片坐标与地面点大地坐标的关系 共线方程：描述像点、对应地物点和传感器中心之间的关系 共线方程物理意义：当地物点P、对应像点p和投影中心S位于同一条直线上时，上式公式成立。 为什么说中心投影构像方程是遥感构像方程的基础？ 答：框幅式影像属于纯中心投影构像， 全景影像属于多中心等焦距圆柱投影， 多光谱影像属于多中心扫描投影， HRV影像属于多中心推扫扫描投影， 合成孔径侧视雷达属于多中心斜距投影。 3、全景摄影机的构像方程全景摄影机影像是由一条曝光缝隙沿旁向扫描而成，对于每条缝隙图像的形成，其几何关系等效于中心投影沿旁向倾斜一个扫描角θ 4、推扫式传感器的构像方程 5、扫描式传感器的构像方程 21、几何变形 静态误差：传感器相对于地球表面呈静止状态时所具有的各种变形误差。 动态误差：由于地球的旋转等因素所造成的图像变形误差。 内部误差：由于传感器自身的性能技术指标偏移标准数值所造成的。 外部变形误差：由传感器以外的各种因素所造成的误差，如传感器的外方位元素变化，传播介质不均匀，地球曲率，地形起伏以及地球旋转等因素引起的变形误差。 22、传感器外方位元素变化的影响传感器的外方位元素：传感器成像时的位置（Xs,Ys,Zs）和姿态角（φ,ω,κ） dXs、dYs、dZs 、dκ——线性变化 dφ、dω——非线性变形 23、地球曲率引起的图像变形地球曲率引起的像点位移与地形起伏引起的像点位移类似。只要把地球表面（把地球表面看成球面）上的点到地球切平面的正射投影距离看作是一种系统的地形起伏，就可以利用前面介绍的像点位移公式来估计地球曲率所引起的像点位移。 24、大气折射引起的图像变形大气层不是一个均匀的介质，它的密度是随离地面高度的增加而递减，因此电磁波在大气层中传播时的折射率也随高度而变化，使得电磁波的传播路径不是一条直线而变成了曲线，从而引起像点的位移，这种像点位移就是大气层折射的影响。 25、地球自转引起的图像变形在常规框幅摄影机成像的情况下，地球自转不会引起图像变形，因为其整幅图像是在瞬间一次曝光成像的。 地球自转主要是对动态传感器的图像产生变形影响，特别是对卫星遥感图像。当卫星由北向南运行的同时，地球表面也在由西向东自转，由于卫星图像每条扫描线的成像时间不同，因而造成扫描线在地面上的投影依次向西平移，最终使得图像发生扭曲。 26、基于多项式的遥感图像纠正多项式纠正直接对图像变形的本身进行数字模拟。对各种类型传感器图像的纠正是适用的。 利用地面控制点的图像坐标和其同名点的地面坐标通过平差原理计算多项式中的系数，然后用该多项式对图像进行纠正。 常用的多项式有一般多项式、勒让德多项式以及双变量分区插值多项式等。 多项式系数求解： 可预测的图像变形参数构成； 利用已知控制点的坐标值按最小二乘法原理求解 多项式的项数（即系数个数）N与其阶数n有着固定的关系：N=(n+1)(n+2)/2 一次项纠正：可以纠正图像因平移、旋转、比例尺变化和仿射变形等引起的线性变形。 二次项纠正时：在改正一次项各种变形的基础上，改正二次非线性变形。 三次项纠正：改正更高次的非线性变形。 例题： 多项式纠正步骤： 利用已知地面控制点求解多项式系数 地面控制点（GCP）：图像的配准以地面坐标在地图或遥感图像上相对应的点为匹配标准，这些对应的点称为地面控制点。 地面控制点数目的确定 地面控制点选取原则 图像上为明显的地物点，易于判读（道路交叉口、河流转弯处等）。 图像上均匀分布（图像的边缘部分选取控制点，尽量满幅均匀选取）。 数量要足够（特征变化大的地区，多选控制点）。 27、图像亮度值的重采样最邻近像元法 优点：简单容易，计算简单。 缺点：图像的灰度具有不连续性。 双线性内插法 优点：对灰度不连续现象或线状特征的块状化有明显的改善，对图像起到平滑作用 缺点：使对比度明显的分界线变得模糊。 双三次卷积法 优点：精度高。 缺点：计算量大。 28、辐射误差内容： 传感器本身的性能引起 大气的散射和吸收引起 地形影响和光照条件的辩护引起的辐射误差 辐射处理： 辐射定标：指传感器探测值的标定过程方法，用以确定传感器入口处的准确辐射值。 辐射定标分为绝对定标和相对定标。 绝对定标要建立传感器测量的数字信号与对应的辐射能量之间的数量关系。 绝对定标方法： 传感器定标、星上定标、场地定标 - 优点：实现了对遥感器运行状态下与获取地面图像完全同条件的绝对校正 - 缺点：需要测量和计算空中遥感器过顶时的大气环境和地物反射率。 辐射校正：指消除或改正遥感图像成像过程中附加在传感器输出的辐射能量中的各种噪声的过程。 29、大气校正大气的影响：大气对阳光和来自目标的辐射产生吸收和散射。 大气校正的方法 基于辐射传输方程的大气校正 基于地面场地数据或辅助数据进行辐射校正 利用某些不受大气影响或影响小的特性来校正其他波段的大气影响。 30、遥感图像辐射增强一、图像灰度直方图 反映了一幅图像中灰度级与其出现概率之间的关系。 可以看成一个随机分布密度函数，其分布状态用灰度均值和标准差来衡量。 二、图像反差调整 线性变换：按比例拉伸原始图像灰度等级范围。 目的：提高图像对比度。 特点：一对一关系，像元总数不变。 ![](https://img-blog.csdnimg.cn/201904150738009.png) 直方图均衡化 将随机分布的图像直方图修改成均匀分布的直方图，其实质是对图像进行非线性拉伸，重新分配图像像元值，使一定灰度范围内的像元的数量大致相等。 特点：各级灰度值所占图像的面积近似相等 原图像上频率小的灰度级被合并、频率高的灰度级被保留 增强图像上大面积地物与周围地物的反差 具体增强效果不能控制，只能全局均衡 直方图正太化 将随机分布的原图像直方图修改成高斯分布的直方图 直方图匹配 密度分割 密度分割与直方图均衡类似。原始图像的灰度值被分成等间隔的离散的灰度级，每一级有其灰度值。 其他非线性变换 对数变换、指数变换、平方根变换、标准偏差变换、直方图周期性变换。 灰度反转 结果：原来亮的地方变暗，原来暗的地方变亮。 31、图像融合目的： 空间分辨率的提高 目标特征增强 提高分类精度 信息互补 方法： 条件 融合图像应包括不同空间和光谱分辨率 融合的图像应是同一区域 图像应尽可能精确配准 在不同时间获取的图像中，其内容没有大的变化 基于像素的图像融合的方法 加权融合 基于HIS变换的图像融合 基于主分量变换的图像融合 基于小波变换的图像融合 比值变换融合 乘积变换融合基于IHS变换的图像融合 IHS变换将图像处理常用的RGB彩色空间变换到IHS空间。 I：亮度（Intensity） H：色调（Hue） S：饱和度(Saturation) IHS变换可以把图像的亮度、色调和饱和度分开，图像融合只在亮度通道上进行，图像的色调和饱和度保持不变。 效果评价 IHS变换融合：分辨率提高，图像变得清晰，光谱信息明显降低，色彩严重失真 比值变换融合：亮度太低，反差不合适，目视效果不好 ，光谱信息丢失严重 补充： 可见光 波长 /微米 红光 0.760~0.622 橙光 0.622~0.597 黄光 0.597~0.577 绿光 0.577~0.492 青光 0.492~0.450 蓝光 0.450~0.435 紫光 0.435~0.390","tags":[]},{"title":"渲染---唯一值渲染","date":"2021-07-22T09:54:49.066Z","path":"2021/07/22/渲染---唯一值渲染/","text":"1.效果图 2.通过定义唯一值渲染器，渲染字段，设置渲染方式渲染唯一值写死，方式设置参考官方api 12345678//定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号var renderer = new UniqueValueRenderer(fill, &quot;name&quot;);//设置渲染的方式renderer.addValue(&quot;C&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5])));renderer.addValue(&quot;B&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5])));renderer.addValue(&quot;A&quot;,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5])));renderer.addValue(&quot;O&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75])));featureLayer.setRenderer(renderer); 贴代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;UniqueValueRenderer&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;dojo/colors&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/renderers/UniqueValueRenderer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom,Color,SimpleFillSymbol, FeatureLayer, SimpleLineSymbol,UniqueValueRenderer) &#123; var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer); //获得id为btn的DOM元素 var btn=dom.byId(&quot;btn&quot;); //绑定相应的事件 on(btn,&quot;click&quot;,function()&#123; //定义一个要素图层 var featureLayer = new FeatureLayer( &quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/2&quot;, &#123; mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color(&quot;#FFFFCC&quot;)); //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new UniqueValueRenderer(fill, &quot;name&quot;); //设置渲染的方式 renderer.addValue(&quot;C&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addValue(&quot;B&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addValue(&quot;A&quot;,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addValue(&quot;O&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer); map.addLayer(featureLayer); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;渲染&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"渲染---服务器分类渲染","date":"2021-07-22T09:54:49.063Z","path":"2021/07/22/渲染---服务器分类渲染/","text":"1.引入模块1234&quot;esri/tasks/GenerateRendererTask&quot;, &quot;esri/tasks/GenerateRendererParameters&quot;, &quot;esri/tasks/ClassBreaksDefinition&quot;, &quot;esri/tasks/AlgorithmicColorRamp&quot;, 2.与前两个相比当数据量很大的时候，服务器渲染的速度明显快过客户端渲染。客户端和服务端的渲染都分为两种：唯一值渲染和分类渲染 3.服务器分类步骤相比客户端较多，有层次 创建对象12345678var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3);var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new dojo.Color(&quot;#FFFFCC&quot;));//创建服务器渲染对象var RenderAnalyst = new GenerateRendererTask(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;);//创建服务器渲染参数对象var params = new GenerateRendererParameters(); //创建颜色坡道对象 var colorRamp = new AlgorithmicColorRamp(); 设置颜色位置、类型123456//颜色的起始位置 colorRamp.fromColor = dojo.colorFromHex(&quot;#998ec3&quot;);//颜色的终止位置 colorRamp.toColor = dojo.colorFromHex(&quot;#f1a340&quot;);//颜色的类型 colorRamp.algorithm = &quot;hsv&quot;; 渲染器样式、分类字段，怎么分，分几类 12345678//渲染器样式var unidef = new ClassBreaksDefinition();//分类字段unidef.classificationField = &quot;Shape.STArea()&quot;;//如何分类 unidef.classificationMethod=&quot;natural-breaks&quot;;//几类unidef.breakCount = 3; 显示分类符号，颜色，赋值渲染12345678//默认的符号 unidef.baseSymbol=fill;//将自定义的颜色坡道告诉服务器 unidef.colorRamp=colorRamp;//给渲染参数对象赋值 params.classificationDefinition = unidef;//进行服务器渲染 RenderAnalyst.execute(params, showRender); 4.贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;GenerateRendererTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/GenerateRendererTask&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/tasks/GenerateRendererParameters&quot;, &quot;esri/tasks/ClassBreaksDefinition&quot;, &quot;esri/tasks/AlgorithmicColorRamp&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom,on, GenerateRendererTask, FeatureLayer, SimpleFillSymbol, SimpleLineSymbol, GenerateRendererParameters, ClassBreaksDefinition, AlgorithmicColorRamp ) &#123; //服务器端渲染 var MyMap = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/&quot;); MyMap.addLayer(layer) //获得id为Btn的DOM对象 var btn=dom.byId(&quot;Btn&quot;); //给btn绑定点击事件 on(btn,&quot;click&quot;,function(e)&#123; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new dojo.Color(&quot;#FFFFCC&quot;)); //创建服务器渲染对象 var RenderAnalyst = new GenerateRendererTask(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;); //创建服务器渲染参数对象 var params = new GenerateRendererParameters(); //创建颜色坡道对象 var colorRamp = new AlgorithmicColorRamp(); //颜色的起始位置 colorRamp.fromColor = dojo.colorFromHex(&quot;#998ec3&quot;); //颜色的终止位置 colorRamp.toColor = dojo.colorFromHex(&quot;#f1a340&quot;); //颜色的类型 colorRamp.algorithm = &quot;hsv&quot;; //渲染器样式 var unidef = new ClassBreaksDefinition(); //分类字段 unidef.classificationField = &quot;Shape.STArea()&quot;; //如何分类 unidef.classificationMethod=&quot;natural-breaks&quot;; //几类 unidef.breakCount = 3; //默认的符号 unidef.baseSymbol=fill; //将自定义的颜色坡道告诉服务器 unidef.colorRamp=colorRamp; //给渲染参数对象赋值 params.classificationDefinition = unidef; //进行服务器渲染 RenderAnalyst.execute(params, showRender); &#125;); //处理服务器返回来的结果 function showRender(renderer) &#123; if (renderer != null) &#123; //定义要素图层，注意：这个地方我们用到并不是要素服务，而是地图服务 var featureLayer = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;,&#123; mode: FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //赋予渲染器 featureLayer.setRenderer(renderer); featureLayer.refresh(); MyMap.addLayer(featureLayer); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; id=&quot;Btn&quot; value=&quot;服务器渲染&quot; /&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"渲染---分类渲染","date":"2021-07-22T09:54:49.062Z","path":"2021/07/22/渲染---分类渲染/","text":"1.效果图 2.与唯一值渲染相比不同的只有渲染方式的设置 唯一值渲染： 1234renderer.addValue(&quot;C&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5])));renderer.addValue(&quot;B&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5])));renderer.addValue(&quot;A&quot;,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5])));renderer.addValue(&quot;O&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); 分类渲染： 1234renderer.addBreak(0,20, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5])));renderer.addBreak(20,30, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5])));renderer.addBreak(30,40,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5])));renderer.addBreak(40,60, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); 分类渲染即将选择字段的值分为不同阶段渲染为不同颜色 3.贴代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;UniqueValueRenderer&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;dojo/colors&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/renderers/ClassBreaksRenderer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom,Color,SimpleFillSymbol, FeatureLayer, SimpleLineSymbol,ClassBreaksRenderer) &#123; var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer); //获得id为btn的DOM元素 var btn=dom.byId(&quot;btn&quot;); //绑定相应的事件 on(btn,&quot;click&quot;,function()&#123; //定义一个要素图层 var featureLayer = new FeatureLayer( &quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;, &#123; mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color(&quot;#FFFFCC&quot;)); //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new ClassBreaksRenderer(fill, &quot;OBJECTID&quot;); //设置渲染间隔 renderer.addBreak(0,20, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addBreak(20,30, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addBreak(30,40,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addBreak(40,60, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer); map.addLayer(featureLayer); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;渲染&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"小操作","date":"2021-07-22T09:54:49.059Z","path":"2021/07/22/小操作/","text":"2019.9.21 更添加图层map.addLayer(Shp);移除图层map.removeLayer(Shp);隐藏图层shp.hide();显示图层shp.show(); 2020.3.20更定位地图中心 12345function setMapCenter() &#123; var point = new Point(121.453, 31.709); map.centerAt(point);&#125;dojo.connect(dojo.byId(&quot;btn5&quot;), &quot;onclick&quot;, setMapCenter); 开关图层 123456789101112131415//加载动态地图 var dynamicUrl = &quot;http://localhost:6080/arcgis/rest/services/webgis/School/MapServer&quot;; var dynamicLayer = new ArcGISDynamicMapServiceLayer(dynamicUrl); map.addLayer(dynamicLayer); // 关闭所有显示 visible = [-1]; dynamicLayer.setVisibleLayers(visible); // 打开所有显示 visible = []; for (i = 0; i &lt; dynamicLayer.layerInfos.length; i++) &#123; visible.push(i); &#125; dynamicLayer.setVisibleLayers(visible);","tags":[]},{"title":"鹰眼图","date":"2021-07-22T09:54:49.057Z","path":"2021/07/22/小部件---鹰眼图/","text":"1. 效果图 2. 引用模块鹰眼图&quot;esri/dijit/OverviewMap&quot;, 3. 增加了一个鹰眼图，div的布局会不会有什么变化？123456789&lt;body&gt; &lt;div id=&quot;map&quot; style=&quot;height: 800px;&quot;&gt;&lt;/div&gt; &lt;button&gt;拉框放大&lt;/button&gt; &lt;button&gt;拉框缩小&lt;/button&gt; &lt;button&gt;平移&lt;/button&gt; &lt;button&gt;全图&lt;/button&gt; &lt;button&gt;漫游&lt;/button&gt; &lt;/body&gt; 嗯，，，似乎是没有任何变化 这样看来。鹰眼图就像是map的属性一样，本身便存在，需要设置它的setVisibleXX来控制它的可见性。我猜是这样 4. 看一下JS代码证实一下猜想123456var overviewMapDijit = new OverviewMap(&#123; map: map, //LOOK LOOK visible: true &#125;); overviewMapDijit.startup(); OverviewMap就是创建鹰眼图的类。创建参数中第一个绑定地图。第二个就是设置鹰眼图的可见性。并且它的可见性默认是false（亲测） 5. 试试在上一篇中的绑定小部件上加上鹰眼图，贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Overview Map&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;style&gt; html, body &#123; height: 100%; width: 100%; margin: 0; padding: 0; &#125; &lt;/style&gt; &lt;script src=&quot;https://js.arcgis.com/3.29/&quot;&gt;&lt;/script&gt; &lt;script&gt; var map; require([ &quot;esri/map&quot;, &quot;esri/dijit/OverviewMap&quot;, &quot;dojo/parser&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;,&quot;esri/toolbars/navigation&quot;, &quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dojo/domReady!&quot; ], function ( Map, OverviewMap, parser,ArcGISDynamicMapServiceLayer,query,Navigation) &#123; parser.parse(); map = new Map(&quot;map&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); var overviewMapDijit = new OverviewMap(&#123; map: map, visible: true &#125;); overviewMapDijit.startup(); //创建地图操作对象 var navToolbar = new Navigation(map); //给按钮添加绑定事件 query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; //获得按钮的文本信息 var value=this.innerHTML; switch(value)&#123; case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break; case &quot;全图&quot;: navToolbar.zoomToFullExtent(); break; case &quot;漫游&quot;: //默认是漫游操作 navToolbar.deactivate(); break; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;map&quot; style=&quot;height: 800px;&quot;&gt;&lt;/div&gt; &lt;button&gt;拉框放大&lt;/button&gt; &lt;button&gt;拉框缩小&lt;/button&gt; &lt;button&gt;平移&lt;/button&gt; &lt;button&gt;全图&lt;/button&gt; &lt;button&gt;漫游&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 6. 结果 7. 拓展：尝试设置重新鹰眼图的位置","tags":[]},{"title":"图例","date":"2021-07-22T09:54:49.055Z","path":"2021/07/22/小部件---图例/","text":"1. 效果图 2. 引用模块图例 &quot;esri/dijit/Legend&quot;, 3. 右侧增加的图例框会不会对div有一定的影响？先看一下HTML结构 12345678910111213141516171819202122232425262728&lt;body class=&quot;claro&quot;&gt;&lt;div id=&quot;content&quot; data-dojo-type=&quot;dijit/layout/BorderContainer&quot; data-dojo-props=&quot;design:&#x27;headline&#x27;, gutters:true&quot; style=&quot;width: 100%; height: 100%; margin: 0;&quot;&gt; &lt;div id=&quot;rightPane&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&#x27;right&#x27;&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/AccordionContainer&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; id=&quot;legendPane&quot; data-dojo-props=&quot;title:&#x27;Legend&#x27;, selected:true&quot;&gt; &lt;div id=&quot;legendDiv&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;title:&#x27;Pane 2&#x27;&quot;&gt; This pane could contain tools or additional content &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;map&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&#x27;center&#x27;&quot; style=&quot;overflow:hidden;&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 好吧，很乱。大致分为四层。如图与之对应的图例中：解释一下：①：获取的图例对象的内容即框中的数据②：显示图例的标签卡及其平行标签卡，可以当作是对图例对象显示上的改进④：与map平行的同级div，border: solid #CCC 1px（灰色边框）③：②和④中间的间隙，它取决于②，换句话说，如果②为空，那么③的存在就没有意义。 除了①中的是必须获取的数据之外，剩余的有都是由Esri官方提供的方便开发的方法。不妨尝试进一步美化。这样看来，右侧增加的图例框的真实存在的div，但是它也是获取map中的数据。所以它更像是map对象的一种方法，而非属性。这也是和鹰眼图比较根本上的区别。 4. 大概因为都与map对象密切相关，所以鹰眼图和图例在启动上都十分相似，看一眼JS代码12345//add the legendvar legend = new Legend(&#123; map:map &#125;,&quot;legendDiv&quot;); legend.startup(); 相比而言，图例只是不用设置它的可见性。但我认为它们还是由本质上的区别。（个人拙见） 5. 贴代码动态图层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Map with legend&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.29/dijit/themes/claro/claro.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.29/esri/css/esri.css&quot;&gt; &lt;style&gt; html, body &#123; height: 99%; width: 99%; &#125; #rightPane &#123; width: 20%; &#125; #legendPane &#123; border: solid #97DCF2 1px; &#125; &lt;/style&gt; &lt;script src=&quot;https://js.arcgis.com/3.29/&quot;&gt;&lt;/script&gt; &lt;script&gt; var map; require([ &quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/dijit/Legend&quot;, &quot;dojo/_base/array&quot;, &quot;dojo/parser&quot;, &quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dijit/layout/AccordionContainer&quot;, &quot;dojo/domReady!&quot; ], function( Map, ArcGISDynamicMapServiceLayer, Legend, arrayUtils, parser ) &#123; parser.parse(); map = new Map(&quot;map&quot;, &#123; logo:false &#125;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) //不设置显示图层，默认显示&#x27;[0]&#x27;的图层 layer.setVisibleLayers([0]); //add the legend var legend = new Legend(&#123; map:map &#125;,&quot;legendDiv&quot;); legend.startup(); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;claro&quot;&gt;&lt;div id=&quot;content&quot; data-dojo-type=&quot;dijit/layout/BorderContainer&quot; data-dojo-props=&quot;design:&#x27;headline&#x27;, gutters:true&quot; style=&quot;width: 100%; height: 100%; margin: 0;&quot;&gt; &lt;div id=&quot;rightPane&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&#x27;right&#x27;&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/AccordionContainer&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; id=&quot;legendPane&quot; data-dojo-props=&quot;title:&#x27;Legend&#x27;, selected:true&quot;&gt; &lt;div id=&quot;legendDiv&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;title:&#x27;Pane 2&#x27;&quot;&gt; This pane could contain tools or additional content &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;map&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&#x27;center&#x27;&quot; style=&quot;overflow:hidden;&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 要素图层将其中的对应的改为下面的代码即可注意：需要引入模块：&quot;esri/layers/FeatureLayer&quot;注意加载的时候为单图层，及动态图层后加显示序号 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var map; require([ &quot;esri/map&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/dijit/Legend&quot;, &quot;dojo/_base/array&quot;, &quot;dojo/parser&quot;, &quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dijit/layout/AccordionContainer&quot;, &quot;dojo/domReady!&quot; ], function( Map, FeatureLayer, Legend, arrayUtils, parser ) &#123; parser.parse(); map = new Map(&quot;map&quot;, &#123; logo:false &#125;); var rivers = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/1&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] &#125;); var waterbodies = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] &#125;); map.addLayers([waterbodies, rivers]); //add the legend var legend = new Legend(&#123; map:map &#125;,&quot;legendDiv&quot;); legend.startup(); s &#125;); &lt;/script&gt; 要素图层显示效果：加载了两个要素图层，所以也会显示两个图例信息。个人认为交互性的动态图层更加方便，单一展示的要素图层更加方便。 7. 拓展：上面贴的代码中引入模块中多了三个&quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dijit/layout/AccordionContainer&quot; 如果删掉这三个模块，最终结果没有变化，但是在加载过程中，显示最终结果之前出现了一个过度样式，如下图：显然图里位置改变了，并且注意图最下方的地方可见图幅的大小也改变了。 为什么呢？后解。 文章中不正确的地方，麻烦大家指出，一起改进","tags":[]},{"title":"绑定小部件","date":"2021-07-22T09:54:49.053Z","path":"2021/07/22/小部件---绑定小部件/","text":"鼠标滚轮的放大缩小是地图的加载就有的操作方法，绑定的是拉框放大，缩小，全图等方法。 先看看效果图（拉框放大为例）放大前： 拉框放大： 放大后： 新添加模块：”dojo/query” “esri/toolbars/navigation” &quot;dojo/query&quot;绑定点击事件，注意：该点击事件凡是操作地图的要用query不能用on绑定 例如：query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123;&#125;)✔ on(dom.byId(&quot;button&quot;),&quot;click&quot;,function(event)&#123;&#125;)❌ &quot;esri/toolbars/navigation&quot;实现对地图的操作首先创建地图操作对象，给but等绑定该对象的方法。例如放大、缩小等。 步骤： 加载地图 1234var map = new Map(&quot;mapDiv&quot;);var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;);map.addLayer(layer); 创建地图操作对象 1var navToolbar = new Navigation(map); 为btn绑定事件 1query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; 获取btn的识别信息 1var value=this.innerHTML; switch选择合适的操作方法 1234567891011switch(value)&#123; case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break;&#125; 贴代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;,&quot;esri/toolbars/navigation&quot;, &quot;dojo/domReady!&quot;], function (Map,ArcGISDynamicMapServiceLayer,query,Navigation) &#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建地图操作对象 var navToolbar = new Navigation(map); //为btn绑定事件 query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; //获得btn的识别信息 var value=this.innerHTML; switch(value)&#123; case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break; case &quot;全图&quot;: navToolbar.zoomToFullExtent(); break; case &quot;漫游&quot;: //默认是漫游操作 navToolbar.deactivate(); break; &#125; &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;拉框放大&lt;/button&gt; &lt;button&gt;拉框缩小&lt;/button&gt; &lt;button&gt;平移&lt;/button&gt; &lt;button&gt;全图&lt;/button&gt; &lt;button&gt;漫游&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 结果图","tags":[]},{"title":"","date":"2021-07-22T09:54:49.051Z","path":"2021/07/22/唯一值渲染、简单渲染、分级渲染、热力图渲染（完整源码实现）/","text":"效果图 系统中进行了简单封装和提示信息，不需要可以直接删掉，单独成块，不会影响功能。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321&lt;template&gt; &lt;div id=&quot;home&quot;&gt; &lt;!--面包屑导航区域--&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;&gt;Home&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;Analysis&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;唯一值渲染&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btnclass&quot;&gt; &lt;el-card&gt; &lt;el-switch v-model=&quot;weiyiswithvalue&quot; @change=&quot;weiyiswitchchange()&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot; class=&quot;mar10&quot;&gt;&lt;/el-switch&gt; &lt;br&gt; &lt;el-switch v-model=&quot;simpleswithvalue&quot; @change=&quot;simpleswitchchange()&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot; class=&quot;mar10&quot;&gt;&lt;/el-switch&gt; &lt;br&gt; &lt;el-switch v-model=&quot;fenjiswithvalue&quot; @change=&quot;fenjiswitchchange()&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot; class=&quot;mar10&quot;&gt;&lt;/el-switch&gt; &lt;br&gt; &lt;el-switch v-model=&quot;heatswithvalue&quot; @change=&quot;heatswitchchange()&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot; class=&quot;mar10&quot;&gt;&lt;/el-switch&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;button id=&quot;weiyibtn&quot; class=&quot;noable&quot; @click=&quot;weiyiopen&quot;&gt;&lt;/button&gt; &lt;button id=&quot;weiyinobtn&quot; class=&quot;noable&quot; @click=&quot;weiyinoopen&quot;&gt;&lt;/button&gt; &lt;button id=&quot;simplebtn&quot; class=&quot;noable&quot; @click=&quot;simpleopen&quot;&gt;&lt;/button&gt; &lt;button id=&quot;simplenobtn&quot; class=&quot;noable&quot; @click=&quot;simplenoopen&quot;&gt;&lt;/button&gt; &lt;button id=&quot;fenjibtn&quot; class=&quot;noable&quot; @click=&quot;fenjiopen&quot;&gt;&lt;/button&gt; &lt;button id=&quot;fenjinobtn&quot; class=&quot;noable&quot; @click=&quot;fenjinoopen&quot;&gt;&lt;/button&gt; &lt;button id=&quot;heatbtn&quot; class=&quot;noable&quot; @click=&quot;heatopen&quot;&gt;&lt;/button&gt; &lt;button id=&quot;heatnobtn&quot; class=&quot;noable&quot; @click=&quot;heatnoopen&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as esriLoader from &#x27;esri-loader&#x27;import $ from &#x27;jquery&#x27;export default &#123; data() &#123; return &#123; lendgeVisible: true, layerlistVisible: true, measurementVisible: true, weiyiswithvalue: false, simpleswithvalue: false, fenjiswithvalue: false, heatswithvalue: false, mapurl: &#x27;http://localhost:6080/arcgis/rest/services/webgis/China_POI_dizhou/MapServer&#x27; &#125; &#125;, // 我们需要在该组件装载之后做的事情都放在该方法里 mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.28&#x27; &#125;) this.createMap(this) &#125;, // 我们需要执行的方法都定义在该属性里 methods: &#123; createMap: function (that) &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;esri/layers/FeatureLayer&#x27;, &#x27;dojo/on&#x27;, &#x27;dojo/colors&#x27;, &#x27;esri/symbols/SimpleMarkerSymbol&#x27;, &#x27;esri/symbols/SimpleLineSymbol&#x27;, &#x27;esri/renderers/UniqueValueRenderer&#x27;, &#x27;esri/renderers/SimpleRenderer&#x27;, &#x27;esri/renderers/ClassBreaksRenderer&#x27;, &#x27;esri/renderers/HeatmapRenderer&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, ArcGISDynamicMapServiceLayer, FeatureLayer, on, Color, SimpleMarkerSymbol, SimpleLineSymbol, UniqueValueRenderer, SimpleRenderer, ClassBreaksRenderer, HeatmapRenderer]) =&gt; &#123; var map = new Map(&#x27;map&#x27;) var layer = new FeatureLayer(that.mapurl + &#x27;/1&#x27;) map.addLayer(layer) var weiyifeatureLayer var simplefeatureLayer var fenjifeatureLayer var heatfeatureLayer // 唯一值渲染 on($(&#x27;#weiyibtn&#x27;), &#x27;click&#x27;, function () &#123; weiyifeatureLayer.show() &#125;) on($(&#x27;#weiyinobtn&#x27;), &#x27;click&#x27;, function () &#123; weiyifeatureLayer.hide() &#125;) function addWeiyiFeatureLayer() &#123; weiyifeatureLayer = new FeatureLayer(that.mapurl + &#x27;/0&#x27;, &#123; mode: FeatureLayer.MODE_SNAPSHOT, outFields: [&#x27;*&#x27;] &#125;) var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_NULL, new Color([255, 0, 0]), 0) var marker1 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 12, lineSymbol, new Color([255, 218, 185, 0.4])) var marker2 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 15, lineSymbol, new Color([244, 164, 96, 0.4])) var marker3 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 18, lineSymbol, new Color([210, 105, 30, 0.4])) var marker4 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 12, lineSymbol, new Color([205, 133, 63, 0.4])) var marker5 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 25, lineSymbol, new Color([139, 69, 19, 0.4])) var renderer = new UniqueValueRenderer(marker1, &#x27;jishu&#x27;) renderer.addValue(&#x27;1&#x27;, marker1) renderer.addValue(&#x27;2&#x27;, marker2) renderer.addValue(&#x27;3&#x27;, marker3) renderer.addValue(&#x27;4&#x27;, marker4) renderer.addValue(&#x27;5&#x27;, marker5) weiyifeatureLayer.setRenderer(renderer) map.addLayer(weiyifeatureLayer) weiyifeatureLayer.hide() &#125; // 简单渲染 on($(&#x27;#simplebtn&#x27;), &#x27;click&#x27;, function () &#123; console.log(&#x27;show&#x27;) simplefeatureLayer.show() &#125;) on($(&#x27;#simplenobtn&#x27;), &#x27;click&#x27;, function () &#123; console.log(&#x27;hide&#x27;) simplefeatureLayer.hide() &#125;) function addSimpleFeatureLayer() &#123; simplefeatureLayer = new FeatureLayer(that.mapurl + &#x27;/0&#x27;) var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_NULL, new Color([255, 0, 0]), 0) var simplemarker = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 18, lineSymbol, new Color([100, 149, 237, 0.4])) var smpRenderer = new SimpleRenderer(simplemarker) var sizeInfo = &#123; field: &#x27;pm_2_5&#x27;, valueUnit: &#x27;unknown&#x27;, minSize: 1, maxSize: 50, minDataValue: 0, maxDataValue: 50000 &#125; smpRenderer.setSizeInfo(sizeInfo) simplefeatureLayer.setRenderer(smpRenderer) map.addLayer(simplefeatureLayer) simplefeatureLayer.hide() &#125; // 分级渲染 on($(&#x27;#fenjibtn&#x27;), &#x27;click&#x27;, function () &#123; fenjifeatureLayer.show() &#125;) on($(&#x27;#fenjinobtn&#x27;), &#x27;click&#x27;, function () &#123; fenjifeatureLayer.hide() &#125;) function addFenjiFeatureLayer() &#123; fenjifeatureLayer = new FeatureLayer(that.mapurl + &#x27;/0&#x27;) var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_NULL, new Color([255, 0, 0]), 0) var marker1 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 12, lineSymbol, new Color([152, 251, 152, 0.4])) var marker2 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 15, lineSymbol, new Color([0, 255, 0, 0.4])) var marker3 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 18, lineSymbol, new Color([50, 205, 50, 0.4])) var marker4 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 12, lineSymbol, new Color([60, 179, 113, 0.4])) var marker5 = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 25, lineSymbol, new Color([46, 139, 87, 0.4])) var fjRenderer = new ClassBreaksRenderer(marker3, &#x27;AQI&#x27;) fjRenderer.addBreak(0, 100, marker1) fjRenderer.addBreak(100, 200, marker2) fjRenderer.addBreak(200, 300, marker3) fjRenderer.addBreak(300, 400, marker4) fjRenderer.addBreak(500, 600, marker5) fenjifeatureLayer.setRenderer(fjRenderer) map.addLayer(fenjifeatureLayer) fenjifeatureLayer.hide() &#125; // 热力图渲染 on($(&#x27;#heatbtn&#x27;), &#x27;click&#x27;, function () &#123; heatfeatureLayer.show() &#125;) on($(&#x27;#heatnobtn&#x27;), &#x27;click&#x27;, function () &#123; heatfeatureLayer.hide() &#125;) function addHeatFeatureLayer() &#123; heatfeatureLayer = new FeatureLayer(that.mapurl + &#x27;/0&#x27;) var heatmapRenderer = new HeatmapRenderer(&#123; colorStops: [ &#123; color: &#x27;rgba(63, 40, 102, 0)&#x27;, ratio: 0 &#125;, &#123; color: &#x27;#472b77&#x27;, ratio: 0.083 &#125;, &#123; color: &#x27;#4e2d87&#x27;, ratio: 0.166 &#125;, &#123; color: &#x27;#563098&#x27;, ratio: 0.249 &#125;, &#123; color: &#x27;#5d32a8&#x27;, ratio: 0.332 &#125;, &#123; color: &#x27;#6735be&#x27;, ratio: 0.415 &#125;, &#123; color: &#x27;#7139d4&#x27;, ratio: 0.498 &#125;, &#123; color: &#x27;#7b3ce9&#x27;, ratio: 0.581 &#125;, &#123; color: &#x27;#853fff&#x27;, ratio: 0.664 &#125;, &#123; color: &#x27;#a46fbf&#x27;, ratio: 0.747 &#125;, &#123; color: &#x27;#c29f80&#x27;, ratio: 0.83 &#125;, &#123; color: &#x27;#e0cf40&#x27;, ratio: 0.913 &#125;, &#123; color: &#x27;#ffff00&#x27;, ratio: 1 &#125; ], blurRadius: 7, // field: &#x27;pm2_5&#x27;, maxPixelIntensity: 180, minPixeltIntensiy: 10 &#125;) heatfeatureLayer.setRenderer(heatmapRenderer) console.log(heatfeatureLayer) map.addLayer(heatfeatureLayer) heatfeatureLayer.hide() &#125; addFenjiFeatureLayer() addSimpleFeatureLayer() addWeiyiFeatureLayer() addHeatFeatureLayer() // $(&#x27;#fenjibtn&#x27;).click() &#125;) &#125;, weiyiswitchchange() &#123; if (this.weiyiswithvalue === true) $(&#x27;#weiyibtn&#x27;).click() else $(&#x27;#weiyinobtn&#x27;).click() &#125;, simpleswitchchange() &#123; if (this.simpleswithvalue === true) $(&#x27;#simplebtn&#x27;).click() else $(&#x27;#simplenobtn&#x27;).click() &#125;, fenjiswitchchange() &#123; if (this.fenjiswithvalue === true) $(&#x27;#fenjibtn&#x27;).click() else $(&#x27;#fenjinobtn&#x27;).click() &#125;, heatswitchchange() &#123; if (this.heatswithvalue === true) $(&#x27;#heatbtn&#x27;).click() else $(&#x27;#heatnobtn&#x27;).click() &#125;, weiyiopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;AQI级数唯一值渲染&#x27;), type: &#x27;success&#x27; &#125;) &#125;, weiyinoopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;取消AQI级数唯一值渲染&#x27;), type: &#x27;warning&#x27; &#125;) &#125;, simpleopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;pm2.5简单渲染&#x27;), type: &#x27;success&#x27; &#125;) &#125;, simplenoopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;取消pm2.5简单渲染&#x27;), type: &#x27;warning&#x27; &#125;) &#125;, fenjiopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;AQI分级渲染&#x27;), type: &#x27;success&#x27; &#125;) &#125;, fenjinoopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;取消AQI分级渲染&#x27;), type: &#x27;warning&#x27; &#125;) &#125;, heatopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;热力图渲染&#x27;), type: &#x27;success&#x27; &#125;) &#125;, heatnoopen() &#123; const h = this.$createElement this.$notify(&#123; title: &#x27;Message&#x27;, message: h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;取消热力图渲染&#x27;), type: &#x27;warning&#x27; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","tags":[]},{"title":"网络流---算法理解","date":"2021-07-22T09:54:49.049Z","path":"2021/07/22/网络流---算法理解/","text":"最大流交通网络中有人流、车流、货流，供水网络中有水流，金融网络中有金流。这些都涉及到了最大流问题 而最大流存在于网络流中 那么问题来了，什么是网络流？ 首先，你得有一个有向图。即网络 还得有两个特殊点：起点终点。即源汇 每条边有一个权值。即容量 有了这些，就构成了一个基础的网络流 有点绕。。。换个思路 自来水厂是源，家是汇 自来水厂和家之间有很多的管道用来输送水。由于地形和地质的影响，管道规格有多种。通过的水容量也各不相同 清楚了网络流，那么什么是网络流中能到达汇点的最大流呢？ 从源点到汇点的最大可行性流量即为最大流 这个问题就是说，自来水厂供水，那么在家能收到的最大的水流量是多少？ 自来水厂开始供水之前，水流量必定是0 自开水厂开闸供水，水从管道流向家。家开始收到水 自开水厂再开一个闸门供水，水从管道流向家。家里的水流量增加 。 。 打开若干闸门，水流量持续增加 。 。 自开水厂再开一个闸门供水，水从管道流向家。家里的水流量没有发生改变此时，便达到了从自来水厂到家这个网络的最大可行性流 网络流具有三个性质 容量限制：实际流量 &lt; 每条边的容量 自来水管中的水必定是小于它的最大承载容量。否则水管该爆了。 流量守恒：每一个点（不包含源汇点）到相邻节点的流量之和为0. 每一个中间点必定是流进来多少水，流出去多少水。 不可能没有流进来就流出去，也不可能流进来后就不出去。 至于为什么是中间点，因为我问不用知道自来水厂的水是来自哪里的 反对称（斜对称）性：u -&gt; v 的流量 == -（v -&gt; u） 的流量 在坐标系中，a 到 b 的位移是 x ，则 b 到 a 的位移是 -x 同样的 u -&gt; v 的流量为 f ，那么 v -&gt; u 必定是 -f ; 网络流中的名词解释 网络：有源汇点的有向图 容量网络：带有容量值（权值）的有向图（不变） 流量网络：带有流量值（权值）的有向图（改变），最终形态就是最大网络流 残留网络: 带有残余流量值（权值）的有向图（改变），残余流量值：容量-流量的剩余量值。就像是，自来水管中，水流量没有达到管道容量时，中空气的体积容量（空的部分）。 显而易见：残留网络 = 容量网络 - 流量网络 割集：割一些边，使得以源点和汇点为两边，分为两个点集。（非连通图） 割：断开一些边，最小割即为断开权值最小的边 割集类似于，有小偷把自来水厂和家之间的管道偷走了一些，使得水不管从哪个管道走，都不能到家。 割则取决于小偷要偷哪个。最小割便是偷走最小，最轻的管道，最省力，最容易达到目的。","tags":[]},{"title":"网络分析（最短路径+最邻近+路网数据）源码","date":"2021-07-22T09:54:49.047Z","path":"2021/07/22/网络分析（最短路径+最邻近+路网数据）源码/","text":"移步码云下载请留下一个Star","tags":[]},{"title":"书签+图层列表+测量工具+图例+鹰眼+地图切换","date":"2021-07-22T09:54:49.045Z","path":"2021/07/22/书签+图层列表+测量工具+图例+鹰眼+地图切换/","text":"效果图 1. 书签1234567891011121314// 书签 var bookmarksList = [ &#123; extent: &#123; xmin: 106, ymin: 39, xmax: 112, ymax: 32 &#125;, name: &#x27;陕西&#x27; &#125;, &#123; extent: &#123; xmin: 111, ymin: 31, xmax: 117, ymax: 35 &#125;, name: &#x27;河南&#x27; &#125;, &#123; extent: &#123; xmin: 109, ymin: 35, xmax: 121, ymax: 42 &#125;, name: &#x27;河北&#x27; &#125;, &#123; extent: &#123; xmin: 115, ymin: 31, xmax: 121, ymax: 34 &#125;, name: &#x27;江苏&#x27; &#125;, &#123; extent: &#123; xmin: 90, ymin: 22, xmax: 114, ymax: 36 &#125;, name: &#x27;四川&#x27; &#125; ] const bookmarks = new Bookmarks(&#123; map: map, bookmarks: bookmarksList, editable: true &#125;, &#x27;bookmarks&#x27;) bookmarks.startup() 2. 图层列表123456// 图层列表 var myWidget = new LayerList(&#123; map: map, layers: donglayer &#125;, &#x27;layerList&#x27;) myWidget.startup() 3. 测量工具12345// 测量工具 var measurement = new Measurement(&#123; map: map &#125;, &#x27;measurementDiv&#x27;) measurement.startup() 4. 图例12345// 图例 var legend = new Legend(&#123; map: map &#125;, &#x27;legendDiv&#x27;) legend.startup() 5. 鹰眼123456// 鹰眼 var overviewMapDijit = new OverviewMap(&#123; map: map, visible: true &#125;, &#x27;overview&#x27;) overviewMapDijit.startup() 6. 地图切换123456// 地图切换 var basemapToggle = new BasemapToggle(&#123; map: map, visible: true &#125;, &#x27;basemapToggle&#x27;) basemapToggle.startup() 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;template&gt; &lt;div&gt; &lt;div id=&quot;home&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;19&quot;&gt; &lt;div class=&quot;grid-content bg-purple&quot;&gt; &lt;div id=&quot;overview&quot; style=&quot;height: 100px; width: 150px; float:left;&quot;&gt;&lt;/div&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;5&quot;&gt; &lt;div class=&quot;grid-content bg-purple-light&quot;&gt; &lt;el-card id=&quot;mapOut&quot; style=&quot;overflow-y: scroll;&quot;&gt; &lt;!-- 书签--&gt; &lt;el-card style=&quot; padding: 5px;&quot;&gt; &lt;div id=&quot;bookmarks&quot;&gt;&lt;/div&gt; &lt;/el-card&gt; &lt;!-- 图层列表--&gt; &lt;el-card&gt; &lt;div id=&quot;layerListPane&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot;&gt; &lt;div id=&quot;layerList&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;el-card&gt; &lt;div id=&quot;titlePane&quot; class=&quot;esriLayerList&quot; data-dojo-type=&quot;dijit/TitlePane&quot;&gt; &lt;div id=&quot;measurementDiv&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;!-- 图例--&gt; &lt;el-card shadow=&quot;always&quot; class=&quot;box-card&quot; style=&quot;width: 100%&quot;&gt; &lt;div slot=&quot;header&quot; class=&quot;clearfix&quot;&gt; &lt;span&gt;Lendge&lt;/span&gt; &lt;el-button style=&quot;float: right; padding: 3px 0&quot; type=&quot;text&quot; @click=&quot;lendgeVisible ? hideLendge() : showLendge()&quot;&gt;&#123;&#123;this.lendgeVisible&#125;&#125; &lt;/el-button&gt; &lt;/div&gt; &lt;div id=&quot;legendDiv&quot;&gt;&lt;/div&gt; &lt;/el-card&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;div style=&quot;position: absolute; bottom: 20px; z-Index:999;&quot;&gt; &lt;div id=&quot;basemapToggle&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as esriLoader from &#x27;esri-loader&#x27;import $ from &#x27;jquery&#x27;export default &#123; data() &#123; return &#123; lendgeVisible: true &#125; &#125;, // 我们需要在该组件装载之后做的事情都放在该方法里 mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.28&#x27; &#125;) this.createMap() &#125;, // 我们需要执行的方法都定义在该属性里 methods: &#123; createMap: function () &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;dojo/dom&#x27;, &#x27;dojo/on&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;esri/dijit/Scalebar&#x27;, &#x27;esri/dijit/OverviewMap&#x27;, &#x27;esri/dijit/BasemapToggle&#x27;, &#x27;esri/dijit/BasemapGallery&#x27;, &#x27;esri/dijit/Bookmarks&#x27;, &#x27;esri/dijit/Measurement&#x27;, &#x27;esri/dijit/Legend&#x27;, &#x27;esri/dijit/LayerList&#x27;, &#x27;esri/tasks/PrintTask&#x27;, &#x27;esri/tasks/PrintTemplate&#x27;, &#x27;esri/tasks/PrintParameters&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, dom, on, ArcGISDynamicMapServiceLayer, Scalebar, OverviewMap, BasemapToggle, BasemapGallery, Bookmarks, Measurement, Legend, LayerList, PrintTask, PrintTemplate, PrintParameters]) =&gt; &#123; var dongURL = &#x27;http://localhost:6080/arcgis/rest/services/webgis/China_POI/MapServer&#x27; var donglayer = new ArcGISDynamicMapServiceLayer(dongURL) // 初始化容器 const map = new Map(&#x27;map&#x27;, &#123; center: [108.934518, 34.35333], zoom: 7, logo: false, basemap: &#x27;oceans&#x27; &#125;) map.addLayer(donglayer) // 鹰眼 var overviewMapDijit = new OverviewMap(&#123; map: map, visible: true &#125;, &#x27;overview&#x27;) overviewMapDijit.startup() // 地图切换 var basemapToggle = new BasemapToggle(&#123; map: map, visible: true &#125;, &#x27;basemapToggle&#x27;) basemapToggle.startup() // 书签 var bookmarksList = [ &#123; extent: &#123; xmin: 106, ymin: 39, xmax: 112, ymax: 32 &#125;, name: &#x27;陕西&#x27; &#125;, &#123; extent: &#123; xmin: 111, ymin: 31, xmax: 117, ymax: 35 &#125;, name: &#x27;河南&#x27; &#125;, &#123; extent: &#123; xmin: 109, ymin: 35, xmax: 121, ymax: 42 &#125;, name: &#x27;河北&#x27; &#125;, &#123; extent: &#123; xmin: 115, ymin: 31, xmax: 121, ymax: 34 &#125;, name: &#x27;江苏&#x27; &#125;, &#123; extent: &#123; xmin: 90, ymin: 22, xmax: 114, ymax: 36 &#125;, name: &#x27;四川&#x27; &#125; ] const bookmarks = new Bookmarks(&#123; map: map, bookmarks: bookmarksList, editable: true &#125;, &#x27;bookmarks&#x27;) bookmarks.startup() // 测量工具 var measurement = new Measurement(&#123; map: map &#125;, &#x27;measurementDiv&#x27;) measurement.startup() // 图层列表 var myWidget = new LayerList(&#123; map: map, layers: donglayer &#125;, &#x27;layerList&#x27;) myWidget.startup() // 图例 var legend = new Legend(&#123; map: map &#125;, &#x27;legendDiv&#x27;) legend.startup() &#125;) &#125;, hideLendge() &#123; this.lendgeVisible = !this.lendgeVisible $(&#x27;#legendDiv&#x27;).hide() &#125;, showLendge() &#123; this.lendgeVisible = !this.lendgeVisible $(&#x27;#legendDiv&#x27;).show() &#125;, opensuccess() &#123; this.$message(&#123; message: &#x27;success&#x27;, type: &#x27;success&#x27; &#125;) &#125;, openWarning() &#123; this.$message(&#123; message: &#x27;非地理坐标系&#x27;, type: &#x27;warning&#x27; &#125;) &#125; &#125;&#125;&lt;/script&gt;","tags":[]},{"title":"联动","date":"2021-07-22T09:54:49.043Z","path":"2021/07/22/联动/","text":"这次采用了使用4.x的功能实现联动，3.x的extent-change可以实现，但是会出现延迟。实现嗯，很简单，创建两个Mapview，监听事件，设置center和zoom但是设置zoom，总是会莫名的出BUG，或者在多监听一个滚轮方便一点就是现在使用的办法。 4.x 动态地图的加载 12345678view01.on([&quot;pointer-down&quot;, &quot;pointer-move&quot;], function (evt) &#123; view02.center = view01.center; view02.scale = view01.scale;//代替zoom&#125;);view02.on([&quot;pointer-down&quot;, &quot;pointer-move&quot;], function (evt) &#123; view01.center = view02.center; view01.scale = view02.scale;&#125;);","tags":[]},{"title":"空间数据库总结","date":"2021-07-22T09:54:49.041Z","path":"2021/07/22/空间数据库总结/","text":"空间数据库第一章1. 数据的特点：数据与其语义不可分割 2. 数据库的特点： 数据共享 数据独立（程序和数据结构之间相互独立） 减少数据冗余 避免数据不一致和加强了数据保护 3. 数据库管理系统DBMS的功能： 数据定义功能：提供数据定义语言(DDL)，对数据库、表、索引的定义 数据操作功能：提供数据操纵语言(DML)，实现对数据库的基本操作 (查询、插入、删除和修改) 数据库运行控制功能：并发控制、安全性检查、完整性约束条件的检查和执行、索引的自动建立 数据库的建立和维护功能：初始数据的输入、转换，数据的存储组织，数据库的转储恢复，性能监视、分析功能等 4. 数据库系统DBS的构成 数据库 数据库管理系统 数据库管理员、用户 应用程序 5. 数据库系统DBS特点 数据结构化 数据的共享性高，冗余度低，易扩充 数据独立性高 数据由DBMS统一管理和控制 6. 数据管理技术 人工管理阶段(20世纪40年代中–50年代中) 文件系统阶段(20世纪50年代末–60年代中) 数据库系统阶段(20世纪60年代末–现在) 7. 内部结构：三级模式，两级映像，逻辑独立性和物理独立性 三级模式：对数据的三个抽象级别 模式 外模式（子模式或用户模式）：介于模式与应用之间。同一个模式可以有任意多个外模式。模式与外模式的关系：一对多，外模式与应用的关系：一对多 内模式（也称存储模式）：数据物理结构和存储方式的描述。一个数据库只有一个内模式 两级映像：在DBMS内部实现这三个抽象层次的联系和转换 外模式／模式映像：每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系，保证数据的逻辑独立性 模式／内模式映像 ：定义了数据全局逻辑结构与存储结构之间的对应关系。模式／内模式映象是唯一的。保证数据的物理独立性 8. 数据模型 概念模型：实体－联系法(E-R图法) 逻辑模型 物理模型 三要素： 数据结构 数据操作 完整性约束条件 9. 常用模型 层次（树形结构） 网状（图） 关系（二维表) 10. 关系的完整性约束条件 实体完整性 参照完整性 用户定义的完整性 第二章1. 空间数据及特征： 空间数据： 对空间事物的描述 以地球表面空间位置为参照，用来描述空间实体的位置、形状、大小及其分布特征诸多方面信息的数据 一种带有空间坐标的数据 空间数据获取方式包括人工统计、仪器测量等必然产生误差 特征： 时空特征（空间特征、属性特征、时态特征） 多维特征（空间三维与时间维，多维属性信息） 多尺度特征（空间多尺度、时间多尺度，空间坐标和空间关系变长结构，非结构化特征） 海量数据特征 空间数据类型（P9） 地图数据 影像数据 地形数据 属性数据 2. 空间数据库SDB的概念和构成概念：描述与特定空间位置相关的真实世界对象的数据集合 构成 空间数据库 空间数据管理系统 空间数据库应用程序 用户 3.五种空间数据的管理模式 文件管理方式 二元化空间数据库管理系统 全关系型空间数据库管理系统 对象－关系空间数据库管理系统 面向对象空间数据库管理系统 4. 空间信息（概念）模型 数据模型：表示空间参考对象也即要将空间实体抽象为数据模型。 场模型：连续对象的描述（二维，三维），不能够对单独对象进行描述 对象模型：强调单个对象，把空间对象当做空间要素来表达（点线面体） 网络模型：网络状对象的描述 场的组成部分 空间框架：构建了场的定义域 连续平面：坐标定位 离散网格：编码定位 场函数：属性域 例子中的森林单一场：空间框架f(x,y)→属性域（冷杉，橡树，松树） 场操作 局部操作 聚焦操作 区域操作 5. 拓扑操作（几何不变性）、九交矩阵描述 第三章 + 第四章1. 关系模型的三要素 1.8 集合运算：并、交、差、笛卡尔积 专门的关系运算：选择、投影、连接、除 五种基本：并、差、笛卡尔积、选择、投影 2. 关系的性质（了解） 列是同质的：同一属性名下的诸属性是同类型数据，且必须来自同一个域 不同列属性必须有不同属性名 列、行的次序无所谓、可以任意交换 任意两个元组不能完全相同 不允许“表中套表”，即分量必须取原子值，每一个分量必须是不可分的数据项 3. 关系代数的写法 &lt;!-- 写关系代数 --&gt; 4. SQL语句的写法 &lt;!-- SQL语句 --&gt; 5. SQL的特点：非过程化（了解） 一体化特点。 高度非过程化。 语言简洁，易学易用。 统一的语法结构对待不同的工作方式。 面向集合的操作方式。 SQL语言可以对两种基本数据结构进行操作，一种是“表”，另一种是“视图(View)”。 6. 数据定义的命令 表 create Alter ( add, drop, modify修改 ) drop 视图 create ( update, delete, Insert ) drop 索引 create drop × 第五章1. E-R图 ，带象形图的E-R图：将对象插在方框内的微缩图 2. 扩展SQL，SQL3和SQL99版本，有了用户自定义类型对象关系数据库 关键特性就是支持SQL3/SQL99。 SQL3中支持用户自定义数据类型。 空间数据库就是要研究SQL3/SQL99，对标准SQL语言进行扩展，从而操纵和获取空间数据。 3. OGIS联盟 标准操作：8种 P74-75 拓朴/集合运算： Equal 如果两个几何体完全相同返回真 Disjoint 两个几何体内部和边界都不相交返回真 Intersect 两几何体相交则返回真 Touch 两几何体边界相交则返回真 Cross 如果线和面的内部相交则返回真 Within 给定几何内部不和另一几何的外部相交返回真 Contains 判断给定几何体是否包含另一几何体 Overlap 如果两几何体内部有非空交集返回真 4. 创建空间表 123456CREATE TABLE Country( Name varchar(35) Primary key, Pop Integer, GDP double Life FLOAT, Shape Polygon) 5. 空间查询 P76 第五章PPT P52 第六章1. 物理、空间模型：实现逻辑模型2. 存储架构 主存（提升性能）——速度很快（纳秒级），但关电源后存储内容丢失 二级存储设备（存储数据）——速度慢（微秒级），但存储内容不受电源的影响 三级存储设备（存储备份）——速度更慢，存储内容不受电源影响，往往存储容量非常大。 3. 磁盘物理结构： 盘片：物理圆形磁片 磁道：盘片上的同心圆，磁道密度决定容量 柱面：所有盘片上的直径相同的磁道 扇区：组成页面（存储）的最小单位，有扇区号 页面：磁盘和主存间的最小传输单位，一般为扇区的整数倍 4. 存取时间和构成：ts、tt、tl 寻道时间：移动磁头到相应磁道上的时间ts 延迟时间：要读取页面旋转到磁头下的时间tl 传输时间：磁头读或写相应数据的时间tt ts&gt;tl&gt;tt tt一般在初始时固定，但ts和tl可能通过优化策略缩短。 5. 主存上缓冲区管理器及缓冲策略 DBMS模块：先进先出 缓冲区管理器 DBMS的一个软件模块 负责缓冲区空间分配调度的子系统 缓冲区替换策略 最近使用（LRU） 替换出最长时间没有读或写过的块 先进先出（FIFO） 替换出被同一个块占用时间最长的缓冲块 “时钟”算法 LRU的一个常见的、有效的近似 系统控制 查询优化器或者其它的DBMS部件可以给缓冲区管理器提供建议来避免象LRU，FIFO，或者时钟这样的严格的策略可能引起的问题 6. 根据存储容量从小到大采用什么存储策略 从小到大 同一扇区 相邻扇区 = 同一个磁道 同一柱面 减少存到时间 相邻柱面 7. 文件结构 PPT P33 无序（堆）文件 顺序文件 散列文件 聚类文件（用于空间数据存储） 8. 空间填充曲线（过程） &lt;!-- 画图 --&gt; Z曲线 hilbert 9. 空间数据的组织 横向分幅（标准分幅或区域分幅等） 标准经纬度分块 矩形分块 任意区域多边形分块 &lt;!--小比例尺按经纬线分幅，大比例尺地图按矩形分幅。--&gt; 纵向分层 专题分层 每个图层对应一个专题，包含某一种或某一类数据。如地貌层、水系层、道路层、居民地层等。 时间序列分层 把不同时间或不同时期的数据作为多个数据层。 地面垂直高度分层 把不同垂直高度的数据作为一个数据层。 分层分块索引 金字塔含义和性质（分辨率变、范围不变、每块不同） 核心：对遥感影像进行分层、分块 分层就是把原始影像数据按照不同分辨率进行管理，具体就是把分辨率高的影像层依次通过重采样算法生成其上层的影像数据。 分块是对分层之后的影像数据按照设定好的影像块进行分割存储。分块之后只需要将需要显示和处理的若干个影像块数据读入内存，而并非未分块前的一整幅影像。 最后对每层的影像块（分块大小相等）统一组织存储。 性质： 从底层到顶层，分辨率越来越低，但表示的空间范围不变。 一般采用固定大小（通常取2的幂次方）的分块方法。目前建立影像数据库多采用数据块大小为 128×128或 256×256。 &lt;!--影像的尺寸越来越小，但描述的空间范围是不变的，最终分辨率降低。--&gt; 10. B-数和B+数 –》R树 B-树是一种平衡的多路查找树，m阶树 根结点或者是叶子，或者至少有两棵子树，至多有m棵子树 除根结点外，所有非终端结点至少有m/2棵子树，至多有m棵子树； 所有叶子结点都在树的同一层上； 每个结点应包含如下信息：(n，A0，K1，A1，K2，A2，… ，Kn，An) 其中Ki(1≤i≤n)是关键字，且Ki&lt;Ki+1 (1≤i≤n-1)；Ai(i=0，1，… ，n)为指向孩子结点的指针，且Ai-1所指向的子树中所有结点的关键字都小于Ki ，Ai所指向的子树中所有结点的关键字都大于Ki ；n是结点中关键字的个数，且（m/2)-1≤n≤m-1，n+1为子树的棵数。 B- 树 3阶 4阶 5阶 根结点子树 2-3 2-4 2-5 根/非终端结点子树 2-3 2-4 3-5 根/结点中关键字 1-2 1-3 2-4 根结点中关键字 1-2 1-3 1-4 B+树 从最小关键字顺序查找 从根结点开始随机查找 每个结点至多有m个子结点； 除根结点和叶结点外，其它每个结点至少有m/2 个子结点； 若根结点不是叶子结点，则至少有两个子结点； 所有的叶结点在同一层； B+ 树 3阶 4阶 5阶 根结点子树 2-3 2-4 2-5 根/非终端结点子树 2-3 2-4 3-5 根/结点中关键字 2-3 2-4 3-5 根结点中关键字 1-3 1-4 1-5 11. 什么是空间索引？ 空间索引：依据空间对象的位置和形状或空间对象之间的空间关系，按一定的顺序排列的一种数据结构。 基本思想：近似体的使用 常见的空间索引： 对象范围索引（两级过滤） 初次过滤根据空间要素外包矩形来过滤掉大部分不在查询范围的空间要素； 第二级过滤则用查询空间范围直接和初次过滤结果集中空间要素的二进制边界坐标比较，从而得到查询的准确结果 &lt;!-- 没有真正的空间索引文件，而是为空间对象添加外接矩形，依靠空间计算能力判别 --&gt; &lt;!-- 查询时仍需要对整个空间对象进行检索，某些对象可以通过矩形范围直接判别 --&gt; &lt;!-- 该方法仍需要花费大量时间进行空间检索，计算机处理速度加快，弥补了效率的要求 --&gt; 格网索引（固定网格结构，固定网格结构是固定的，它的目录稀疏而巨大） &lt;!-- 将研究区域用横竖线条划分大小相等或不等的格网，记录每一个格网所包含的空间实体 --&gt; &lt;!-- 空间查询时，首先计算出用户查询对象所在格网，然后在该网格中快速查询所选空间实体 --&gt; 第一阶段（RDBMS完成）： 接收SQL语句，获取空间过滤器的封装边界 检测空间过滤器的封装边界跨越的网格 到空间索引表中检索出封装边界所在网格内的要素 第二阶段：几何过滤器的封装边界与第一阶段检索出的要素的边界相比较，找出具有重叠关系的要素 第三阶段：几何过滤器的坐标与第二阶段检索出的要素的边界比较，找出边界在几何过滤器内的要素 第四阶段：几何过滤器的坐标与第三阶段检索出的要素的坐标比较，找出最终在几何过滤器内的要素类 格网索引（网格文件） 四叉树索引 在建立四叉树索引时，根据所有空间对象覆盖的范围，进行四叉树分割，使每个子块中包含单个实体，然后根据包含每个实体的子块层数或子块大小，建立相应的索引。 R树索引 根结点到每一个叶结点的深度相等 。 树中每个非叶结点有n到M个子结点，M 对特定的树是固定的(阶数)。2=&lt; n&lt;= M/2 12.对象范围索引中有一个检索关系式空间对象被检索 Xmax ≥ XW and Xmin≤XE AND Ymax ≥ YS and Ymin≤YN 空间对象不被检索Xmax ≤ XW OR Xmin ≥ XE OR Ymax ≤ YS OR Ymin ≥YN 13. 网格文件索引 &lt;!-- 画图 --&gt; 根据空间维度划分k维空间。 将平面索引空间划分为相等或不等的一些小方格网。 与每个格网相关联的空间目标存储到同一磁盘页面（桶）或多个磁盘页面（溢出桶）。 页面的访问地址通过格网的线性标量（数组下标）求得。 线性标量是空间目标实际坐标按照线型比例生成的索引。 14. R树特征(10-12条) 每个叶结点包含m至M条索引记录(其中m&lt;=M/2 ) 一个叶结点上的每条索引记录了最小外包矩形。 每个非叶结点都有m至M个子结点。 对于非叶结点中的每个条目包含其子结点中矩形的最小外包矩形。 根结点至少有两子结点。 所有叶结点出现在同一层。 所有MBR的边与一个全局坐标系的轴平行。 R树允许结点相互覆盖,这种交叠可以使R树保持较高的空间利用率和保持树的平衡。 过多交叠可能会造成查询效率的降低,最坏的情况下对某一对象的查询可能造成对整个树的搜索。 R树搜索的性能取决于两个参数：覆盖和交叠。 树的某一层覆盖是指这一层所有节点的MBR所覆盖的全部区域。 若想要得到一个高效的R树，覆盖和交叠都应该很小。 15. 最优R树画法 &lt;!-- 画图 --&gt; 第七章1. 策略 选择运算尽可能先做 投影运算和选择运算同时进行 把投影运算同其前后的双目运算结合执行 执行连接运算前，进行适当的预处理 选择运算和笛卡尔积运算结合成连接运算 找出公共子表达式，避免重复运算 2. 空间操作的两步处理：过滤步骤、精炼步骤练习题 数据库系统的特点是数据共享、数据独立、减少数据冗余、避免数据不一致和加强了数据保护。 数据库管理系统（DBMS）是系统软件 数据库管理系统能实现对数据库中数据的查询、插入、修改和删除等操作．这种功能称为数据操纵功能 在数据库的三级模式结构中，描述数据库中全体数据的全局逻辑结构和特征的是模式 数据库系统的数据独立性是指不会因为数据的变化而影响应用程序 数据库类型是按照数据模型来划分的 一组具有相同数据类型的值的集合称为域 在数据库中存储的是数据以及数据之间的联系 按所使用的数据模型来分，数据库可分为层次、关系和网状三种模型 在数据库设计中用关系模型来表示实体和实体之间的联系。关系模型的结构是二维表结构 在关系模型中，实现”关系中不允许出现相同的元组”的约束是通过主键 关系模型由数据结构、关系操作集合和完整性约束三部分组成","tags":[]},{"title":"卷帘","date":"2021-07-22T09:54:49.039Z","path":"2021/07/22/卷帘/","text":"思路 定义要素图层 new一个卷帘对象 开启小部件PS：要素图层需要添加在map容器中才能在卷帘对象中设置layers 实用方法12swipeWidget01.disable();//禁用小部件swipeWidget23.enable();//启用小部件 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Layer Swipe&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;esri.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;tundra.css&quot; /&gt; &lt;style&gt; html, body, #map &#123; padding: 0; margin: 0; height: 100%; position: relative; &#125; &lt;/style&gt; &lt;script src=&quot;https://js.arcgis.com/3.29/&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;calcite&quot;&gt;&lt;div id=&quot;map&quot; class=&quot;map&quot;&gt; &lt;div id=&quot;swipeDiv&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; require([ &quot;esri/map&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/dijit/LayerSwipe&quot;, &quot;dojo/domReady!&quot; ], function ( Map, FeatureLayer, LayerSwipe ) &#123; var map = new Map(&quot;map&quot;); thingslayer0 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/gaofen/bazhou/MapServer&quot; + &quot;/0&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] &#125;); thingslayer1 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/gaofen/bazhou/MapServer&quot; + &quot;/1&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] &#125;); //矢量 map.addLayer(thingslayer0); map.addLayer(thingslayer1); var swipeWidget = new LayerSwipe(&#123; type: &quot;vertical&quot;, map: map, // 要卷帘哪些图层 layers: [thingslayer0, thingslayer1], &#125;, &quot;swipeDiv&quot;); swipeWidget.startup(); &#125;);&lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"加载---闪烁Layer","date":"2021-07-22T09:54:49.037Z","path":"2021/07/22/加载---闪烁Layer/","text":"一个简单的图层切换闪烁动画，js入门练手知识点设置显示图层layer.setVisibleLayers([0]); 查看图层编号步骤： 查看已经发布地图服务 功能—REST URL 查看 贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass &#123; width: 100%; height: 960px; border: 1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; var flag = 0; var Max_layer=30; function init()&#123; var btn = document.getElementById(&quot;btn0&quot;); setInterval(function()&#123; btn.click(); &#125;,500); &#125; require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;], function (Map, on, dom, ArcGISDynamicMapServiceLayer ) &#123; var map = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/demo/WLFX_huanbao/MapServer&quot;); map.addLayer(layer); layer.setVisibleLayers([0]); on(dom.byId(&quot;btn0&quot;),&quot;click&quot;,function(e)&#123; flag++; if(flag&lt;=Max_layer) layer.setVisibleLayers([flag]); else flag=0; &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;init()&quot;&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button type=&quot;button&quot; id=&quot;btn0&quot; &gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"加载---加载动态图层+注册文件夹","date":"2021-07-22T09:54:49.035Z","path":"2021/07/22/加载---加载动态图层+注册文件夹/","text":"基础：加载动态图层方法： 添加一个button（添加动态图层），给button绑定on模块的点击事件 1on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e)&#123;&#125;) 定义数据源，设置命名空间，设置命名空间下面的shp 123var dataSource = new TableDataSource();dataSource.workspaceId = &quot;demo&quot;;dataSource.dataSourceName = &quot;demoShp.shp&quot;; 定义图层数据源，对其赋值 12var layerSource = new LayerDataSource();layerSource.dataSource = dataSource; 定义要素图层（动态图层） 123456var layer2 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/dynamicLayer&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource&#125;); 定义线符号，渲染器 123var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3);var renderer = new esri.renderer.SimpleRenderer(lineSymbol); 给要素图层设置渲染器 12layer2.setRenderer(renderer);layer2.refresh(); 把要素图层添加到map上 1map.addLayer(layer2); 贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/layers/TableDataSource&quot;, &quot;esri/layers/LayerDataSource&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;dojo/domReady!&quot;], function ( Map,dom,on, ArcGISDynamicMapServiceLayer, FeatureLayer, TableDataSource, LayerDataSource, SimpleRenderer,SimpleLineSymbol) &#123; var map = new Map(&quot;mapDiv&quot;); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer1); on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e)&#123; // 定义数据源，设置命名空间，设置命名空间下面的shp var dataSource = new TableDataSource(); dataSource.workspaceId = &quot;demo&quot;; dataSource.dataSourceName = &quot;demoShp.shp&quot;; // 定义图层数据源，对其赋值 var layerSource = new LayerDataSource(); layerSource.dataSource = dataSource; //定义一个要素图层:动态图层 var layer2 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/dynamicLayer&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource &#125;); //定义线符号，渲染器 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var renderer = new esri.renderer.SimpleRenderer(lineSymbol); //给要素图层设置渲染器 layer2.setRenderer(renderer); layer2.refresh(); //把要素图层添加到map上 map.addLayer(layer2); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;height:600px;&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;添加动态图层&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"加载---动态 / 切片地图加载","date":"2021-07-22T09:54:49.033Z","path":"2021/07/22/加载---动态 _ 切片地图加载/","text":"先来看看效果图这是北京市的2000年的土地资源主题地图 页面按加载完成之后，地图可以放大缩小，平移。所有的放大缩小平移都是一起的，显而易见这是一个图层。可以在esri官方查找ArcJS的APIArcGIS API for JavaScript 3.29 进入主题1. 先来看一下一般的html代码框架12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require( , function () &#123;&#125; ); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; style=&quot;height:800px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其中不同的几行：1234567891011&lt;!-- 引入map相关的引用css，可以通过https://js.arcgis.com或者部署本地js --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt;&lt;!-- 引入map相关的引用js --&gt;&lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt;&lt;!-- 实际的js操作代码 --&gt;&lt;!-- require中一般为2/2及以上的function、on等参数 --&gt;&lt;!-- 第一个参数为地图操作中的相关模块引用 --&gt;&lt;!-- 在本案例中，该函数为记载函数 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; require( , function () &#123;&#125; );&lt;/script&gt; 2. 引用模块记载地图的引用基本模块：例如加载Arcgis官方的自带底图 12require([&quot;esri/map&quot;, &quot;dojo/domReady!&quot;] , function () &#123;&#125; ); 本例中，通过引用ArcSer的REST URL加载地图。需要引用动态图层模块：&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;引用以&quot;dojo/domReady!&quot;结尾，基于dojo 123require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;] , function () &#123;&#125; ); 3. 操作函数分为三步： 给div定义一个map容器 定义一个图层Layer 把Layer加载到map容器里 123456789// function中的参数顺序必须和引用的模块顺序一样，否则会出现未定义的ERRORfunction (Map, ArcGISDynamicMapServiceLayer) &#123; // div的id为mapDiv var map = new Map(&quot;mapDiv&quot;); // 引用ArcSer的REST URL var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); // 引用map的addLayer方法加载动态图层 map.addLayer(layer1);&#125; 完整代码12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer) &#123; var map = new Map(&quot;mapDiv&quot;,&#123; logo:false &#125;); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer1); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; style=&quot;height:800px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 切片地图将代码中的所有ArcGISDynamicMapServiceLayer改为ArcGISTiledMapServiceLayer多加尝试，万事开头难，后面就会容易些了，学习中的bug可以在放在评论区一起讨论欢迎指出文章中的错误","tags":[]},{"title":"计算机地图制图 知识总结","date":"2021-07-22T09:54:49.031Z","path":"2021/07/22/计算机地图制图 知识总结/","text":"计算机地图制图第一章1. 计算机制图的概念 P1 数字地图，电子地图的概念（PPT），区分，名词解释 计算机地图制图（数字地图制图）：以传统的地图制图原理为基础，以计算机及其外围设备为工具，采用数据库技术和图形数据处理方法，实现地图信息的采集、存储、处理、显示和绘图的应用科学。实质: 从图形（连续）转换为数字（离散），经过一定处理，再由数字转换为图形的过程。 数字地图：一定坐标系内，空间数据 + 属性标志的离散数据，以数字形式存储的数据 。 电子地图：利用计算机技术，以数字方式存储和查阅的地图，数字地图在屏幕上显示的地图。 模拟地图（传统地图）：电子地图在一定比例尺下出图，打印成纸质地图。 2. 计算机制图的优点 P2 易于编辑更新，交互性强 允许同样的数据进行不同图形表示的实验 提高绘图速度和精度 便宜、自动化的引入导致整个生产过程工时节省和技术革新 易于存储，容量大，降低了成本 改变了仅以印刷地图作为空间数据存储介质的现状，增大了载负量，因而减少了数据压缩分类和数据综合对质量的影响） 丰富了地图品种 能生产特殊用户需要的地图，能生产手工方法难以生产的地图，如三维地图，立体地图等 便于信息共享 大量无损失复制，可通过网络进行传播 3. 计算机制图的构成 P6 硬件 - 各种设备-物质基础 输入设备：键盘、鼠标、数字化仪（跟踪式、扫描式）扫描仪 输出设备：图形显示终端、打印机、绘图仪 设 备 图形输出方式 精度 特 点 矢量绘图机 矢量线划 高 绘制线划图；进行刻图等 喷墨打印机 网格点阵 高 彩色地图和影像地图 高分辨率彩显 屏幕像元点阵 一般 实时显示GIS的各种图形、图像产品 行式打印机 字符点阵 差 以打印字符输出各类地图。 胶片拷贝机 光栅 较高 将屏幕图形复制至胶片，用于制作幻灯片和正胶片。 软件 - 支持数据采集、存储、加工、回答用户问题的计算机程序系统 计算机系统软件 计算机制图数据库软件 计算机地图制图应用软件 制图数据 - 系统分析与处理的对象、构成系统的应用基础 地理要素空间数据 地理要素属性数据 地理要素空间关系 地图符号库 地图注记 元数据 制图人员 - GIS服务的对象，分为一般用户和从事建立、维护、管理和更新的高级用户 4. 计算机制图的基本过程 P13 简答 数据获取 二 –》1 数据处理 预处理 投影变换 图形处理 制图综合 符号化 数据输出 普通地图 专题地图 统计图表 5. 计算机制图与地理信息系统（CAD）之间的区别联系 P18 （################必考） 与GIS 都是基于空间数据库的空间信息的表达、显示和处理。 计算机地图制图是地理信息系统的一部分； GIS是计算机地图制图之上的超结构。 名称 制图 GIS 模型 位置＋符号 位置＋符号＋属性 数据管理 地图数据库 空间数据库、关系数据库 应用 输出地图 输出地图，提供空间对象供用户使用，查询检索和分析决策 CAD CAD和GIS都有坐标参考系统，CAD的是相对坐标，没有空间意义，不能空间分析。地图制图是对空间数据的处理，是有坐标的。 计算机辅助制图多为规则的几何图形或组合，图形及其关系更复杂，空间数据和属性数据的相互操作频繁，空间数据的处理和符号化功能较强，属性功能相对较弱； CAD是平面设计软件，建筑行业频繁使用的软件。 第二章 数据采集1. 数字地图的数据源有哪些？怎么获取？地图数据 ，遥感数据， 文本数据，统计数据 实测数据，多媒体数据，已有地图数据库… 几何数据采集： 已有数字数据：转换后输入数据库 外野测量获取的几何数据：预处理（平板测量、全野外数字测图、空间定位测量）后导入地图数据库 遥感影像数据：预处理（几何纠正、图像变换、影响分类、特征提取） 纸质地图：地图数字化（手扶跟踪数字化、扫描矢量化） 摄影测量方法：摄影测量包括航空摄影测量和地面摄影测量 属性数据采集： 键盘，人机对话 程序批量输入 2. GIS里面矢量、栅格数据， 名词解释 矢量数据结构和栅格数据结构是两种地图空间数据结构。 矢量数据结构：通过记录坐标的方式尽可能精确地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。特点：定位明显，属性隐含 栅格数据结构：将地表划分成为紧密相邻的网格阵列。每个网格的位置由行列号定义，并包含一个代码，以表示该网格的属性。特点：属性明显，定位隐含 通过记录坐标的方式尽可能精确地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。特点：定位明显，属性隐含 如何选择？ 栅格结构：利于叠加分析。大范围小比例尺的自然资源、环境、农林业等区域问题的研究。 矢量结构：表达事物比较精细。城市分区或详细规划、土地管理、公用事业管理等方面的应用。 3. 数据质量数据的质量包括五个方面： 位置（几何）精度：如数学基础、平面精度、高程精度等，用以描述几何数据的误差。 属性精度：如要素分类的正确性、属性编码的正确性、注记的正确性等，用以反映属性数据的质量。 完备性：如数据分类的完备性、实体类型的完备性、属性数据的完备性、注记的完整性，数据层完整性，检验完整性等。 现势性：如数据的采集时间、数据的更新时间等。 逻辑一致性：如多边形的闭合精度、结点匹配精度、拓扑关系的正确性等，由几何或属性误差也会引起逻辑误差。 质量的控制： 误差带法：该方法适用于任何类型的GIS数据，关键是如何给出合理的ε值。 对比法：把数字化后的数据，用绘图机绘出，与原图叠合，选择明显地物点进行量测，以确定误差。 相关法：依据地图要素自身的相关性来分析数据的质量。如河流与等高线的套合程度。 第五章 P1031. 数据预处理坐标变换，数据压缩，数据匹配 坐标变换 几何纠正 投影变换 数据压缩 主要对象：现状要素中心轴线和面状要素边界数据 间隔取点法 垂距法 偏角法 道格拉斯普克法 光栏法 数据匹配：实现误差纠正。 顶点匹配 数字接边 2. 坐标变换 几何纠正#####P105 性质，什么情况使用哪个，有多少个未知数，道理是啥。 高次变换：12个未知数，需要6对以上控制点坐标 二次变换：10个未知数，需要5对以上控制点坐标。适用于原图有非线性变形 一次变换：6个未知数，需要不在一条直线上的3对以上控制点坐标。由于误差，需要多观测一组。一共需要四对控制点坐标 同素变换： 仿射变换：只考虑x方向和y反向上的变形。（经过对坐标的缩放，旋转，平移后原坐标在新坐标域中的值） 仿射变换 = 线性变化 + 平移 3. 投影变换（转换的思想） 解析变换：找出两投影间坐标变换的解析计算公式 正解变换：将具有经纬度的地理坐标转换为直角坐标系下的坐标 反解变换：将具有直角坐标系下的坐标转换为经纬度 数值变换：在不易求出两投影坐标之间的直接关系，采用多项式逼近建立变公式。20个未知数，10个控制点坐标 数值解析变换：已知新的投影公式，但不知道原投影公式，可选择通过数值变化法求出原投影点的地理坐标，然后代入新投影公式中，求出新投影点的坐标。 4. 数据压缩（论述）压缩条件： 保持曲线的形状特征 保持密度对比 保持转折点的精度 保持空间关系正确 道格拉斯普克法：（画图，思路）对给定曲线的首末点虚连一条直线，求中间所有点与直线间的距离，并找出最大距离dmax，用dmax与限差 L比较。dmax ≥L，保留对应点，以该点为界将曲线分为两段，对每一段重复使用该方法。dmax&lt;L，舍去所有中间点。 光栏法：（画图，思路，简单说）定义一个扇形区域，通过判断曲线上的点在扇形外还是在扇形内，确定保留还是舍去。 5. 图形编辑P110 地图开窗：按照用户指定的空间范围，进行图形子集的选取。这个指定的范围被称为窗口 正开窗：选取整个图形数据在窗口内的子集合 负开窗：选取整个图形数据在窗口外的子集合 点的选取：计算C和P之间的距离是否小于限差 线的选取：通过计算光标点C到该线的每条线段的距离d，与搜索半径D比较。如果d&lt;D，则认为找到；反之则未成功。 面的选取：铅垂线法：从待判别点引铅垂线，由该铅垂线（注意：是一条射线）与多边形交点个数的奇偶性来判断点是否在多边形内。 步骤： 第一步，计算多边形最小投影矩形，若点在最小投影矩形外，则点一定在多边形外，算法结束；否则执行第二步。 第二步，设置记录交点个数的计数器Num=0。 第三步，从待判断的点作铅垂线，顺次判断该铅垂线与多边形各边是否相交，若相交，求出交点并记录下来。每有一次相交，把Num数值增加1。 第四步，若Num为偶数，则该点在多边形外；否则，该点在多边形内。算法结束。 异常情况： 交点位于多边形顶点：若在同侧，Num不变，否则Num加1。 铅垂线与多边形的一条边重合：若在同侧，Num不变，否则Num加1。 6. 几何变换 P114 变换矩阵：平移变换，比值变换，对称变换，旋转变换，错切，符合，，，，，理解 1.平移变换 2.旋转变换 3.比例变换：分别给定X轴和Y轴上的两个比例系数 以上几种基本变换的处理形式不统一，如何解决？齐次坐标 二维点（x,y）的齐次坐标表示为（hx,hy,h），那么变换h，都表示二维空间中同一个点的齐次坐标。（12,8,4） (6,4,2) (3,2,1) 均表示（3,2）这一点的齐次坐标。 平移变化：只改变图形的位置，不改变图形的大小和形状 比例变换： 以坐标原点为放缩参照点。 当Sx=Sy=1时：恒等比例变换。 当Sx=Sy&gt;1时：沿x,y方向等比例放大。 当Sx=Sy&lt;1时：沿x,y方向等比例缩小。 当SxSy时：沿x,y方向作非均匀的比例变换，图形变形。 当Sx=1，Sy=－1，关于X轴的对称变换。 当Sx=－1，Sy=1时，为关于Y轴的对称变换。 当Sx=Sy=－1，为关于坐标原点的对称变换。 对称变换： 当d=b=0,a=-1,e=1时，(x* y* 1)=(-x y 1)：与y轴对称的反射变换。 当d=b=0,a=1,e=-1时，(x* y* 1)=( x -y 1)：与x轴对称的反射变换。 当d=b=0,a=e=-1时，(x* y* 1)=(-x -y 1)：与原点对称的反射变换。 当d=b=1,a=e=0时，(x* y* 1)=(y x 1)：与y=x对称的反射变换。 当d=b=-1,a=e=0时，(x* y* 1)=(-y -x 1)：与y=-x对称的反射变换 旋转变换： 错切变换：错切变换引起图形角度关系的改变，甚至导致图形发生变形 当b=0时， (x* y* 1)=(x+by y 1)：图形的y坐标不变； 当d&gt;0：图形沿+x方向作错切位移。ABCD→A1B1C1D1 当d&lt;0：图形沿-x方向作错切位移。ABCD→ A2B2C2D2 复合变换：指在XY平面内，对一个已定义的图形，按一定顺序进行多次变换而得到新的图形，也即对图形做一次以上的几何变换。注意：任何一个线性变换都可以分解为上述几类变换。 ​ 7. 矢量数据向栅格数据转换 P123（简答） 简答 点线面。。。点和线的一样的。答点和面。。。。 矢量转栅格： 栅格数据分辨率和栅格数的确定 点的栅格化 线的栅格化：八方向栅格化、分带法、恒密度栅格化 面的栅格化：内部点扩散法、射线算法、扫描算法边界代数算法 第六章 栅格数据的处理1. 栅格图像平移 P128（看懂）平移、算术运算、逻辑运算、宏运算 看懂 灰度级变换：对每一像素的灰度级进行变换，扩大图像灰度的范围，达到图像增强的目的。 平移：原始的栅格影像按照一定的方向平移确定的像元数目。 算术组合：两个栅格图像相互叠置，对应的像元灰度值相加、相减、相乘等 逻辑组合：对应的像元灰度进行逻辑运算，或，与，非，异或 宏运算 扩张：向指定的方向和给定的像元数据进行扩张，平移同时做或运算 例：向右平移一个像元 侵蚀：向侵蚀方向移动确定的像元格 加粗：分为四方向和八方向 减细：加粗的逆运算 填充 逐步蔓延加粗法：让单个像元作为填充胚，在给定的区域范围内，通过某种方法进行蔓延，最终填充满整个多边形区域。四邻法、八邻法 逐行填充法：对种子所在的行进行填充，在每次填充一行后，应搜索该行的上下两侧以确定新的种子，对于相互连通的一侧，只需一个种子，并将其放入栈中。 2. 栅格数据向矢量数据转换的算法 P139 算法 栅格转矢量： 点的矢量化： 线的矢量化：实质：将具有相同属性值的连续的单元格搜索出来，最后得到细化的一条线。两种算法思想：细化矢量化和非细化矢量化 多边形的矢量化：实质：将具有同一属性的单元归为一类，再检测两类不同属性的边界作为多边形的便，最终提取以栅格集合表示的区域边界和边界的拓扑关系。 一般过程：栅格数据的二值化、多边形边界提取和细化、多边界跟踪、去除多余及曲线光滑、矢量数据转换的过程 二值化。栅格数据是按0～255的不同灰度值表达的。为了简化追踪算法，将256个灰阶压缩为2个灰阶，即0和1两级。 边界细化。使每一条线只保留代表其轴线或周围轮廓线（对多边形而言）位置的单个栅格的宽度。 边界跟踪。把细化后的栅格数据整理为从结点出发的线段或闭合的线条，并以矢量形式加以存储。 曲线化简及光滑 。直接提取的边界线节点密集、有明显的抖动锯齿感，需进行化简及光滑处理。 生成拓扑关系，建立节点、弧段及多边形间的连接关系。 第七章 地图符号1. 地图符号和地图符号化的概念地图符号：地图的主要表达形式，它是地图区别于其他表示地理环境方法的一个重要特征。地图符号不仅能反映地图要素的存在、类别及其数量和质量特征，而且通过他们的组合，还能反映出地理要素的空间分布、结构、联系以及变化等。 地图符号化：地图数据的符号化，两层含义： 在地图设计工作中，指利用符号将地图数据进行分类、分级、概括、抽象的过程； 在数字地图转换为模拟地图的过程中，指将已处理好的矢量地图数据恢复成可见的图形，并附之以不同符号表示的过程。 编程法 信息法 直接信息法：直接表示符号图形的各个细部，在信息块中直接存储符号图形的矢量数据或栅格数据 间接信息法：信息块中不直接存储符号图形数据，而只存储符号图形的几何参数 2. 符号绘制 P214 没找到 3. 地图符号库采用的算法矢量符号库：信息块法，程序块法，综合法 栅格符号库：信息块法 信息块法：用人工或程序将要绘制的符号里三成坐标信息，用统一的结构和方法进行描述，这些描述信息存放在数据文件中形成符号库。 程序块法：对每一类地图符号编写一个绘图子程序，由这些子程序组成符号库。绘图时按照符号的编号调用库中相应的程序，输入相应参数，由程序根据参数及已知数据计算矢量，从而完成地图符号的绘制。 综合法：其实质是把信息块法和程序法结合在一起，绘制组合式符号。 4. 点符号的生成算法 P215 点状符号信息块法 程序块法 任何圆都可以用正多边形来逼近，边数越多，圆越光滑。 以圆弧的起始点坐标，圆弧的起始角、圆弧的终止角、圆弧的起始点半径和终止点半径为参数设计绘圆程序，这个程序就既能绘制圆也能绘制圆弧和螺线。 以椭圆的起始点坐标、长半轴、短半轴、长半轴与 x 轴的夹角、起始点和终止点到中心点连线分别于x轴的夹角为参数来设计绘制椭圆的程序，这个程序就能绘制椭圆，也能绘制椭圆弧并调整椭圆长轴的方向。 5. 线符号的生成算法，线状符号信息块法、土堤符号绘制原理 P219 信息块法：把各类线状符号看作是由符号单元沿线状要素中轴线重复串接而成。 程序块法： 解决两个问题： 确定每一条短横线的位置，确定横短线与中轴线的交点坐标 确定横短线两端点的坐标 6. 面符号。。。。。信息块法 信息块法：存储的是填充符号的单元信息，结构类似线状符号中线—线信息块，但需要增加三种信息：行距、行向倾角（晕线与x轴夹角）、排列方式（“井”型、交错和散列）。 程序法： 填充点状符号算法 填充线状符号算法 算法总体思路:计算所填绘的每条线符与多边形的交点，然后调绘线符绘制程序在两交点间绘制出所要求的线符即可。 第八章 数字表面模型1. DEM和数字地面模型（DTM）的区别数字正射影像(DOM) 数字地面模型(DTM)，是要素的平面坐标(x，y)和其他物性质的数据集合。如果此属性是高程z，则此数字地面模型又称为数字高程模型(DEM)。 DEM是建立DTM的基础数据。 实际上地形模型不仅包含高程属性，还包含其它的地表形态属性，如坡度、坡向等。 DEM和DTM主要用于描述地面起伏状况，可以用于提取各种地形参数，如坡度、坡向、粗糙度等，并进行通视分析、流域结构生成等应用分析。 DEM在各个领域中被广泛使用。 DEM可以有多种表达方法，包括网格、等高线、三角网等。 2. Delaunay三角网、泰森多边形的概念，关系。 定义： 不规则三角网（TIN）：由一系列相连的但不重叠的三角形的集合, 而且这些三角形的外接圆不包含这个面域的其他任何点。存储表达：对于每一个三角形、边和节点都对应一个记录。 Delaunay三角网：表示数字高程模型的方法，它既减少规则格网方法带来的数据冗余，同时在计算（如坡度）效率方面又优于纯粹基于等高线的方法。 泰森多边形—冯洛诺伊图（Voronoi diagram）：指用不规则的小面块来逼近和模拟自然界不规则地理单元的一种方法。对Delaunay三角网的各个边做中垂线，中垂线上的顶点相连就构成了泰森多边形。 关系：Voronoi图（泰森多边形） 和 Delaunay三角形 互为对偶图 3. 三角网的特点，性质。 Delaunay三角网特性：1）其Delaunay三角网是唯一的；2）三角网的外边界构成了点集P的凸多边形“外壳”；3）没有任何点在三角形的外接圆内部，反之，如果一个三角网满足此条件，那么它就是Delaunay三角网。4）如果将三角网中的每个三角形的最小角进行升序排列，则Delaunay三角网的排列得到的数值最大，从这个意义上讲，Delaunay三角网是“最接近于规则化”的三角网。 Delaunay三角形性质（基本准则）： 外接圆准则：任何一个Delaunay三角形的外接圆的内部不能包含其它任何点。 最大化最小角原则：每两个相邻的三角形构成的凸四边形的对角线，在相互交换后，六个内角的最小角不再增大。 局部优化准则：先求出包含新插入点p的外接圆的三角形，这种三角形称为影响三角形。删除影响三角形的公共边，将p与全部影响三角形的顶点连接，完成p点在原Delaunay三角形中的插入。 4. 泰森的应用范围，应用场景，多边形特征 泰森多边形应用范围： 泰森多边形可用于定性分析、统计分析、邻近分析等。 例如，可以用离散点的性质来描述泰森多边形区域的性质；可用离散点的数据来计算泰森多边形区域的数据；判断一个离散点与其它哪些离散点相邻时，可根据泰森多边形直接得出，且若泰森多边形是n边形，则就与n个离散点相邻；当某一数据点落入某一泰森多边形中时，它与相应的离散点最邻近，无需计算距离。 泰森多边形特点 多边形的边总垂直平分两个邻接采样点的连线 多边形内任何位置总是离该多边形内样点的距离最近，离相邻多边形内样点最远 每个多边形内只有一个点 泰森多边形内部的顶点必有3条边同它连接，这些边相邻的3个三多边形的两两拼接的公共边 泰森多边形内部的顶点周围有3个离散数据点，将其连成三角形后，该三角形的外接圆心即为该顶点 3. 如何用点集生成TIN不规则点集生成TIN 凸包生成 环切边界法凸包三角剖分 离散点内插(局部优化准则) 4. 格网DEM转成TIN（规则分布的采样点生成TIN）目的是尽量减少TIN的顶点数目，同时尽可能多地保留地形信息，如山峰、山脊、谷底和坡度突变处。 保留重要点法 启发丢弃法 1）可以将格网DEM作为输入，此时所有格网点视为TIN的节点，将格网中4个节点中的两个对角点相连，将每个格网剖分成两个三角形。2）取TIN的一个节点O及与其相邻的其它节点，如图9-9所示，O的邻点（称Delaunay邻接点）为A，B，C，D, E，使用Delaunay三角构造算法，将O的邻点进行Delaunay三角形重构，图中实线所示。 3）判断该节点O位于哪个新生成的Delaunay三角形中，如图为三角形BCE。计算O点的高程和过O点与三角形BCE交点O’的高程差d。若高程差d大于阈值de，则O点为重要点，保留，否则，可删除。de为阈值。4）对TIN中所有的节点，重复进行上述判断过程。5）直到TIN中所有的节点满足条件d&gt;de，结束。 等高线转成格网DEM 4. 蒂洛尼三角网–空壳 (PPT) 第三、四章 地图的设计和制作1. 色彩 P83 设色的要求P87 地图的色彩应与地图的性质、用途相协调 地图的色彩应层次分明突出重点内容 充分利用色彩的感觉和象征性 地图色彩应系统协调突出特色 色彩在地图的应用 P88-P102 论述题 地图色彩的类别 点状色彩 线状色彩 注记色彩 面状色彩（质别底色、区域底色、色级底色、衬托底色） 地图设计中的色彩设计 点状符号的色彩设计 线状符号的色彩设计 面状符号的色彩设计： 根据性质选用色值 同类元素应在同一色系中选色 面状色之间协调选色 面状色应选用柔和的色值 色彩对比的应用 色彩明度对比的应用： 明度对比与图面的清晰感 明度对比与地图的层次感 明度对比与图面的节奏感 明度对比与图面的空间感 明度对比与图面的多样统一美 色相对比的应用 纯度对比的应用 地图层次设计中色彩对比手法的综合运用： 冷暖对比 纯度对比 明度对比 地图色彩在地图制作中如何运用和设计的？ 分区用多色相，避免用原色 运用色彩视觉心理特性 色彩过渡自然 注意等值线的色彩 色彩的作用 色彩的运用简化了图形符号系统 丰富了地图内容，提高了地图传递空间信息的容量 提高地图内容表现的科学性 改善地图语言的视觉效果 提高地图的审美价值 2. 地图符号，注记 （论述）地图符号设计，注记进行页面布局 P204点状，线，面的设计。。。 点状符号系统的设计：主要差异：类别和层次。对应下面 横向对比：不同类型的地图要素符号系统之间的形态差异，内容简单的地图，无论具象符号还是抽象符号的形态设计，均能比较容易的表现出要素的差异。 纵向对比： 属于不同要素之间或同一要素内部的层次差异，适用于内部尺寸、结构、虚实、明度等对比要素来反映。 面状符号的对比设计： 横向对比设计：以纹样对比为主，只要能表达出地图内容，原则上网纹越简单越好。 注记 P236 主要是P236的地图注记设计 论述题 地图设计三大块，总结，注意什么 制图过程是什么样的，怎运用书上的理论，怎么改进。","tags":[]},{"title":"几何处理-绘图（点，多点，线，箭头线，面，徒手线，徒手面，圆，矩形）","date":"2021-07-22T09:54:49.029Z","path":"2021/07/22/几何处理-绘图（点，多点，线，箭头线，面，徒手线，徒手面，圆，矩形）/","text":"效果图几何处理结合api，每一种几乎改动不大。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;template&gt; &lt;div id=&quot;home&quot;&gt; &lt;!--面包屑导航区域--&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;Map&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;Geometry&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; &lt;el-row style=&quot;position: absolute; top: 100px; left: 300px; width: 1200px;&quot;&gt; &lt;el-button plain&gt;简单点&lt;/el-button&gt; &lt;el-button plain&gt;图片点&lt;/el-button&gt; &lt;el-button plain&gt;基本线&lt;/el-button&gt; &lt;el-button plain&gt;箭头线&lt;/el-button&gt; &lt;el-button plain&gt;面样式1&lt;/el-button&gt; &lt;el-button plain&gt;面样式2&lt;/el-button&gt; &lt;el-button plain&gt;绘制多点&lt;/el-button&gt; &lt;el-button plain&gt;自由线&lt;/el-button&gt; &lt;el-button plain&gt;自由面&lt;/el-button&gt; &lt;el-button plain&gt;圆&lt;/el-button&gt; &lt;el-button plain&gt;矩形&lt;/el-button&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as esriLoader from &#x27;esri-loader&#x27;export default &#123; data() &#123; return &#123;&#125; &#125;, mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.31&#x27; &#125;) this.createMap() &#125;, methods: &#123; createMap: function () &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;dojo/dom&#x27;, &#x27;dojo/on&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;esri/geometry/Point&#x27;, &#x27;esri/geometry/Polyline&#x27;, &#x27;esri/graphic&#x27;, &#x27;esri/Color&#x27;, &#x27;esri/symbols/SimpleMarkerSymbol&#x27;, &#x27;esri/symbols/SimpleLineSymbol&#x27;, &#x27;esri/symbols/SimpleFillSymbol&#x27;, &#x27;esri/symbols/PictureMarkerSymbol&#x27;, &#x27;esri/renderers/SimpleRenderer&#x27;, &#x27;dojo/query&#x27;, &#x27;esri/toolbars/draw&#x27;, &#x27;esri/SpatialReference&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, dom, on, ArcGISDynamicMapServiceLayer, Point, Polyline, Graphic, Color, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, PictureMarkerSymbol, SimpleRenderer, query, Draw, SpatialReferenc]) =&gt; &#123; var map = new Map(&#x27;map&#x27;, &#123; center: [108.934518, 34.35333], zoom: 7, logo: false, basemap: &#x27;oceans&#x27; &#125;) map.on(&#x27;load&#x27;, () =&gt; &#123; var toolbar = new Draw(map, &#123; showTooltips: true &#125;) var smpPoint = true var smpLine = true var smpPloy = true query(&#x27;button&#x27;).on(&#x27;click&#x27;, function (event) &#123; var value = this.innerHTML console.log(value) value = value.replace(new RegExp(&#x27;^\\\\&#x27; + &#x27;&lt;!----&gt;&lt;!----&gt;&lt;span&gt;&#x27; + &#x27;+&#x27;, &#x27;g&#x27;), &#x27;&#x27;) value = value.replace(new RegExp(&#x27;\\\\&#x27; + &#x27;&lt;/span&gt;&#x27; + &#x27;+$&#x27;, &#x27;g&#x27;), &#x27;&#x27;) console.log(value) switch (value) &#123; case &#x27;简单点&#x27;: &#123; toolbar.activate(Draw.POINT, &#123; showTooltips: true &#125;) smpPoint = true break &#125; case &#x27;图片点&#x27;: &#123; toolbar.activate(Draw.POINT, &#123; showTooltips: true &#125;) smpPoint = false break &#125; case &#x27;基本线&#x27;: &#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips: true &#125;) smpLine = true break &#125; case &#x27;箭头线&#x27;: &#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips: true &#125;) smpLine = false break &#125; case &#x27;面样式1&#x27;: &#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips: true &#125;) smpPloy = true break &#125; case &#x27;面样式2&#x27;: &#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips: true &#125;) smpPloy = false break &#125; case &#x27;绘制多点&#x27;: &#123; toolbar.activate(Draw.MULTI_POINT, &#123; showTooltips: true &#125;) break &#125; case &#x27;自由线&#x27;: &#123; toolbar.activate(Draw.FREEHAND_POLYLINE, &#123; showTooltips: true &#125;) break &#125; case &#x27;自由面&#x27;: &#123; toolbar.activate(Draw.FREEHAND_POLYGON, &#123; showTooltips: true &#125;) break &#125; case &#x27;圆&#x27;: &#123; toolbar.activate(Draw.CIRCLE, &#123; showTooltips: true &#125;) break &#125; case &#x27;矩形&#x27;: &#123; toolbar.activate(Draw.RECTANGLE, &#123; showTooltips: true &#125;) break &#125; &#125; // var markerSym = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 12, // new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, // new Color([87, 181, 74]), 1), // new Color([255, 0, 0, 0.5])) var lineSymbol1 = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([0, 25, 0]), 1) var lineSymbol2 = new SimpleLineSymbol(SimpleLineSymbol.STYLE_LONGDASHDOT, new Color([225, 0, 0]), 1) var outLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOTDOT, new Color([235, 235, 5]), 3) var marker = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 10, lineSymbol1, new Color([215, 224, 203])) var fill1 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, outLineSymbol, new Color([48, 190, 144, 0.5])) var fill2 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_DIAGONAL_CROSS, lineSymbol1, new Color([48, 190, 144])) var pictureMarkerSymbol = new PictureMarkerSymbol(&#x27;https://gtms04.alicdn.com/tps/i4/TB1_oz6GVXXXXaFXpXXJDFnIXXX-64-64.ico&#x27;, 20, 20) lineSymbol2.setMarker(&#123; style: &#x27;arrow&#x27;, placement: &#x27;end&#x27; &#125;) on(toolbar, &#x27;draw-complete&#x27;, function (result) &#123; var geometry = result.geometry var type = geometry.type var graphic switch (type) &#123; case &#x27;point&#x27;: if (smpPoint) graphic = new Graphic(geometry, marker) else graphic = new Graphic(geometry, pictureMarkerSymbol) break case &#x27;polyline&#x27;: if (smpLine) graphic = new Graphic(geometry, lineSymbol1) else graphic = new Graphic(geometry, lineSymbol2) break case &#x27;polygon&#x27;: if (smpPloy) graphic = new Graphic(geometry, fill1) else graphic = new Graphic(geometry, fill2) break case &#x27;multipoint&#x27;: graphic = new Graphic(geometry, marker) break &#125; console.log(map.graphics.renderer) map.graphics.add(graphic) toolbar.deactivate() &#125;) &#125;) &#125;) &#125;) &#125; &#125;&#125;&lt;/script&gt;","tags":[]},{"title":"基础功能---具体坐标生成Graphic","date":"2021-07-22T09:54:49.026Z","path":"2021/07/22/基础功能---具体坐标生成Graphic/","text":"1.图层分析共两层 底图（动态图层） 客户端图层（添加指定坐标的点线面） 2. 步骤 通过switch选择定义对应的geometry 根据坐标创建Graphic graphic=new Graphic(geometry, xxx ); 把图形加载到图层中 graphicsLayer.add(graphic);3.贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Graphic&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/GraphicsLayer&quot;, &quot;dojo/on&quot;,&quot;dojo/query&quot;,&quot;dojo/colors&quot;, &quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/geometry/Point&quot;, &quot;esri/geometry/Polyline&quot;,&quot;esri/geometry/Polygon&quot;, &quot;esri/geometry/Circle&quot;, &quot;dojo/domReady!&quot;], function(Map,ArcGISDynamicMapServiceLayer, GraphicsLayer,on,query,Color,Graphic, SimpleMarkerSymbol,SimpleLineSymbol, SimpleFillSymbol,Point,Polyline,Polygon,Circle)&#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建客户端图层 var graphicsLayer=new GraphicsLayer(); //将客户端图层添加到地图中 map.addLayer(graphicsLayer); //通过query查询到button对象 var btns=query(&quot;button&quot;); on(btns,&quot;click&quot;,function(event)&#123; var text=this.innerHTML; //定义符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); var fill=SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0])); //声明类型和图形 var geometry; var graphic; //根据文本定义相应的geometry switch(text) &#123; case &quot;添加点&quot;: geometry=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,pSymbol); break; case &quot;添加线&quot;: //点的坐标对 var paths=[]; paths[0]=[ [510326,3985702], [510994, 3985676], [511078, 3985903], [510433, 3985928] ]; geometry=new Polyline(&#123; &quot;paths&quot;:paths, &quot;spatialReference&quot;:map.spatialReference &#125;) graphic=new Graphic(geometry,lineSymbol); break; case &quot;添加面&quot;: //点的坐标对 var ring=[]; ring[0]=[ [510275, 3986100], [510508, 3986162], [510596, 3986032], [510271, 3985847], [510275, 3986100] ]; geometry=new Polygon(&#123; &quot;rings&quot;:ring, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,fill); break; case &quot;添加圆&quot;: //圆心 var p=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference &#125;); //半径 var r=20; geometry=new Circle(p,&#123; &quot;radius&quot;:r &#125;); graphic=new Graphic(geometry,fill); break; &#125; //将图形添加到图层中 graphicsLayer.add(graphic); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;添加点&lt;/button&gt; &lt;button&gt;添加线&lt;/button&gt; &lt;button&gt;添加面&lt;/button&gt; &lt;button&gt;添加圆&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"基础功能---交互画图2","date":"2021-07-22T09:54:49.024Z","path":"2021/07/22/基础功能---交互画图2/","text":"基础画图1效果图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.31/dijit/themes/claro/claro.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.31/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.31/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;&gt; &lt;style&gt; /* 指定样式 */ html, body, #map &#123; height: 100%; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;claro&quot;&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; &lt;div style=&quot;position: absolute; top: 60px; left: 100px; width: 800px;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;简单点&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;图片点&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;基本线&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;箭头线&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;面样式1&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;面样式2&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;绘制多点&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;自由线&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;自由面&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;圆&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;矩形&lt;/button&gt; &lt;/div&gt; &lt;script&gt; require([ &quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/geometry/Point&quot;, &quot;esri/geometry/Polyline&quot;, &quot;esri/graphic&quot;, &quot;esri/Color&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/symbols/PictureMarkerSymbol&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;dojo/query&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/SpatialReference&quot;, &quot;dojo/domReady!&quot; ], function ( Map, dom, on, ArcGISDynamicMapServiceLayer, Point, Polyline, Graphic, Color, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, PictureMarkerSymbol, SimpleRenderer, query, Draw, SpatialReference ) &#123; const map = new Map(&quot;map&quot;, &#123; center: [108.934518, 34.35333], zoom: 7, logo: false, basemap: &quot;oceans&quot; &#125;); var markerSym = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_SQUARE, 12, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new Color([87, 181, 74]), 1), new Color([255, 0, 0, 0.5]));; map.on(&quot;load&quot;, () =&gt; &#123; var toolbar = new Draw(map, &#123; showTooltips: true &#125;); // 标记 基本和自定义样式 var smpPoint = true; var smpLine = true; var smpPloy = true; query(&quot;button&quot;).on(&quot;click&quot;, function (event) &#123; var value = this.innerHTML; switch (value) &#123; case &quot;简单点&quot;: &#123; toolbar.activate(Draw.POINT, &#123; showTooltips: true &#125;) smpPoint = true; break; &#125; case &quot;图片点&quot;: &#123; toolbar.activate(Draw.POINT, &#123; showTooltips: true &#125;) smpPoint = false; break; &#125; case &quot;基本线&quot;: &#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips: true &#125;) smpLine = true; break; &#125; case &quot;箭头线&quot;: &#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips: true &#125;) smpLine = false; break; &#125; case &quot;面样式1&quot;: &#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips: true &#125;) smpPloy = true break; &#125; case &quot;面样式2&quot;: &#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips: true &#125;) smpPloy = false break; &#125; case &quot;绘制多点&quot;: &#123; toolbar.activate(Draw.MULTI_POINT, &#123; showTooltips: true &#125;) break; &#125; case &quot;自由线&quot;: &#123; toolbar.activate(Draw.FREEHAND_POLYLINE, &#123; showTooltips: true &#125;) break; &#125; case &quot;自由面&quot;: &#123; toolbar.activate(Draw.FREEHAND_POLYGON, &#123; showTooltips: true &#125;) break; &#125; case &quot;圆&quot;: &#123; toolbar.activate(Draw.CIRCLE, &#123; showTooltips: true &#125;) break; &#125; case &quot;矩形&quot;: &#123; toolbar.activate(Draw.RECTANGLE, &#123; showTooltips: true &#125;) break; &#125; &#125; var lineSymbol1 = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([0, 25, 0]), 1); var lineSymbol2 = new SimpleLineSymbol(SimpleLineSymbol.STYLE_LONGDASHDOT, new Color([225, 0, 0]), 1); var outLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOTDOT, new Color([235, 235, 5]), 3); var outLineSymbol2 = new SimpleLineSymbol(SimpleLineSymbol.STYLE_LONGDASH, new Color([235, 235, 5]), 3); var marker = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 10, lineSymbol1, new Color([215, 224, 203])); // var fill = new SimpleFillSymbol(SimpleFillSymbol.STYLE_VERTICAL, lineSymbol1, new Color([235, 235, 5])); var fill1 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, outLineSymbol, new Color([48, 190, 144, 0.5])); var fill2 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_DIAGONAL_CROSS, lineSymbol1, new Color([48, 190, 144])); var pictureMarkerSymbol = new PictureMarkerSymbol(&#x27;https://gtms04.alicdn.com/tps/i4/TB1_oz6GVXXXXaFXpXXJDFnIXXX-64-64.ico&#x27;, 20, 20); lineSymbol2.setMarker(&#123; style: &quot;arrow&quot;, placement: &quot;end&quot;, &#125;); on(toolbar, &quot;draw-complete&quot;, function (result) &#123; var geometry = result.geometry; var type = geometry.type; var graphic; switch (type) &#123; case &quot;point&quot;: if (smpPoint) graphic = new Graphic(geometry, marker); else graphic = new Graphic(geometry, pictureMarkerSymbol); break; case &quot;polyline&quot;: if (smpLine) graphic = new Graphic(geometry, lineSymbol1); else graphic = new Graphic(geometry, lineSymbol2); break; case &quot;polygon&quot;: if (smpPloy) graphic = new Graphic(geometry, fill1); else graphic = new Graphic(geometry, fill2); // graphic = new Graphic(geometry, fill); break; case &quot;multipoint&quot;: graphic = new Graphic(geometry, marker); break; &#125; console.log(map.graphics.renderer) map.graphics.add(graphic); toolbar.deactivate(); &#125;); &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"基础功能---交互画图1","date":"2021-07-22T09:54:49.022Z","path":"2021/07/22/基础功能---交互画图1/","text":"1.效果图 2.引入模块12345&quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, 3.像是绑定小部件的进阶版 都是使用switch选择合适的操作方法 12345678910111213141516171819202122232425262728293031323334353637query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; var value=this.innerHTML; switch(value)&#123; case &quot;绘制点&quot;:&#123; toolbar.activate(Draw.POINT, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制折线&quot;:&#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制面&quot;:&#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手线&quot;:&#123; toolbar.activate(Draw.FREEHAND_POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手面&quot;:&#123; toolbar.activate(Draw.FREEHAND_POLYGON, &#123; showTooltips:true &#125;) break; &#125; &#125; &#125;); 具有改进的是，引入on模块，toolbar通过switch决定各自操作方法（这里还不是太明白@@@标记） 12345678910111213141516171819on(toolbar,&quot;draw-complete&quot;, function (result) &#123; var geometry=result.geometry; var type=geometry.type; var graphic; switch (type) &#123; case &quot;point&quot;: graphic= new Graphic(geometry, marker); break; case &quot;polyline&quot;: graphic= new Graphic(geometry, lineSymbol); break; case &quot;polygon&quot;: graphic= new Graphic(geometry, fill); break; &#125; map.graphics.add(graphic); toolbar.deactivate(); &#125;); 4.贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;WebGIS&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:800px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;,&quot;dojo/dom&quot;,&quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;dojo/domReady!&quot;], function (Map,dom,on, ArcGISDynamicMapServiceLayer,query, Draw, SimpleLineSymbol,Graphic,SimpleMarkerSymbol,SimpleFillSymbol) &#123; var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) var toolbar = new Draw(map, &#123; showTooltips: true &#125;); var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var marker= new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new dojo.Color([255, 0, 0])); var fill= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 0, 0])); on(toolbar,&quot;draw-complete&quot;, function (result) &#123; var geometry=result.geometry; var type=geometry.type; var graphic; switch (type) &#123; case &quot;point&quot;: graphic= new Graphic(geometry, marker); break; case &quot;polyline&quot;: graphic= new Graphic(geometry, lineSymbol); break; case &quot;polygon&quot;: graphic= new Graphic(geometry, fill); break; &#125; map.graphics.add(graphic); toolbar.deactivate(); &#125;); query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; var value=this.innerHTML; switch(value)&#123; case &quot;绘制点&quot;:&#123; toolbar.activate(Draw.POINT, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制折线&quot;:&#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制面&quot;:&#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手线&quot;:&#123; toolbar.activate(Draw.FREEHAND_POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手面&quot;:&#123; toolbar.activate(Draw.FREEHAND_POLYGON, &#123; showTooltips:true &#125;) break; &#125; &#125; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;绘制点&lt;/button&gt; &lt;button&gt;绘制折线&lt;/button&gt; &lt;button&gt;绘制面&lt;/button&gt; &lt;button&gt;徒手线&lt;/button&gt; &lt;button&gt;徒手面&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 拓展","tags":[]},{"title":"基础功能---几何服务_缓冲区","date":"2021-07-22T09:54:49.020Z","path":"2021/07/22/基础功能---几何服务_缓冲区/","text":"1.效果图 2.启用几何服务和发布的地图一样，通过REST URL调用 3.引入模块12345&quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;esri/tasks/BufferParameters&quot;, &quot;dojo/colors&quot;, 4.步骤 创建几何服务对象 12//这里是几何服务的REST URLvar geometryServices = new GeometryService(&quot;http://localhost:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot;); 创建缓存参数对象 1var params = new BufferParameters(); 使用toolbar上的绘图工具 1var toolBar = new Draw(map); 创建点，线，面 123var pointSymbol = new SimpleMarkerSymbol(); lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 2); polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 255, 0, 0.25])); 给画点按钮绑定事件 123456on(dom.byId(&quot;point&quot;), &quot;click&quot;, function () &#123; //激活画点工具 toolBar.activate(Draw.POINT, &#123; showTooltips: true &#125;)&#125;) 绘图结束绑定事件 12345678910111213on(toolBar, &quot;draw-end&quot;, function (result) &#123; //获得点形状 var geometry = result.geometry; //创建Graphic var graphicpoint = new Graphic(geometry, pointSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); // *** 构建缓冲区分析的形状属性 //注意这里可以放一个数组，此处为了方便我们只对一个形状进行缓冲区分析 params.geometries = [geometry]; &#125;) 给缓冲区分析按钮绑定事件 123456789101112131415161718on(dom.byId(&quot;Btn&quot;), &quot;click&quot;, function () &#123; var mi = $(&quot;#te&quot;).val(); //缓冲距离 params.distances = [mi]; //空间参考，缓冲区样式，透明度等 params.bufferSpatialReference = map.spatialReference; params.outSpatialReference = map.spatialReference; //执行分析处理结果 geometryServices.buffer(params, function (result) &#123; //处理缓冲区分析得到的结果 for (var idx in result) &#123; //创建Graphic var graphic = new Graphic(result[idx], polygonSymbol) //结果放在map中 map.graphics.add(graphic) &#125; &#125;); &#125;) 5. 贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;缓冲区分析&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass &#123; width: 100%; height: 900px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;esri/tasks/BufferParameters&quot;, &quot;dojo/colors&quot;, &quot;dojo/domReady!&quot;], function (Map, dom, on, ArcGISDynamicMapServiceLayer, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Draw, Graphic, GeometryService, BufferParameters, Color) &#123; var map = new esri.Map(&quot;mapDiv&quot;); var layer = new esri.layers.ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建几何服务对象 var geometryServices = new GeometryService(&quot;http://localhost:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot;); //创建缓存参数对象 var params = new BufferParameters(); //使用toolbar上的绘图工具 var toolBar = new Draw(map); //创建点符号 var pointSymbol = new SimpleMarkerSymbol(); pointSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; pointSymbol.setSize(10); pointSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 2); //面符号 polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 255, 0, 0.25])); //给画点按钮绑定事件 on(dom.byId(&quot;point&quot;), &quot;click&quot;, function () &#123; //激活画点工具 toolBar.activate(Draw.POINT, &#123; showTooltips: true &#125;) &#125;) //绘图结束绑定事件 on(toolBar, &quot;draw-end&quot;, function (result) &#123; //获得点形状 var geometry = result.geometry; //创建Graphic var graphicpoint = new Graphic(geometry, pointSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); //很重要！！！在这里构建缓冲区分析的形状属性 //注意这里可以放一个数组，此处为了方便我们只对一个形状进行缓冲区分析 params.geometries = [geometry]; &#125;) //给缓冲区分析按钮绑定事件 on(dom.byId(&quot;Btn&quot;), &quot;click&quot;, function () &#123; // var mi = document.getElementById(&quot;te&quot;).value; var mi = $(&quot;#te&quot;).val(); //缓冲距离 params.distances = [mi]; //空间参考 params.bufferSpatialReference = map.spatialReference; params.outSpatialReference = map.spatialReference; //执行分析处理结果 geometryServices.buffer(params, function (result) &#123; //处理缓冲区分析得到的结果 for (var idx in result) &#123; //创建Graphic var graphic = new Graphic(result[idx], polygonSymbol) //将每一个结果都放在map中 map.graphics.add(graphic) &#125; &#125;); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;point&quot; type=&quot;button&quot; value=&quot;点&quot; /&gt; &lt;input id=&quot;te&quot; type=&quot;text&quot; value=&quot;缓冲距离&quot;&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;缓冲区分析&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 6. 拓展对连续点进行缓冲区操作，怎么消除上一个操作的缓冲区？怎么连续选点，批量建立缓冲区？","tags":[]},{"title":"基础功能---地图打印（踩坑、解决 详解）","date":"2021-07-22T09:54:49.018Z","path":"2021/07/22/基础功能---地图打印（踩坑、解决 详解）/","text":"踩坑如果点击打印地图，没有反应也不报错。考虑一下几点 ArcGIS Server中的地理处理服务没有开 浏览器阻止了弹出窗口 解决 运行服务 浏览器的弹出窗口，点击允许。如果没有弹出在浏览器设置 -&gt; 网站设置 -&gt; 弹出式窗口和重定向中打开允许，或者在允许中添加测试页面的地址。 当地图内存很大的时候，回调函数有可能会超时，这种情况下，会产生打印的pdf，执行回调函数中的内容需要等很久，具体时间视地图大小而定，因为已经响应超时。这种情况请继续看 打开控制台，查看资源，刷新页面，重新请求资源，点击打印，在最下面会增加两个资源 双击第二个资源，这是打印执行后服务器所返回的 出现这个，说明是成功了，但是弹出窗口还需要等待，可以直接点击value -&gt; url打开pdf，这个就是返回的pdf的地址 这里报错状态码为500，说明是地理处理服务没有打开。打开后重新运行解决。 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;地图打印&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;,&quot;dojo/on&quot;,&quot;dojo/query&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/PrintTask&quot;, &quot;esri/tasks/PrintTemplate&quot;, &quot;esri/tasks/PrintParameters&quot;, &quot;dojo/colors&quot;, &quot;dojo/domReady!&quot;], function (Map,dom,on,query, ArcGISDynamicMapServiceLayer, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Draw, Graphic, PrintTask,PrintTemplate,PrintParameters, Color) &#123; var map = new esri.Map(&quot;mapDiv&quot;); var layer = new esri.layers.ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建绘图对象 var toolBar = new Draw(map); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //面符号 polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0, 0.25])); //给绘制polygon的按钮绑定事件 query(&quot;.pbtn&quot;).on(&quot;click&quot;,function(event)&#123; //激活绘制多边形 toolBar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) &#125;) //绘图结束绑定事件 on(toolBar,&quot;draw-end&quot;,function(result)&#123; //获得面形状 var geometry=result.geometry; //创建Graphic var graphicpoint= new Graphic(geometry, polygonSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); &#125;) //给地图打印按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //创建地图打印对象 var printMap = new PrintTask(&quot;http://localhost:6080/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task&quot;); //创建地图打印模版 var template = new PrintTemplate(); //创建地图的打印参数，参数里面包括：模版和地图 var params = new PrintParameters(); //输出图片的空间参考 printMap.outSpatialReference = map.SpatialReference //打印图片的各种参数 template.exportOptions = &#123; width: 850, height: 650, dpi: 96 &#125;; //打印输出的格式 template.format = &quot;PDF&quot;; //输出地图的布局 template.layout = &quot;MAP_ONLY&quot;; PrintTemplate //设置参数地图 params.map = map; //设置参数模版 params.template = template; //运行结果 printMap.execute(params, function(result)&#123; if (result != null) &#123; //网页打开生成的地图 window.open(result.url); &#125; &#125;) &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pbtn&quot; &gt;画多边形&lt;/button&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;地图打印&quot; /&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"基础功能---地理编码","date":"2021-07-22T09:54:49.016Z","path":"2021/07/22/基础功能---地理编码/","text":"首先需要发布地理编码服务，再调用。还没有使用过这一功能。记录贴 贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;地理编码_动态图层服务&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/query&quot;,&quot;dojo/on&quot;,&quot;dojo/_base/array&quot;,&quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/locator&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;dojo/colors&quot;, &quot;esri/InfoTemplate&quot;,&quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function(Map,query,on,array,dom,ArcGISDynamicMapServiceLayer,Locator,SimpleMarkerSymbol,Color,InfoTemplate,Graphic)&#123; var map = new Map(&quot;mapDiv&quot;); var layer=new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer); query(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123; //获得名称 var name=query(&quot;.nm&quot;)[0].value; //创建地理编码对象 var locator = new Locator(&quot;http://localhost:6080/arcgis/rest/services/demo/nameLoc_geo/GeocodeServer&quot;); //参数和服务的参数对应 var address = &#123; &quot;Single Line Input&quot;: name&#125;; //输出的空间参考 locator.outSpatialReference = map.spatialReference; var options = &#123; address: address, outFields: [&quot;*&quot;] &#125; //执行方法 locator.addressToLocations(options,function(candidates)&#123; //获得运行之后的信息 if (candidates.length &gt; 0)&#123; var htmls = &quot;&lt;table style=&#x27;width: 100%&#x27;&gt;&quot;; htmls = htmls + &quot;&lt;tr bgcolor=&#x27;#E0E0E0&#x27;&gt;&lt;td&gt;X 坐标&lt;/td&gt;&lt;td&gt;Y 坐标&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;/tr&gt;&quot;; array.forEach(candidates, function (candidate, index) &#123; if (index % 2 == 1) &#123; htmls = htmls + &quot;&lt;tr bgcolor=&#x27;#E0E0E0&#x27;&gt;&lt;td style=&#x27;width: 60px&#x27;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&#x27;width: 60px&#x27;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; else &#123; htmls = htmls + &quot;&lt;tr&gt;&lt;td style=&#x27;width: 60px&#x27;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&#x27;width: 60px&#x27;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; &#125;); htmls = htmls + &quot;&lt;/table&gt;&quot;; dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125;,function(error)&#123;alert(error)&#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:580px; border:1px solid #000;&quot;&gt;&lt;/div&gt; Name:&lt;input class=&quot;nm&quot; type=&quot;text&quot;&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;定位&quot;&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"分析---影像分析","date":"2021-07-22T09:54:49.014Z","path":"2021/07/22/分析---影像分析/","text":"1.效果图 2.发布服务 在Arccatalog中共享为影像服务 发布成功之后查看 说明发布成功 3.引入模块查询影像数据esri/tasks/ImageServiceIdentifyTask参数：esri/tasks/ImageServiceIdentifyParameters esri/tasks/ImageServiceIdentifyResultesri/tasks/ImageServiceIdentifyResult接收返回的参数 影像测量esri/tasks/ImageServiceMeasureTask参数：esri/tasks/ImageServiceMeasureParameters 4.步骤 加载图层（不使用动态，使用影像服务） 创建影像分析和分析方法的参数对象 绑定事件，获取高程值并弹出 其中的掩模规则等可以封装为接口，方便以后使用5.代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;影像分析&lt;/title&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;this is my page&quot;&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:700px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISImageServiceLayer&quot;,&quot;dojo/on&quot;, &quot;dojo/dom&quot;,&quot;esri/toolbars/draw&quot;, &quot;esri/tasks/ImageServiceIdentifyTask&quot;,&quot;esri/tasks/ImageServiceIdentifyParameters&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;,&quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/MosaicRule&quot;, &quot;dojo/domReady!&quot;],function(Map,ArcGISImageServiceLayer,on,dom,Draw,ImageServiceIdentifyTask, ImageServiceIdentifyParameters,SimpleLineSymbol, Graphic,SimpleMarkerSymbol,SimpleFillSymbol,MosaicRule)&#123; var map=new Map(&quot;mapDiv&quot;) //注意这里是影像服务 var layer=new ArcGISImageServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/ImageService_qingdao/ImageServer&quot;) map.addLayer(layer); //用于绘制点 var toolbar =new Draw(map); //创建影像分析对象 var task=new ImageServiceIdentifyTask(&quot;http://localhost:6080/arcgis/rest/services/demo/ImageService_qingdao/ImageServer&quot;); //创建影像分析参数对象 var params=new ImageServiceIdentifyParameters(); var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var marker= new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new dojo.Color([255, 0, 0])); var fill= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 0, 0])); //给绘制折线按钮绑定事件 on(dom.byId(&quot;drawp&quot;),&quot;click&quot;,function()&#123; toolbar.activate(Draw.POINT, &#123; showTooltips:true &#125;) &#125;) //给draw工具的绘制完成事件绑定函数 on(toolbar,&quot;draw-complete&quot;, function (result) &#123; map.graphics.clear(); var geometry=result.geometry; //给参数对象的几何属性赋值 params.geometry =geometry; graphic= new Graphic(geometry, marker); map.graphics.add(graphic); toolbar.deactivate(); &#125;) on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function()&#123; //设置掩膜规则 var mosaicRule=new MosaicRule(); mosaicRule.ascending=false; mosaicRule.method=MosaicRule.METHOD_CENTER params.mosaicRule=mosaicRule params.pixelSizeX=layer.pixelSizeX; params.pixelSizeY=layer.pixelSizeY; task.execute(params,function(result)&#123; //弹出改点的高程值 alert(result.value) &#125;) &#125;) &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button id=&quot;drawp&quot;&gt;绘制点&lt;/button&gt; &lt;button id=&quot;btn&quot;&gt;查询&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"分析---网络分析","date":"2021-07-22T09:54:49.012Z","path":"2021/07/22/分析---网络分析/","text":"1.效果图分析经过停靠点，避开障碍点之间的最优路径 2.发布服务在ArcMap中进行网络分析制图后需要发布地图服务才可以被调用。 为了以后方便，全选择 打开工具条，进行新建路径等，结束制图后进行服务发布 发布服务时，需要增加Network Analysis功能 成功发布之后进入http://localhost:6080/arcgis/rest/services找到存放目录这样说明服务发布成功了 选择(NAServer)后缀的链接，复制URL 创建路径分析对象的时候参数为URL+/Route2.引入模块 12&quot;esri/tasks/RouteTask&quot;, &quot;esri/tasks/FeatureSet&quot;, 3.分析 分析需要不为0的停靠点和障碍点，所以先写添加点的方法， 为分析按钮添加事件，执行分析函数 得到路径分析结果，显示在图层上 需要注意健壮性的检验，即特殊情况的特判 4. 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;Geometric _Network&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/RouteTask&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/TextSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/tasks/RouteParameters&quot;, &quot;dojo/colors&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map,on,dom, ArcGISDynamicMapServiceLayer, RouteTask, FeatureSet, SimpleMarkerSymbol, TextSymbol, Draw, SimpleLineSymbol, RouteParameters, Color, Graphic ) &#123; var map = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/demo/WLFX_huanbao/MapServer&quot;); map.addLayer(layer) //创建路径分析对象 var shortestAnalyst = new RouteTask(&quot;http://localhost:6080/arcgis/rest/services/demo/WLFX_huanbao/NAServer/Route&quot;); //创建路径参数对象 var routeParas = new RouteParameters(); //障碍点，但是此时障碍点为空 routeParas.barriers = new FeatureSet(); //停靠点，但是此时停靠点为空 routeParas.stops = new FeatureSet(); //路径是否有方向 routeParas.returnDirections = false; //是否返回路径，此处必须返回 routeParas.returnRoutes = true; //空间参考 routeParas.outSpatialReference = map.SpatialReference; //定义一个标志 //selectPointID=0什么都不做 //selectPointID=1说明是添加停靠点 //selectPointID=2说明是添加障碍点 var selectPointID; //给停靠点按钮添加点击事件 on(dom.byId(&quot;stop&quot;),&quot;click&quot;,function()&#123; selectPointID = 1; &#125;) //给障碍点按钮添加点击事件 on(dom.byId(&quot;barriers&quot;),&quot;click&quot;,function()&#123; selectPointID = 2; &#125;) //定义停靠点的符号 var stopSymbol = new SimpleMarkerSymbol(); stopSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; stopSymbol.setSize(8); stopSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //定义障碍点的符号 var barrierSymbol = new SimpleMarkerSymbol(); barrierSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; barrierSymbol.setSize(8); barrierSymbol.setColor(new Color(&quot;#f1a340&quot;)); on(map, &quot;mouse-down&quot;, function(evt)&#123; //通过selectPointID判断是添加是停靠点还是障碍点 switch (selectPointID) &#123; case 0: break; case 1: //获得停靠点的坐标 var pointStop=evt.mapPoint; var gr=new Graphic(pointStop,stopSymbol); //构建停靠点的参数 routeParas.stops.features.push(gr); break; case 2: //获得障碍点的坐标 var pointBarrier=evt.mapPoint; var gr=new Graphic(pointBarrier,barrierSymbol); //构建障碍点的参数 routeParas.barriers.features.push(gr); break; &#125; //如果selectPointID不等于0，将点的坐标在地图上显示出来 if (selectPointID != 0) &#123; addTextPoint(&quot;停靠点&quot;, pointStop, stopSymbol); addTextPoint(&quot;障碍点&quot;, pointBarrier, barrierSymbol); selectPointID = 0; &#125; &#125;); //文本符号：文本信息，点坐标，符号 function addTextPoint(text,point,symbol) &#123; var textSymbol = new TextSymbol(text); textSymbol.setColor(new Color([128, 0, 0])); var graphicText = Graphic(point, textSymbol); var graphicpoint = new Graphic(point, symbol); //用默认的图层添加 map.graphics.add(graphicpoint); map.graphics.add(graphicText); &#125; //给分析按钮添加点击事件 on(dom.byId(&quot;analyse&quot;),&quot;click&quot;,function()&#123; //如果障碍点或者停靠点的个数有一个为0，提示用户参数输入不对 if (routeParas.stops.features.length == 0 || routeParas.barriers.features.length==0) &#123; alert(&quot;输入参数不全，无法分析&quot;); return; &#125; //执行路径分析函数 shortestAnalyst.solve(routeParas, showRoute) &#125;) //处理路径分析返回的结果。 function showRoute(solveResult) &#123; //路径分析的结果 var routeResults = solveResult.routeResults; //路径分析的长度 var res = routeResults.length; //路径的符号 routeSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); if (res &gt; 0) &#123; for (var i = 0; i &lt; res; i++) &#123; var graphicroute = routeResults[i]; var graphic = graphicroute.route; graphic.setSymbol(routeSymbol); map.graphics.add(graphic); &#125; &#125; else &#123; alert(&quot;没有返回结果&quot;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;stop&quot; type=&quot;button&quot; value=&quot;停靠点&quot; /&gt; &lt;input id=&quot;barriers&quot; type=&quot;button&quot; value=&quot;障碍点&quot; /&gt; &lt;input id=&quot;analyse&quot; type=&quot;button&quot; value=&quot;分析&quot; /&gt; &lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"分析---网络分析（最短路径）附完整代码","date":"2021-07-22T09:54:49.010Z","path":"2021/07/22/分析---网络分析（最短路径）附完整代码/","text":"1.效果图分析经过停靠点，避开障碍点之间的最优路径 2.发布服务在ArcMap中进行网络分析制图后需要发布地图服务才可以被调用。 为了以后方便，全选择 打开工具条，进行新建路径等，结束制图后进行服务发布 发布服务时，需要增加Network Analysis功能 成功发布之后进入http://localhost:6080/arcgis/rest/services找到存放目录这样说明服务发布成功了 选择(NAServer)后缀的链接，复制URL 创建好之后 新建路径 新建的路径图层名称 创建路径分析对象的时候参数为URL+/图层名称 例如：http://localhost:6080/arcgis/rest/services/webgis/fzkt_streets_ND/NAServer/路径2.引入模块12&quot;esri/tasks/RouteTask&quot;, &quot;esri/tasks/FeatureSet&quot;, 3.分析 定义 停靠点符号 障碍点符号 文本符号 路径符号 网络分析 创建路径分析对象 创建路径分析参数对象 设置分析参数参考坐标系 设置分析参数对象的障碍点和停靠点属性实例化要素集 设置分析参数返回无方向 设置分析参数返回路径 事件 添加停靠点的点击事件 添加障碍点的点击事件 添加地图的mouse-down监听事件 添加分析的点击事件 函数 添加简单图形符号函数 添加文本符号函数 路径分析返回结果处理函数 4. 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;Geometric _Network&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass &#123; width: 100%; height: 600px; border: 1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/RouteTask&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/TextSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/tasks/RouteParameters&quot;, &quot;dojo/colors&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, on, dom, ArcGISDynamicMapServiceLayer, RouteTask, FeatureSet, SimpleMarkerSymbol, TextSymbol, Draw, SimpleLineSymbol, RouteParameters, Color, Graphic ) &#123; var map = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/webgis/fzkt_streets_ND/MapServer&quot;); map.addLayer(layer) //创建路径分析对象 var shortestAnalyst = new RouteTask(&quot;http://localhost:6080/arcgis/rest/services/webgis/fzkt_streets_ND/NAServer/路径&quot;); //创建路径参数对象 var routeParas = new RouteParameters(); //障碍点 routeParas.barriers = new FeatureSet(); //停靠点 routeParas.stops = new FeatureSet(); routeParas.returnDirections = false; routeParas.returnRoutes = true; //空间参考 routeParas.outSpatialReference = map.SpatialReference; var selectPointID; on(dom.byId(&quot;stop&quot;), &quot;click&quot;, function () &#123; selectPointID = 1; &#125;) on(dom.byId(&quot;barriers&quot;), &quot;click&quot;, function () &#123; selectPointID = 2; &#125;) //停靠点的符号 var stopSymbol = new SimpleMarkerSymbol(); stopSymbol.style = SimpleMarkerSymbol.STYLE_CROSS; stopSymbol.setSize(15); //障碍点的符号 var barrierSymbol = new SimpleMarkerSymbol(); barrierSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; barrierSymbol.setSize(14); barrierSymbol.setColor(new Color(&quot;#f1a340&quot;)); on(map, &quot;mouse-down&quot;, function (evt) &#123; switch (selectPointID) &#123; case 0: break; case 1: var pointStop = evt.mapPoint; var gr = new Graphic(pointStop, stopSymbol); routeParas.stops.features.push(gr); break; case 2: var pointBarrier = evt.mapPoint; var gr = new Graphic(pointBarrier, barrierSymbol); routeParas.barriers.features.push(gr); break; &#125; if (selectPointID != 0) &#123; addPoint(pointStop, stopSymbol) addTextPoint(&quot;障碍点&quot;, pointBarrier, barrierSymbol); selectPointID = 0; &#125; &#125;); //单一 function addPoint(point, symbol) &#123; var graphicpoint = new Graphic(point, symbol); map.graphics.add(graphicpoint); &#125; //文本 function addTextPoint(text, point, symbol) &#123; var textSymbol = new TextSymbol(text); textSymbol.setColor(new Color([128, 0, 0])); var graphicText = Graphic(point, textSymbol); var graphicpoint = new Graphic(point, symbol); map.graphics.add(graphicpoint); map.graphics.add(graphicText); &#125; on(dom.byId(&quot;analyse&quot;), &quot;click&quot;, function () &#123; if (routeParas.stops.features.length == 0) &#123; alert(&quot;ERROR&quot;); return; &#125; shortestAnalyst.solve(routeParas, showRoute) &#125;) //处理路径分析返回的结果。 function showRoute(solveResult) &#123; console.log(solveResult) var routeResults = solveResult.routeResults; //路径分析的长度 var res = routeResults.length; routeSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([0, 0, 255, 0.5]), 3); if (res &gt; 0) &#123; for (var i = 0; i &lt; res; i++) &#123; var graphic = routeResults[i].route; graphic.setSymbol(routeSymbol); map.graphics.add(graphic); &#125; &#125; else &#123; alert(&quot;Null&quot;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;stop&quot; type=&quot;button&quot; value=&quot;停靠点&quot; /&gt; &lt;input id=&quot;barriers&quot; type=&quot;button&quot; value=&quot;障碍点&quot; /&gt; &lt;input id=&quot;analyse&quot; type=&quot;button&quot; value=&quot;分析&quot; /&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"分析---网络分析（临近设施分析）附完整代码","date":"2021-07-22T09:54:49.008Z","path":"2021/07/22/分析---网络分析（临近设施分析）附完整代码/","text":"效果图 本篇使用与最短路径分析相同用的服务 与最短路径的不同12345678910111213141516171819var closestFacilityTask = new ClosestFacilityTask(&quot;http://localhost:6080/arcgis/rest/services/webgis/fzkt_wlfx_all/NAServer/最近设施点&quot;);var params = new ClosestFacilityParameters();//单位params.impedenceAttribute = &quot;Miles&quot;;params.defaultCutoff = 7.0;//不返回事件信息params.returnIncidents = false;//返回路径params.returnRoutes = true;//路径有参数params.returnDirections = true;//服务点params.facilities = new FeatureSet();//事件点params.incidents = new FeatureSet();//点障碍params.pointBarriers = new FeatureSet();//空间参考params.outSpatialReference = map.SpatialReference; 基本架构与最短路径一样，此处直接贴代码，不懂详见最短路径分析 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Closest Facilities&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; #map &#123; width: 100%; height: 600px; border: 1px solid #000; &#125; .MapClass &#123; width: 100%; height: 600px; border: 1px solid #000; &#125; &lt;/style&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt; &lt;input id=&quot;server&quot; type=&quot;button&quot; value=&quot;服务点&quot; /&gt; &lt;input id=&quot;eventPoint&quot; type=&quot;button&quot; value=&quot;事件点&quot; /&gt; &lt;input id=&quot;barriers&quot; type=&quot;button&quot; value=&quot;障碍点&quot; /&gt; &lt;input id=&quot;analyse&quot; type=&quot;button&quot; value=&quot;分析&quot; /&gt; &lt;script&gt; require([ &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;dojo/_base/array&quot;, &quot;esri/Color&quot;, &quot;dojo/parser&quot;, &quot;dijit/registry&quot;, &quot;esri/urlUtils&quot;, &quot;esri/map&quot;, &quot;esri/lang&quot;, &quot;esri/graphic&quot;, &quot;esri/InfoTemplate&quot;, &quot;esri/layers/GraphicsLayer&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/geometry/Point&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/tasks/ClosestFacilityTask&quot;, &quot;esri/tasks/ClosestFacilityParameters&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/TextSymbol&quot;, &quot;dijit/form/ComboBox&quot;, &quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot; ], function ( on, dom, array, Color, parser, registry, urlUtils, Map, esriLang, Graphic, InfoTemplate, GraphicsLayer, SimpleRenderer, ArcGISDynamicMapServiceLayer, Point, FeatureSet, ClosestFacilityTask, ClosestFacilityParameters, SimpleMarkerSymbol, SimpleLineSymbol, TextSymbol ) &#123; var incidentsGraphicsLayer, routeGraphicLayer, closestFacilityTask; var map = new Map(&quot;map&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/webgis/fzkt_wlfx_all/MapServer&quot;); map.addLayer(layer) closestFacilityTask = new ClosestFacilityTask(&quot;http://localhost:6080/arcgis/rest/services/webgis/fzkt_wlfx_all/NAServer/最近设施点&quot;); //临近设施分析参数 var params = new ClosestFacilityParameters(); //单位 params.impedenceAttribute = &quot;Miles&quot;; params.defaultCutoff = 7.0; params.returnIncidents = false; params.returnRoutes = true; params.returnDirections = true; //服务点 params.facilities = new FeatureSet(); //事件点 params.incidents = new FeatureSet(); //点障碍 params.pointBarriers = new FeatureSet(); params.outSpatialReference = map.SpatialReference; //服务点符号 var facilityPointSymbol = new SimpleMarkerSymbol( SimpleMarkerSymbol.STYLE_SQUARE, 20, new SimpleLineSymbol( SimpleLineSymbol.STYLE_SOLID, new Color([89, 95, 35]), 2 ), new Color([130, 159, 83, 0.40]) ); //事件点符号 var incidentPointSymbol = new SimpleMarkerSymbol( SimpleMarkerSymbol.STYLE_CIRCLE, 16, new SimpleLineSymbol( SimpleLineSymbol.STYLE_SOLID, new Color([89, 95, 35]), 2 ), new Color([130, 159, 83, 0.40]) ); //障碍点符号 var barrierSymbol = new SimpleMarkerSymbol(); barrierSymbol.style = SimpleMarkerSymbol.STYLE_X; barrierSymbol.setSize(12); barrierSymbol.setColor(new Color(&quot;#f1a340&quot;)); incidentsGraphicsLayer = new GraphicsLayer(); //路径线符号 var routePolylineSymbol = new SimpleLineSymbol( SimpleLineSymbol.STYLE_SOLID, new Color(&quot;#0078df&quot;), 4.0 ); var selectPointID; //服务点 $(&quot;#server&quot;).click(function () &#123; selectPointID = 1; &#125;); //事件点 $(&quot;#eventPoint&quot;).click(function () &#123; selectPointID = 2; &#125;); //障碍点 $(&quot;#barriers&quot;).click(function () &#123; selectPointID = 3; &#125;); on(map, &quot;mouse-down&quot;, function (evt) &#123; switch (selectPointID) &#123; case 0: break; case 1: var pointServer = evt.mapPoint; var gr = new Graphic(pointServer, facilityPointSymbol); params.facilities.features.push(gr); break; case 2: var pointEvent = evt.mapPoint; var gr = new Graphic(pointEvent, incidentPointSymbol); params.incidents.features.push(gr); break; case 3: var pointBarrier = evt.mapPoint; var gr = new Graphic(pointBarrier, barrierSymbol); params.pointBarriers.features.push(gr); break; &#125; if (selectPointID != 0) &#123; addTextPoint(&quot;服务点&quot;, pointServer, facilityPointSymbol); addTextPoint(&quot;事件点&quot;, pointEvent, incidentPointSymbol); addTextPoint(&quot;障碍点&quot;, pointBarrier, barrierSymbol); &#125; &#125;); function addTextPoint(text, point, symbol) &#123; var textSymbol = new TextSymbol(text); textSymbol.setColor(new Color([128, 0, 0])); var graphicText = Graphic(point, textSymbol); var graphicpoint = new Graphic(point, symbol); map.graphics.add(graphicpoint); map.graphics.add(graphicText); &#125; $(&quot;#analyse&quot;).click(function () &#123; selectPointID = 0; if (params.facilities.features.length == 0 || params.incidents.features.length == 0) &#123; alert(&quot;无法分析&quot;); return; &#125; closestFacilityTask.solve(params, showRoute) &#125;); function showRoute(solveResult) &#123; var routeResults = solveResult.routes; var res = routeResults.length; if (res &gt; 0) &#123; for (var i = 0; i &lt; res; i++) &#123; var graphicroute = routeResults[i]; var graphic = graphicroute; graphic.setSymbol(routePolylineSymbol); map.graphics.add(graphic); &#125; &#125; else &#123; alert(&quot;NULL&quot;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"分析 -- 缓冲区查询","date":"2021-07-22T09:54:49.006Z","path":"2021/07/22/分析 -- 缓冲区查询/","text":"效果图 过程主要参考官方给的示例代码。 绘图工具 结束触发缓冲函数 更新查询几何为返回的缓冲区 官方案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt;&lt;title&gt;Buffer&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.21/esri/css/esri.css&quot;&gt;&lt;style type=&quot;text/css&quot;&gt; html,body,#map&#123; width: 100%; height: 100%; margin: 0; padding: 0； &#125;&lt;/style&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://js.arcgis.com/3.21/&quot;&gt;&lt;/script&gt;&lt;body&gt;&lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/geometry/Point&quot;, &quot;esri/geometry/Polyline&quot;, &quot;esri/geometry/Polygon&quot;, &quot;esri/graphic&quot;, &quot;esri/Color&quot;, &quot;esri/tasks/BufferParameters&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/SpatialReference&quot;, &quot;dojo/domReady!&quot;],function(Map,Point,Polyline,Polygon,Graphic,Color,BufferParameters,GeometryService,SimpleMarkerSymbol,SimpleFillSymbol,SimpleLineSymbol,SpatialReference)&#123; var map=new Map(&quot;map&quot;,&#123; basemap: &quot;osm&quot;, center: [115.95,28.6826], zoom:&quot;12&quot; &#125;); var points=[new Point(116.026,28.6826),new Point(116.05,28.66),new Point(116.11,28.70),new Point(115.95,28.65)]; var polylines=[new Polyline([[115.88,28.70],[115.88,28.67]]),new Polyline([[115.82,28.64],[115.89,28.59]])]; var polygons=[new Polygon([[115.798499,28.783553],[115.75998,28.895433],[115.900834,28.821535],[115.785276,28.759237],[115.713987,28.733902]])]; var geometryService=new GeometryService(&quot;https://utility.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer&quot;); map.on(&quot;load&quot;,function()&#123; var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID,new Color([255,0,0]), 4) var markerSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE, 10, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID,new Color([100,100,100,0.1]), 1), new Color([255,0,0])); var fillSymbol=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(&quot;solid&quot;, new Color([255,0,0]), 1), new Color([255,0,0])); for(var i=0;i&lt;points.length;i++)&#123; map.graphics.add(new Graphic(points[i],markerSymbol)) &#125; for(var i=0;i&lt;polylines.length;i++)&#123; map.graphics.add(new Graphic(polylines[i],lineSymbol)) &#125; for(var i=0;i&lt;polygons.length;i++)&#123; map.graphics.add(new Graphic(polygons[i],fillSymbol)) &#125; // 点缓冲区 var pointParams = new BufferParameters(); pointParams.geometries = points; pointParams.distances = [ 1]; pointParams.unit = GeometryService.UNIT_KILOMETER; pointParams.bufferSpatialReference = new SpatialReference(&#123;wkid: 32662&#125;); pointParams.outSpatialReference = new SpatialReference(&#123;wkid: 4326&#125;) geometryService.buffer(pointParams,function(features) &#123; var symbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(&quot;solid&quot;, new Color([197,97,20]), 1), new Color([197,97,20,1])); for(var i=0;i&lt;features.length;i++)&#123; console.log(features[i]); map.graphics.add(new Graphic(features[i],symbol)) &#125; &#125;); // 线缓冲区 var polyineParams=new BufferParameters(); polyineParams.geometries=polylines; polyineParams.distances = [ 1]; polyineParams.unit = GeometryService.UNIT_KILOMETER; polyineParams.bufferSpatialReference = new SpatialReference(&#123;wkid: 32662&#125;); polyineParams.outSpatialReference = new SpatialReference(&#123;wkid: 4326&#125;); geometryService.buffer(polyineParams,function(features) &#123; var symbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(&quot;solid&quot;, new Color([197,97,20]), 1), new Color([197,97,20,1])); for(var i=0;i&lt;features.length;i++)&#123; console.log(features[i]); map.graphics.add(new Graphic(features[i],symbol)) &#125; &#125;); // 面缓冲区 var polygonParams=new BufferParameters(); polygonParams.geometries=polygons; polygonParams.geodesic=true; polygonParams.distances = [ 1]; polygonParams.unit = GeometryService.UNIT_KILOMETER; polygonParams.bufferSpatialReference = new SpatialReference(&#123;wkid: 32662&#125;); polygonParams.outSpatialReference = new SpatialReference(&#123;wkid: 4326&#125;); geometryService.buffer(polygonParams,function(features) &#123; var symbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(&quot;solid&quot;, new Color([197,97,20]), 1), new Color([197,97,20,0.5])); for(var i=0;i&lt;features.length;i++)&#123; console.log(features[i]); map.graphics.add(new Graphic(features[i],symbol)) &#125; &#125;); &#125;) &#125;);&lt;/script&gt;&lt;/html&gt; 缓冲区空间查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122var url = &quot;http://localhost:6080/arcgis/rest/services/Eco/BJ_td_gd_nyd/MapServer&quot;;require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/tasks/query&quot;, &quot;esri/geometry/Polygon&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;esri/Color&quot;, &quot;esri/tasks/BufferParameters&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/SpatialReference&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom, on, QueryTask, Draw, Query, Polygon, SimpleLineSymbol, SimpleFillSymbol, Graphic, Color, BufferParameters, GeometryService, SimpleMarkerSymbol, SimpleFillSymbol, SimpleLineSymbol, SpatialReference) &#123; var map = new Map(&quot;mapdiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(url); map.addLayer(layer) //定义一个绘图工具 var toolBar = new Draw(map); //给button绑定事件 on(dom.byId(&quot;Btn&quot;), &quot;click&quot;, function () &#123; //激活绘图工具，我要绘制一个面图形 toolBar.activate(Draw.POLYGON); &#125;) on(toolBar, &quot;draw-complete&quot;, function (result) &#123; //获得绘图得到的面 var geometry = result.geometry; //关闭绘图工具 toolBar.deactivate(); bufferSelect(geometry) queryGraphic(geometry); &#125;); function bufferSelect(geometry) &#123; var polygons = [new Polygon(geometry.rings)]; console.log(polygons) var geometryService = new GeometryService(&quot;https://utility.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer&quot;); // 面缓冲区 var polygonParams = new BufferParameters(); polygonParams.geometries = polygons; polygonParams.geodesic = true; polygonParams.distances = [8]; polygonParams.unit = GeometryService.UNIT_KILOMETER; polygonParams.bufferSpatialReference = new SpatialReference(&#123; wkid: 32662 &#125;); polygonParams.outSpatialReference = new SpatialReference(&#123; wkid: 4326 &#125;); geometryService.buffer(polygonParams, function (features) &#123; console.log(features) var symbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(&quot;solid&quot;, new Color([197, 97, 20]), 1), new Color([207, 135, 89, 0.5])); for (var i = 0; i &lt; features.length; i++) &#123; console.log(features[i]); map.graphics.add(new Graphic(features[i], symbol)) queryGraphic(features[i]) &#125; &#125;); var fillSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(&quot;solid&quot;, new Color([255, 0, 0]), 0.8), new Color([255, 0, 0])); for (var i = 0; i &lt; polygons.length; i++) &#123; map.graphics.add(new Graphic(polygons[i], fillSymbol)) &#125; &#125; function queryGraphic(geometry) &#123; //创建查询对象 var queryTask = new QueryTask(url + &quot;/0&quot;); //创建查询参数对象 var query = new Query(); //是否返回几何形状 query.returnGeometry = true; //空间查询的几何对象 query.geometry = geometry; //服务器给我们返回的字段信息，*代表返回所有字段 query.outFields = [&quot;*&quot;]; //空间参考信息 query.outSpatialReference = map.spatialReference; //查询的标准，此处代表和geometry相交的图形都要返回 query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS; //执行空间查询 queryTask.execute(query, showQueryResult); &#125; function showQueryResult(queryResult) &#123; //创建线符号 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, new SimpleLineSymbol(&quot;solid&quot;, new Color([30, 30, 30]), 1), new Color([133, 105, 70, 0.5])); var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) &#123; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //得到graphic var graphic = queryResult.features[i]; //给图形赋予符号 graphic.setSymbol(fill); //添加到地图从而实现高亮效果 map.graphics.add(graphic); &#125; &#125; &#125; &#125;);","tags":[]},{"title":"发布BufferGP服务","date":"2021-07-22T09:54:49.004Z","path":"2021/07/22/发布BufferGP服务/","text":"步骤： 新建工具箱 -&gt; 模型 -&gt; 模型重命名为英文 拖进Buffer工具 给input dis out设置为模型参数，相当于函数中的形参 验证模型并保存退出，双击运行模型 打开结果， 在当前会话中找到刚刚的模型处理,右键 -&gt;共享为 -&gt; 地理处理服务 同步是execute方法；异步是submitJob方法 分析 -&gt; 发布 -&gt;查看 如果发布失败，检查变量及模型名称是否为英文 请求GP工具 出现则成功","tags":[]},{"title":"动态地图加载api 4.x","date":"2021-07-22T09:54:49.001Z","path":"2021/07/22/动态地图加载api 4.x/","text":"感觉3和4还是有较大改变的。从esri官方例子上看来，4的功能更加丰富，在大数据的展示和操作上体验比3要好。 4.12为例 1. 不同 API调用 123456//API 3.x ：&lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt;&lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;//API 4.x ：&lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.12/esri/css/main.css&quot;&gt; &lt;script src=&quot;https://js.arcgis.com/4.12/&quot;&gt; 动态图层的引用模块 123456//API 3.x ：&quot;esri/map&quot;,“esri/layers/ArcGISDynamicMapServiceLayer”，//API 4.x ：&quot;esri/Map&quot;,“esri/views/MapView” “map”改为了”Map” 显而易见从layers目录下到，到了views下，说明，地图需要放置在views中，既然多了一层，那这个views层必然是为我们封装了很多的方法和接口。 创建Map对象不在需要绑定id 1234//API 3.x ：var map = new Map(&quot;mapDiv&quot;);//API 4.x ：var map = new Map(); 图层的创建 1234var layer = new MapImageLayer(&#123; url:&quot;http://192.168.3.1:6080/arcgis/rest/services/gaofen/xianghe/MapServer&quot;, sublayers: [&#123;id: 0,visible:true&#125;]&#125;); 一般为两个参数，url 和 sublayers url 为 REST URL sublayers 设置图层可见性 比3更加方便 创建MapView，需要选择容器中的 map 和绑定的 DIV 的 id 1234new MapView(&#123; map: map, container: &quot;viewDiv&quot;&#125;); 2. api 3.x 代码3. api 4.x 代码 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.12/esri/css/main.css&quot;&gt; &lt;script src=&quot;https://js.arcgis.com/4.12/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/Map&quot;, &quot;esri/layers/MapImageLayer&quot;, &quot;esri/views/MapView&quot;, &quot;dojo/domReady!&quot;], function (Map, MapImageLayer, MapView) &#123; var map = new Map(); var layer = new MapImageLayer(&#123; url:&quot;http://192.168.3.1:6080/arcgis/rest/services/gaofen/xianghe/MapServer&quot;, &#125;); map.add(layer); new MapView(&#123; map: map, container: &quot;viewDiv&quot; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;viewDiv&quot; style=&quot;height:800px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"大数据学习记录（更新中）","date":"2021-07-22T09:54:48.999Z","path":"2021/07/22/大数据学习记录（更新中）/","text":"大数据基本概念 搭建环境 处理架构","tags":[]},{"title":"大数据概述概念总结","date":"2021-07-22T09:54:48.997Z","path":"2021/07/22/大数据概述概念总结/","text":"第三次信息化浪潮的标志：云计算、大数据、物联网技术的普及 大数据时代新兴的技术：Spark、Hadoop、HBase 大数据发展的三个阶段： 萌芽期（上世纪90年代至本世纪初） 成熟期（本实际前十年） 大规模应用期（2010年前后） 数据产生方式大致经历了三个阶段： 感知式系统阶段 运营式系统阶段 用户原创内容阶段 大数据带来思维方式的三个转变是： 全样而非抽样 相关而非因果 效率而非精确 大数据的4V特性：数据量大、数据类型繁多、处理速度快、价值密度低 Jim Gray博士认为，人类在科学研究上先后经历了四种范式：实验科学、理论科学、计算科学和数据密集型科学 大数据计算模式： 批处理计算：针对大规模数据的批量处理。MapReduce、Spark等 流计算：针对流数据的实时计算。Storm、S4、Flume、Streams、Puma、DStream、Super Mario、银河流数据处理平台等 图计算：针对大规模图结构数据的处理。Pregel、GraphX、Giraph、PowerGraph、Hama、GoldenOrb等 查询分析计算：大规模数据的存储管理和查询分析。Dremel、Hive、Cassandra、Impala 云计算的典型服务模式：SaaS、IaaS、PaaS 云计算关键技术包括：虚拟化、分布式存储、分布式计算、多租户等 物联网中的关键技术包括识别和感知技术（二维码、RFID、传感器等）、网络与通信技术、数据挖掘与融合技术等 云计算、大数据和物联网三者紧密相关，相辅相成 物联网可以借助于大数据实现海量数据的分析 物联网可以借助于云计算实现海量数据的存储","tags":[]},{"title":"处理架构知识点","date":"2021-07-22T09:54:48.994Z","path":"2021/07/22/处理架构知识点/","text":"Hadoop的核心是HDFS和MapReduce Hadoop2.0增加了NameNode HA和Wire-compatibility两个重大特性 Hadoop MapReduce是针对谷歌MapReduce的开源实现，通常用于大规模数据集的并行计算 hadoop的特性高可靠性、支持多种编程语言、高容错性 HDFS：分布式文件系统，是Hadoop项目的两大核心之一，是谷歌GFS的开源实现 HBase：提供高可靠性、高性能、分布式的列式数据库，是谷歌BigTable的开源实现 Zookeeper：针对谷歌Chubby的一个开源实现，是高效可靠的协同工作系统 Hive：一个基于Hadoop的数据仓库工具，用于对Hadoop文件中的数据集进行数据整理、特殊查询和分析存储 Hadoop生态系统功能组件：核心的HDFS和MapReduce以外，还包括ZoopKer、HBase、Hive、Pig、Mahout、Sqoop、Flume、Ambari等功能组件 操作HDFS文件的命令hdfs dfs","tags":[]},{"title":"","date":"2021-07-22T09:54:48.992Z","path":"2021/07/22/查询---查询+echarts交互/","text":"1.效果图 PS:表格数据只有第一列为真实获取，剩余为写死的数据。查询的结果是一个地区的不同属性。Echarts要展示的为不同地区的同一属性，为方便测试功能，就没有重新制图。 2.注意加载模块时，只能有一种采用配置路径加载。 为什么呢？例如，ArcJS的模块加载路径是在https://js.arcgis.com/3.28/，如果echarts也采用这种方法加载模块，那么便会出现这种情况，例如加载echarts.min.js包，在浏览器开发者模式下NetWork中的该资源的下载路径是https://js.arcgis.com/3.28/echarts.min.js显然这个路径下是下载不到这个包的，就会报错，显示echarts.min.js文件下载出错。 解决：任一个的包部署在本地之后，本地加载。注意加载的顺序，先加载echarts在加载ArcJS。**因为Echarts的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边 3. 贴代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;script src=&quot;../echarts.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass &#123; width: 100%; height: 520px; /* border:1px solid #000; */ &#125; &lt;/style&gt; &lt;script&gt; var beijing0 = &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;; var GL_pt_NL_NAME_3; var GL_pt_area_td; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;dojo/query&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/Color&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom, on, query, QueryTask, Query, SimpleLineSymbol, Color) &#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) //给属性查询按钮添加click事件 on(dom.byId(&quot;Btn_sx&quot;), &quot;click&quot;, function (e) &#123; // var text = document.getElementById(&quot;te&quot;).value; var text = $(&quot;#te&quot;).val(); //定义查询对象 var queryTask = new QueryTask(beijing0); //定义查询参数对象 var query = new Query(); //查询条件，类似于sql语句的where子句 query.where = &quot;FID = &quot; + text; //返回的字段信息：*代表返回全部字段 query.outFields = [&quot;*&quot;]; //是否返回几何形状 query.returnGeometry = true; //执行属性查询 var a = queryTask.execute(query, showQueryResult); // alert(re()); &#125;) //属性查询完成之后，用showQueryResult来处理返回的结果 function showQueryResult(queryResult) &#123; if (queryResult.features.length &gt;= 1) &#123; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; var graphic = queryResult.features[i]; var pt_NL_NAME_3 = graphic.attributes[&quot;NL_NAME_3&quot;]; var pt_area_td = graphic.attributes[&quot;土地面积&quot;]; GL_pt_NL_NAME_3 = pt_NL_NAME_3; GL_pt_area_td = pt_area_td; &#125; &#125; var x = document.getElementById(&quot;main&quot;); var myChart = echarts.init(x); var option = &#123; tooltip: &#123; show: true &#125;, legend: &#123; data: [&#x27;123&#x27;] &#125;, xAxis: [&#123; type: &#x27;category&#x27;, data: [GL_pt_NL_NAME_3, &quot;朝阳区&quot;, &quot;大厂区&quot;] &#125;], yAxis: [&#123; type: &#x27;value&#x27; &#125;], series: [&#123; &quot;name&quot;: &quot;销量&quot;, &quot;type&quot;: &quot;bar&quot;, &quot;data&quot;: [pt_area_td, 1500, 1000] &#125;] &#125;; myChart.setOption(option); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;在此处输入需要查询的XX&quot; id=&quot;te&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn_sx&quot; /&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot; style=&quot;height:400px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"","date":"2021-07-22T09:54:48.990Z","path":"2021/07/22/查询---QueryTask属性查询/","text":"1. 效果图查询FID为2的区域 2. FindTask和QueryTask属性查询中的不同 引入模块 FindTask：&quot;esri/tasks/FindTask&quot;,&quot;esri/tasks/FindParameters&quot;,QueryTask：&quot;esri/tasks/QueryTask&quot;,&quot;esri/tasks/query&quot;, 定义查询对象 FindTask： 12//动态图层var findTask = new FindTask(http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer); **QueryTask：** 12//要素图层var queryTask = new QueryTask(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); 查询条件 FindTask： 123//查询字段 findParams.searchFields=findParams.searchTextfindParams.searchFields = [&quot;FID&quot;];findParams.searchText = &quot;2&quot;; **QueryTask：** 1234//查询条件，类似于sql语句的where子句query.where = &quot;FID = 2&quot;;//返回的字段信息：*代表返回全部字段query.outFields = [&quot;*&quot;]; 显示 FindTask 中的 queryResult == QueryTask 中的 queryResult.features[i]; 3. 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:800px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) &#123; //根据div的id属性创建地图 var map = new Map(&quot;mapDiv&quot;); //定义一个动态地图服务 var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); //将图层添加到地图 map.addLayer(layer) //给属性查询按钮添加click事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e)&#123; //定义查询对象，查询参数 var queryTask = new QueryTask (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); var query = new Query(); //是否返回几何形状 query.returnGeometry = true; //查询条件，类似于sql语句的where子句 query.where = &quot;FID = 2&quot;; //返回的字段信息：*代表返回全部字段 query.outFields = [&quot;*&quot;]; //执行属性查询 queryTask.execute(query, showQueryResult); &#125;) //属性查询完成之后，用showQueryResult来处理返回的结果 function showQueryResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //获得图形graphic var graphic = queryResult.features[i]; //赋予相应的符号 graphic.setSymbol(fill); //将graphic添加到地图中，从而实现高亮效果 map.graphics.add(graphic); //获得neirong var ptName = graphic.attributes[&quot;NL_NAME_3&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //将属性绑定在divShowResult上面 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. 拓展（JS基础） 改为选择查询参数，输入查询关键字，点击查询","tags":[]},{"title":"","date":"2021-07-22T09:54:48.988Z","path":"2021/07/22/查询---QueryTask空间查询/","text":"1. 效果图 2. QueryTask属性查询和空间查询的不同 引入模块不同空间查询多了&quot;esri/toolbars/draw&quot;,模块 条件格式 1234567891011121314//定义一个绘图工具var toolBar = new Draw(map);//给button绑定事件on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //激活绘图工具，我要绘制一个面图形 toolBar.activate(Draw.POLYGON);&#125;)on(toolBar, &quot;draw-complete&quot;, function (result) &#123; //获得绘图得到的面 var geometry=result.geometry; //关闭绘图工具 toolBar.deactivate(); queryGraphic(geometry);&#125;); 查询条件 属性查询 12//查询条件，类似于sql语句的where子句query.where = &quot;FID = 2&quot;; 空间查询 12//空间查询的几何对象query.geometry = geometry; 3. 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:800px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Draw, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) &#123; var map = new Map(&quot;mapdiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) //定义一个绘图工具 var toolBar = new Draw(map); //给button绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //激活绘图工具，我要绘制一个面图形 toolBar.activate(Draw.POLYGON); &#125;) on(toolBar, &quot;draw-complete&quot;, function (result) &#123; //获得绘图得到的面 var geometry=result.geometry; //关闭绘图工具 toolBar.deactivate(); queryGraphic(geometry); &#125;); function queryGraphic(geometry) &#123; //创建查询对象 var queryTask = new QueryTask( &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); //创建查询参数对象 var query = new Query(); //是否返回几何形状 query.returnGeometry = true; //空间查询的几何对象 query.geometry = geometry; //服务器给我们返回的字段信息，*代表返回所有字段 query.outFields = [&quot;*&quot;]; //空间参考信息 query.outSpatialReference = map.spatialReference; //查询的标准，此处代表和geometry相交的图形都要返回 query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS; //执行空间查询 queryTask.execute(query, showQueryResult); &#125; function showQueryResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //得到graphic var graphic = queryResult.features[i]; //给图形赋予符号 graphic.setSymbol(fill); //添加到地图从而实现高亮效果 map.graphics.add(graphic); ////获得内容，对应属性表 var ptName = graphic.attributes[&quot;NL_NAME_3&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot;\\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //将教学楼的名称信息和divShowResult绑定 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapdiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;空间查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"","date":"2021-07-22T09:54:48.986Z","path":"2021/07/22/查询---QueryTask空间+属性查询/","text":"1.效果图将上面两片结合起来就OK，代码容易，但是高亮过的图层怎么消除？（扩展） 2. 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:800px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Draw, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) &#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); //将图层添加到地图 map.addLayer(layer) //给属性查询按钮添加click事件 on(dom.byId(&quot;Btn_sx&quot;),&quot;click&quot;,function(e)&#123; var queryTask = new QueryTask (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); var query = new Query(); query.where = &quot;FID = 2&quot;; query.outFields = [&quot;*&quot;]; query.returnGeometry = true; queryTask.execute(query, showQueryResult); &#125;) var toolBar = new Draw(map); on(dom.byId(&quot;Btn_kj&quot;),&quot;click&quot;,function()&#123; toolBar.activate(Draw.POLYGON); &#125;) on(toolBar, &quot;draw-complete&quot;, function (result) &#123; var geometry=result.geometry; toolBar.deactivate(); queryGraphic(geometry); &#125;); function queryGraphic(geometry) &#123; var queryTask = new QueryTask( &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); var query = new Query(); query.geometry = geometry; query.outFields = [&quot;*&quot;]; query.returnGeometry = true; queryTask.execute(query, showQueryResult); &#125; function showQueryResult(queryResult) &#123; var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; var graphic = queryResult.features[i]; graphic.setSymbol(fill); map.graphics.add(graphic); var ptName = graphic.attributes[&quot;NL_NAME_3&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn_sx&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;空间查询&quot; id=&quot;Btn_kj&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"","date":"2021-07-22T09:54:48.984Z","path":"2021/07/22/查询---GraphicsLayer的属性查询/","text":"这个查询方法，学习过还没有在开发中真正的使用过。感觉没有上述的三种好用。例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Graphic&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:800px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/GraphicsLayer&quot;, &quot;dojo/on&quot;,&quot;dojo/query&quot;,&quot;dojo/colors&quot;, &quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/geometry/Point&quot;, &quot;dojo/domReady!&quot;], function(Map,ArcGISDynamicMapServiceLayer, GraphicsLayer,on,query,Color,Graphic, SimpleMarkerSymbol,SimpleLineSymbol,Point)&#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建客户端图层 var graphicsLayer=new GraphicsLayer(); //将客户端图层添加到地图中 map.addLayer(graphicsLayer); //添加点图形的函数 function addGraphic() &#123; var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); var geometry; var graphic; //添加第一个点 geometry=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:100, &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第二个点图形 geometry=new Point(&#123; &quot;x&quot;:510326, &quot;y&quot;:3985702, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:200, &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第三个点 geometry=new Point(&#123; &quot;x&quot;:510275, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:300, &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); &#125; addGraphic(); //绑定事件 on(graphicsLayer,&quot;click&quot;,function(event)&#123; var graphic=event.graphic; alert(graphic.attributes[&quot;h&quot;]); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"","date":"2021-07-22T09:54:48.982Z","path":"2021/07/22/查询---FindTask属性查询/","text":"1. 效果图查询FID为2的区域 2. 引入模块12345678910//查询对象&quot;esri/tasks/FindTask&quot;,//查询参数 &quot;esri/tasks/FindParameters&quot;, //线符号对象&quot;esri/symbols/SimpleLineSymbol&quot;,//面符号对象&quot;esri/symbols/SimpleFillSymbol&quot;,//图形对象 &quot;esri/graphic&quot;, 3. 步骤 查询 显示 查询 创建属性查询对象、查询参数 12var findTask = new FindTask(MapServer);var findParams = new FindParameters(); 绑定触发事件 1on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123;&#125;) 返回几何信息 决定高亮等结果显示 1findParams.returnGeometry = true; 查询图层 1findParams.layerIds = [1]; 查询字段 findParams.searchFields=findParams.searchText 12findParams.searchFields = [&quot;FID&quot;];findParams.searchText = &quot;2&quot;; 执行查询对象 12//ShowFindResult是显示方法findTask.execute(findParams, ShowFindResult); 显示 创建线符号 1var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); 创建面符号 1var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); 如果查询结果等于0，结束。 1234if (queryResult.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return;&#125; 查询结果大于等于1 1if (queryResult.length &gt;= 1) &#123;&#125; 获得图形，设置符号，添加在地图中，高亮 1234567//获得图形var graphic = queryResult[i].feature;//设置符号graphic.setSymbol(fill);//将graphic添加到地图中//实现高亮map.graphics.add(graphic); 获取对应属性表的内容，并修改显示div的html为获取到的内容 123456789var ptName = graphic.attributes[&quot;FID&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; 修改显示div的html 1dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; 4.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;FindTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:800px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/tasks/FindTask&quot;, &quot;esri/tasks/FindParameters&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom, FindTask, FindParameters, SimpleLineSymbol,SimpleFillSymbol,Graphic) &#123; var map = new esri.Map(&quot;mapDiv&quot;); var MapServer = &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;; var layer = new esri.layers.ArcGISDynamicMapServiceLayer(MapServer); map.addLayer(layer) //创建属性查询对象、查询参数 var findTask = new FindTask(MapServer); var findParams = new FindParameters(); //绑定触发事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //是否返回几何信息 决定高亮等结果显示 findParams.returnGeometry = true; //查询图层 findParams.layerIds = [1]; //查询字段 findParams.searchFields=findParams.searchText findParams.searchFields = [&quot;FID&quot;]; findParams.searchText = &quot;2&quot;; //执行查询对象 findTask.execute(findParams, ShowFindResult); &#125;) function ShowFindResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.length; i++) &#123; //获得图形 var graphic = queryResult[i].feature; //赋予相应的符号 graphic.setSymbol(fill); //将graphic添加到地图中 //实现高亮 map.graphics.add(graphic); //获得内容 注意对应属性表 var ptName = graphic.attributes[&quot;FID&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //dom操作修改div的html dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5. 拓展（JS基础） 改为选择查询参数，输入查询关键字，点击查询","tags":[]},{"title":"WebGIS期中复习","date":"2021-07-22T09:54:48.980Z","path":"2021/07/22/WebGIS期中复习/","text":"第一章 施乐公司开发的一个基于Web的地图浏览器，标志着万维网地理信息系统的产生 WebGIS是使用了Web技术的各种地理信息系统 WebGIS需要通过Web技术来实现 WebGIS是一种分布式的地理信息系统 WebGIS至少需要一个Web应用服务器和一个客户端 WebGIS开源解决方案：Leaflet、Geoserver服务器、Openlayers平台 GIS功能： 地图可视化与制图 发现地理事物的隐含关系 探寻事物的空间分布规律演变趋势 采集、存储及共享地理数据 WebGIS的优点有： 传播的广远性，应用广泛 较好的跨平台 费用低廉 分布式服务体系 基于Internet标准 WebGIS的功能： 空间数据发布 空间查询检索和联机处理 空间数据可视化 空间模型分析服务 Web资源共享 WebGIS开发平台： 商业平台 开源平台 高德 百度地图平台 基于WebGL或其他图形语言的底层开发 第二章 TOMCAT默认端口号为8080 arcgis server默认端口号为6080 HTTP协议默认端口号是80 HTTPS默认端口号是443 五种状态码： 1xx：信息提示，表示请求已被成功接收，继续处理 2xx：请求被成功提交。 3xx：客户端被重定向到其他资源。 4xx：客户端错误状态码，格式错误或者不存在资源。 5xx：描述服务器内部错误。 常见的状态码描述如下： 200：客户端请求成功，是最常见的状态。 302：重定向。 404：请求资源不存在，是最常见的状态。 400：客户端请求有语法错误，不能被服务器所理解。 401：请求未经授权。 403：服务器收到请求，但是拒绝提供服务。 500：服务器内部错误，是最常见的状态。 Web服务器有：Apache、Tomcat、IIS 浏览器前端编程技术：Javascript、Flex、Siverlight WebGIS的基本架构包括： 客户端 Web服务器 GIS服务器 空间数据库服务器 一个Web应用的工作流程是使用Web客户端在地址栏上输入URL地址，Web服务器收到请求后，搜索服务器上存储的文件或脚本，并将执行结果返回给Web客户端，收到相应结果，并把返回的结果渲染和显示出来。 HTTP(HyperText Transfer Protocol)协议是一种超文本传输协议，定义了一套进行超文本传输协议请求和应答时所遵循的协议规范，它允许将HTML（超文本标记语言）文档从Web服务器传送到Web浏览器。 以下HTTP请求消息，可以得到该请求是POST请求(方法)，请求的服务器文件是该域名根目录下的test.php文件，第三部分说明使用的是HTTP1.1协议版本，请求主机地址是www.test.com。 1234567POST /test.php HTTP/1.1 //请求行HOST：www.test.com //请求头User-Agent：Mozilla/5.0 （windows NT 6.1；rv：15.0）Gecko/20100101 Firefox/15.0 //空白行，代表请求头结束Username=admin&amp;password=admin //请求正文 XML转换json 1234567891011121314151617181920&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt;&lt;title&gt;Everyday Italian&lt;/title&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;&lt;year&gt;2005&lt;/year&gt;&lt;price&gt;30.00&lt;/price&gt;&lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt;&lt;title&gt;Harry Potter&lt;/title&gt;&lt;author&gt;J K. Rowling&lt;/author&gt;&lt;year&gt;2005&lt;/year&gt;&lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt;&lt;title&gt;Learning XML&lt;/title&gt;&lt;author&gt;Erik T. Ray&lt;/author&gt;&lt;year&gt;2003&lt;/year&gt;&lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt; 答案： 123456789101112131415161718192021222324252627&#123; &quot;bookstore&quot;: &#123; &quot;book&quot;: [ &#123; &quot;-category&quot;: &quot;COOKING&quot;, &quot;title&quot;: &quot;Everyday Italian&quot;, &quot;author&quot;: &quot;Giada De Laurentiis&quot;, &quot;year&quot;: &quot;2005&quot;, &quot;price&quot;: &quot;30.00&quot; &#125;, &#123; &quot;-category&quot;: &quot;CHILDREN&quot;, &quot;title&quot;: &quot;Harry Potter&quot;, &quot;author&quot;: &quot;J K. Rowling&quot;, &quot;year&quot;: &quot;2005&quot;, &quot;price&quot;: &quot;29.99&quot; &#125;, &#123; &quot;-category&quot;: &quot;WEB&quot;, &quot;title&quot;: &quot;Learning XML&quot;, &quot;author&quot;: &quot;Erik T. Ray&quot;, &quot;year&quot;: &quot;2003&quot;, &quot;price&quot;: &quot;39.95&quot; &#125; ] &#125;&#125; 第三章 服务器端WebGIS实现方式的优点： 瘦客户端，不需要安装插件 可以执行复杂的空间分析与数据处理 CGI模式具有跨平台能力 服务器端WebGIS实现方式的缺点：服务器负担重 客户端WebGIS实现方式的优点： 服务器端压力轻 客户端地图操作响应速度快 服务器和网络传输负担轻 在栅格切片中第（level i）中的一张切片到第（level i+1）级中变成4张 ArcGIS的矢量瓦片格式是PBF，它是一种基于协议缓冲（protocol Buffer）技术的紧凑的二进制格式。 WebGIS系统的组成：客户端、通信协议、服务器 服务器端WebGIS实现方式：CGI、Server API 客户端WebGIS实现方式：GIS plugin、Java Applet、ActiveX 矢量瓦片和栅格瓦片比优势有： 矢量瓦片切片速度快，栅格瓦片切片速度慢 矢量瓦片数据量小，栅格瓦片数据量大 矢量瓦片在客户端绘制地图，渲染速度快；栅格瓦片在服务器端制作地图，前端渲染速度不及矢量切片 矢量瓦片可以在前端修改地图样式，栅格瓦片的地图样式不能修改。 矢量切片与栅格切片原理一样，只是切割的数据内容不一样 栅格切片的地图瓦片是预先在服务器端生成的。 矢量切片主要的三种格式是GeoJson、TopoJson、Mapbox Vector Tile（MVT）","tags":[]},{"title":"Vue + ArcGIS api 自学笔记","date":"2021-07-22T09:54:48.978Z","path":"2021/07/22/Vue + ArcGIS api 自学笔记/","text":"Vue 与 ArcGIS api 结合，基于Vue-cli 和 esri loader 学习笔记 2020.3.19更 3.x加载 arcgis server 地图服务 4.x加载 arcgis server 地图服务 2020.03.28更 实时同步范围+坐标 小部件 图层控制 + 筛选 设置范围+坐标 2020.04.11更 书签+图层列表+测量工具+图例+鹰眼+地图切换. 几何处理-绘图（点，多点，线，箭头线，面，徒手线，徒手面，圆，矩形） 2020.05.01更 唯一值渲染、简单渲染、分级渲染、热力图渲染 echarts绘制map，添加图表 2021.05.11更 空间查询、属性查询 官方API是最好的学习文档","tags":[]},{"title":"Vue + ArcGIS api 实时同步范围+坐标","date":"2021-07-22T09:54:48.975Z","path":"2021/07/22/Vue + ArcGIS api 实时同步范围+坐标/","text":"修改中心坐标需要是地理坐标系 功能 ID 函数 同步范围 #extent-change showExtent 同步坐标 ‘#MouseMove’ showCoordinates 变量 含义 extent_tag 绑定范围的显示标签 xyText 绑定坐标的显示标签 extent_zdy 修改范围的值 xy_zdy 修改XY的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.28&#x27; &#125;) this.createMap()&#125;,methods: &#123; createMap: function() &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;esri/geometry/Extent&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;dojo/query&#x27;, &#x27;esri/toolbars/navigation&#x27;, &#x27;esri/geometry/Point&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, Extent, ArcGISDynamicMapServiceLayer, query, Navigation, Point]) =&gt; &#123; var tjUAVurl = &#x27;http://localhost:6080/arcgis/rest/services/Eco/BJ_td_gd_nyd/MapServer&#x27; var map = new Map(&#x27;map&#x27;, &#123; extent: new Extent(&#123; xmin: 114.4134760856628, ymin: 40.13100080490112, xmax: 118.36547288894677, ymax: 41.64383821487438, spatialReference: &#123; wkid: 4326 &#125; &#125;), logo: false &#125;) var tjUAVLayer = new ArcGISDynamicMapServiceLayer(tjUAVurl) map.addLayer(tjUAVLayer) // *************************************************************************************** // var that = this function showExtent() &#123; // console.log(that.extent_tag) var extent = map.extent var s = [] s[0] = &#x27;XMin:&#x27; + extent.xmin s[1] = &#x27;YMin:&#x27; + extent.ymin s[2] = &#x27;XMax:&#x27; + extent.xmax s[3] = &#x27;YMax:&#x27; + extent.ymax that.extent_tag = s that.extent_zdy = map.extent &#125; function showCoordinates(event) &#123; var mp = event.mapPoint that.xy_zdy = mp that.xyText = mp.x + &#x27;,&#x27; + mp.y &#125; showExtent() map.on(&#x27;extent-change&#x27;, showExtent) map.on(&#x27;MouseMove&#x27;, showCoordinates) &#125;) &#125;&#125;","tags":[]},{"title":"Vue + ArcGIS api 设置范围+坐标","date":"2021-07-22T09:54:48.973Z","path":"2021/07/22/Vue + ArcGIS api 设置范围+坐标/","text":"修改中心坐标需要是地理坐标系 功能 ID 函数 控制修改中心坐标的Dialog的显示 #setting-extent-xy dialogSetXYVisible 实现修改中心坐标 ‘#XYDialogOK’ btnSettingXY 控制修改范围的Dialog的显示 #setting-extent dialogSetExtentVisible 实现修改范围 ‘#extentDialogOK’ btnSettingExtent 变量 含义 extent_zdy 修改范围的值 xy_zdy 修改XY的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.28&#x27; &#125;) this.createMap()&#125;,methods: &#123; createMap: function() &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;esri/geometry/Extent&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;dojo/query&#x27;, &#x27;esri/toolbars/navigation&#x27;, &#x27;esri/geometry/Point&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, Extent, ArcGISDynamicMapServiceLayer, query, Navigation, Point]) =&gt; &#123; var tjUAVurl = &#x27;http://localhost:6080/arcgis/rest/services/Eco/BJ_td_gd_nyd/MapServer&#x27; var map = new Map(&#x27;map&#x27;, &#123; extent: new Extent(&#123; xmin: 114.4134760856628, ymin: 40.13100080490112, xmax: 118.36547288894677, ymax: 41.64383821487438, spatialReference: &#123; wkid: 4326 &#125; &#125;), logo: false &#125;) var tjUAVLayer = new ArcGISDynamicMapServiceLayer(tjUAVurl) map.addLayer(tjUAVLayer) var that = this function dialogSetXYVisible() &#123; that.centerDialogVisible = true &#125; function btnSettingXY() &#123; if (map.extent.spatialReference.wkid === 4326) &#123; console.log(map.extent.spatialReference.wkid) var point = new Point(that.xy_zdy.x, that.xy_zdy.y) map.centerAt(point) that.opensuccess() &#125; else &#123; that.openWarning() &#125; &#125; function dialogSetExtentVisible() &#123; that.centerDialogVisible_extent = true &#125; function btnSettingExtent() &#123; map.setExtent(that.extent_zdy) that.opensuccess() &#125; // *************************************************************************************** // query(&#x27;#setting-extent-xy&#x27;).on(&#x27;click&#x27;, dialogSetXYVisible) query(&#x27;#XYDialogOK&#x27;).on(&#x27;click&#x27;, btnSettingXY) query(&#x27;#setting-extent&#x27;).on(&#x27;click&#x27;, dialogSetExtentVisible) query(&#x27;#extentDialogOK&#x27;).on(&#x27;click&#x27;, btnSettingExtent) &#125;) &#125;, opensuccess() &#123; this.$message(&#123; message: &#x27;success&#x27;, type: &#x27;success&#x27; &#125;) &#125;, openWarning() &#123; this.$message(&#123; message: &#x27;非地理坐标系&#x27;, type: &#x27;warning&#x27; &#125;) &#125;&#125;","tags":[]},{"title":"Unbutu系统创建及初始配置","date":"2021-07-22T09:54:48.971Z","path":"2021/07/22/Unbutu系统创建及初始配置/","text":"创建 1. 创建2. next 3. 稍后 4. Ununtu 64位，不是Ubuntu 5. 更改位置，选择一个至少20G的磁盘 6. next直到完成。系统初始化设置 1. 选择中文，安装Ubuntu2. 选择镜像，框中的根据电脑配置设置即可，左侧的打印机点击，然后移除 3. 然后让他安装就行。联网状态下，会安装一些基本软件，不相等的话，可以选择前面的建议安装，软件自己部署即可。4. 安装结束后，如果卡在进系统的时候，就在VM顶部选项卡里强制关机一下，然后重新启动就可以了5. 第一次进来的时候，分辨率是不会自适应的。需要安装open-vm-tools-desktop。可以通过VM下面的提示点击安装也可以在虚拟机中的终端安装 6. 更新apt，用来安装软件。 sudo apt-get update 出现这个说明正常安装，如果不能正常安装，更改软件源。然后重新更新即可，如果是无网络状态，解决 7. 安装编辑器Vimsudo apt-get install vim，Ubuntu18.0.4自带了gedit。 8. Ubuntu 已安装SSH client，还需要安装 SSH server sudo apt-get install openssh-server 9. 登录本机，首次登陆会有提示信息 ssh localhost 10. 退出`exit` 11. 创建.ssh目录`cd ~/.ssh/` 12. 生成密钥`ssh-keygen -t rsa` 一路回车 13. 配置SSH无密码登录`cat ./id_rsa.pub &gt;&gt; ./authorized_keys`加入授权，重新登录验证，不再需要输入密码","tags":[]},{"title":"QueryTask属性查询+空间查询（附样例源码）","date":"2021-07-22T09:54:48.969Z","path":"2021/07/22/QueryTask属性查询+空间查询（附样例源码）/","text":"效果图 结合空间查询和属性查询的代码，加上bootstarp控制格式，添加jq组件特效 部分代码1. load12345678910111213141516171819202122232425262728293031323334353637383940414243// 初始化字段 function setField(fieldAliases) &#123; var th_html = &quot;&lt;th scope=&#x27;col&#x27; title=&#x27;President Number&#x27;&gt;ID&lt;/th&gt; &quot;; for (let key in fieldAliases) &#123; th_html += &quot;&lt;th scope=&#x27;col&#x27;&gt;&quot; + key + &quot;&lt;/th&gt;&quot; &#125; $(&quot;#th_rr&quot;).html(th_html); &#125; // 设置赋值符号 function setSym(type) &#123; switch (type) &#123; case &quot;esriGeometryPoint&quot;: return markerSymbol; break; case &quot;esriGeometryLine&quot;: return lineSymbol; break; case &quot;esriGeometryPolygon&quot;: return fillSymbol; break; &#125; &#125; // table 内容 function setTable(queryResult) &#123; var tbodyStr = &quot;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; var graphic = queryResult.features[i]; graphic.setSymbol(setSym(queryResult.geometryType)); map.graphics.add(graphic); tbodyStr += &quot;&lt;tr&gt;&quot;; tbodyStr += &quot;&lt;td&gt;&quot; + i + &quot;&lt;/td&gt;&quot;; for (let j = 0; j &lt; filts.length; j++) &#123; tbodyStr += &quot;&lt;td&gt;&quot; + graphic.attributes[filts[j]] + &quot;&lt;/td&gt;&quot;; &#125; tbodyStr += &quot;&lt;/tr&gt;&quot;; &#125; $(&quot;#tbody_rr&quot;).html(tbodyStr); &#125; // table筛选功能 function tableChoose() &#123; $(&#x27;table&#x27;).filterTable(&#123; inputSelector: &#x27;#input-filter&#x27; &#125;); &#125; 2. power123456789101112131415161718192021222324252627282930313233343536373839404142434445//属性查询事件 on(dom.byId(&quot;select&quot;), &quot;keypress&quot;, function (e) &#123; var query = new Query(); query.where = $(&quot;#select&quot;).val(); queryTask.execute(setQuery(query), showQueryResult); &#125;) // 空间查询 var toolbar = new Draw(map); query(&quot;button&quot;).on(&quot;click&quot;, function (event) &#123; map.graphics.clear(); var value = this.innerHTML; switch (value) &#123; case &quot;点&quot;: &#123; toolbar.activate(Draw.POINT, &#123; showTooltips: true &#125;) break; &#125; case &quot;线&quot;: &#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips: true &#125;) break; &#125; case &quot;面&quot;: &#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips: true &#125;) break; &#125; case &quot;X&quot;: &#123; toolbar.deactivate(); break; &#125; &#125; &#125;) // 绘图事件 on(toolbar, &quot;draw-complete&quot;, function (result) &#123; toolbar.deactivate(); var query = new Query(); query.geometry = result.geometry; queryTask.execute(setQuery(query), showQueryResult); &#125;); 3. Static12345678910111213141516171819// 设置筛选公共参数 function setQuery(query) &#123; query.returnGeometry = true; query.outFields = filts; return query; &#125; // 显示 function showQueryResult(queryResult) &#123; console.log(queryResult) setField(queryResult.fieldAliases) if (queryResult.features.length == 0) &#123; $(&quot;#divShowResult&quot;).html(&quot;&quot;); return; &#125; if (queryResult.features.length &gt;= 1) setTable(queryResult) tableChoose(); &#125; 源码","tags":[]},{"title":"Openlayer加载GeoServer发布的WTMS","date":"2021-07-22T09:54:48.967Z","path":"2021/07/22/Openlayer加载GeoServer发布的WTMS/","text":"CDN12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://openlayers.org/en/v3.20.1/css/ol.css&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;https://openlayers.org/en/v3.20.1/build/ol.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 1. 点击Logo -》版本号 -》查看自己的wms地址 2. 查看WTMS，右键查看源码 3. 将所有script标签中的代码复制下来，删除红框，添加绿框 4.修改baseUrl1var baseUrl = &#x27;http://localhost:8089/geoserver/gwc/service/wmts&#x27;; 完整代码 注意：script要放在html后123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://openlayers.org/en/v3.20.1/css/ol.css&quot; type=&quot;text/css&quot;&gt; &lt;script src=&quot;https://openlayers.org/en/v3.20.1/build/ol.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;WTMS&lt;/h2&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/test.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; test.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function init() &#123; var gridsetName = &#x27;landsat_zdy&#x27;; var gridNames = [&#x27;landsat_zdy:0&#x27;, &#x27;landsat_zdy:1&#x27;, &#x27;landsat_zdy:2&#x27;, &#x27;landsat_zdy:3&#x27;, &#x27;landsat_zdy:4&#x27;, &#x27;landsat_zdy:5&#x27;]; var baseUrl = &#x27;http://localhost:8089/geoserver/gwc/service/wmts&#x27;; var style = &#x27;&#x27;; var format = &#x27;image/png&#x27;; var infoFormat = &#x27;text/html&#x27;; var layerName = &#x27;webgis_test:LC08_L1TP_123033_20170523_20170526_01_T1_B1&#x27;; var projection = new ol.proj.Projection(&#123; code: &#x27;EPSG:32650&#x27;, units: &#x27;m&#x27;, axisOrientation: &#x27;neu&#x27; &#125;); var resolutions = [2609.2074758118906, 1304.6037379059453, 652.3018689529727, 326.1509344764863, 163.07546723824316, 81.53773361912158]; baseParams = [&#x27;VERSION&#x27;, &#x27;LAYER&#x27;, &#x27;STYLE&#x27;, &#x27;TILEMATRIX&#x27;, &#x27;TILEMATRIXSET&#x27;, &#x27;SERVICE&#x27;, &#x27;FORMAT&#x27;]; params = &#123; &#x27;VERSION&#x27;: &#x27;1.0.0&#x27;, &#x27;LAYER&#x27;: layerName, &#x27;STYLE&#x27;: style, &#x27;TILEMATRIX&#x27;: gridNames, &#x27;TILEMATRIXSET&#x27;: gridsetName, &#x27;SERVICE&#x27;: &#x27;WMTS&#x27;, &#x27;FORMAT&#x27;: format &#125;; // 构建layer的source function constructSource() &#123; var url = baseUrl + &#x27;?&#x27; for (var param in params) &#123; if (baseParams.indexOf(param.toUpperCase()) &lt; 0) &#123; url = url + param + &#x27;=&#x27; + params[param] + &#x27;&amp;&#x27;; &#125; &#125; url = url.slice(0, -1); var source = new ol.source.WMTS(&#123; url: url, layer: params[&#x27;LAYER&#x27;], matrixSet: params[&#x27;TILEMATRIXSET&#x27;], format: params[&#x27;FORMAT&#x27;], projection: projection, tileGrid: new ol.tilegrid.WMTS(&#123; tileSize: [256, 256], extent: [166021.44309607794, 0.0, 833978.556903922, 9351399.593309816], origin: [166021.44309607794, 9351399.593309816], resolutions: resolutions, matrixIds: params[&#x27;TILEMATRIX&#x27;] &#125;), style: params[&#x27;STYLE&#x27;], wrapX: true &#125;); return source; &#125; var layer = new ol.layer.Tile(&#123; source: constructSource() &#125;); var view = new ol.View(&#123; center: [0, 0], zoom: 2, projection: projection, extent: [166021.44309607794, 0.0, 833978.556903922, 9351399.593309816] &#125;); var map = new ol.Map(&#123; layers: [layer], target: &#x27;map&#x27;, view: view &#125;); map.getView().fit([320685.0, 4187385.0, 553515.0, 4424415.0], map.getSize());&#125;init(); 结果","tags":[]},{"title":"Openlayer加载GeoServer发布的WMS","date":"2021-07-22T09:54:48.965Z","path":"2021/07/22/Openlayer加载GeoServer发布的WMS/","text":"CDN12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://openlayers.org/en/v3.20.1/css/ol.css&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;https://openlayers.org/en/v3.20.1/build/ol.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 1. 点击Logo -》版本号 -》查看自己的wms地址 2. 设置范围将图中的范围以此填写到 1var extent = [924029.4389153644, 3148870.100464709, 975418.6183263285, 3193088.3305712156]; 3. 设置sourse12345678source: new ol.source.TileWMS(&#123; url: &#x27;http://localhost:8089/geoserver/webgis_test/wms&#x27;, params: &#123; &#x27;LAYERS&#x27;: &#x27;webgis_test:beijing&#x27;, &#x27;TILED&#x27;: false &#125;, serverType: &#x27;geoserver&#x27; &#125;) url为刚才找到的wms地址 ‘LAYERS’的值为图层名称 4. 定义地图对象123456789101112var map = new ol.Map(&#123; layers: tiled, target: &#x27;map&#x27;, view: new ol.View(&#123; projection: &#x27;EPSG:3857&#x27;, zoom: 4 &#125;), controls: ol.control.defaults(&#123; attributionOptions: &#123; collapsible: false &#125; &#125;) 修改projection: &#39;EPSG:3857&#39;,中的3857为图层的坐标代码 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://openlayers.org/en/v3.20.1/css/ol.css&quot; type=&quot;text/css&quot;&gt; &lt;script src=&quot;https://openlayers.org/en/v3.20.1/build/ol.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body onload=&quot;init()&quot;&gt; &lt;h2&gt;WMS&lt;/h2&gt; &lt;div id=&quot;map&quot; style=&quot;height: 900px; width: 100%;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //基于openlayers3 function init() &#123; //WMS的边界范围 var extent = [924029.4389153644, 3148870.100464709, 975418.6183263285, 3193088.3305712156]; var tiled = [ new ol.layer.Tile(&#123; source: new ol.source.TileWMS(&#123; url: &#x27;http://localhost:8089/geoserver/webgis_test/wms&#x27;, params: &#123; &#x27;LAYERS&#x27;: &#x27;webgis_test:beijing&#x27;, &#x27;TILED&#x27;: false &#125;, serverType: &#x27;geoserver&#x27; &#125;) &#125;) ]; //定义地图对象 var map = new ol.Map(&#123; layers: tiled, target: &#x27;map&#x27;, view: new ol.View(&#123; projection: &#x27;EPSG:3857&#x27;, zoom: 4 &#125;), controls: ol.control.defaults(&#123; attributionOptions: &#123; collapsible: false &#125; &#125;) &#125;); map.getView().fit(extent, map.getSize()); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果","tags":[]},{"title":"Openlayer + GeoServer 入门学习笔记（更新中ing）","date":"2021-07-22T09:54:48.962Z","path":"2021/07/22/Openlayer + GeoServer 入门学习笔记（更新中ing）/","text":"学习链接 GeoServer发布服务 WMS和WTMS Openlayer加载 加载WMS 加载WTMS 3.17更","tags":[]},{"title":"Nodejs爬虫实战","date":"2021-07-22T09:54:48.960Z","path":"2021/07/22/Nodejs爬虫实战/","text":"Nodejs爬虫实战（一）Nodejs爬虫实战（二）Nodejs爬虫实战（三）Nodejs爬虫实战（四）Nodejs爬虫实战（五）Nodejs爬虫实战（六）Nodejs爬虫实战（七）数据可视化","tags":[]},{"title":"Nodejs爬虫实战（一）","date":"2021-07-22T09:54:48.958Z","path":"2021/07/22/Nodejs爬虫实战（一）/","text":"1. 搭建本地服务器 const为ES6新增量，可以理解为常量，一旦赋值初始化，遍不能修改 引入http模块 创建server，request为发送的请求，response为返回的数据 response.write(‘pachong’);屏幕打印 实质上是node帮我们创建的HTML标签 response.end();让响应的代码结束（不可缺） ###### 完整代码 指定9000端口 const http = require(&#39;http&#39;); http.createServer((request,response)=&gt;&#123; response.write(&#39;pachong&#39;); response.end(); &#125;).listen(9000);","tags":[]},{"title":"Nodejs爬虫实战（五）","date":"2021-07-22T09:54:48.956Z","path":"2021/07/22/Nodejs爬虫实战（五）/","text":"1. 抓取标签内容 引入模块 新模块jsdom中的JSDOM 创建对象 let DOM = new JSDOM(html); let document = DOM.window.document; dom操作 document.querySelector(&#39;.tm-count&#39;).innerHTML ###### 完整代码 var index = 0; const fs = require(&#39;fs&#39;); const url = require(&#39;url&#39;); const gbk = require(&#39;gbk&#39;); const JSDOM = require(&#39;jsdom&#39;).JSDOM; GetUrl(&#39;https://detail.tmall.com/item.htm?id=548466958386&amp;ali_refid=a3_430583_1006:1103419234:N:%E5%8D%8E%E4%B8%BA:bb84ee4c8f67c7b202d725187b7ad429&amp;ali_trackid=1_bb84ee4c8f67c7b202d725187b7ad429&amp;spm=a230r.1.14.1&amp;sku_properties=5919063:6536025;12304035:116177&#39;,(data)=&gt;&#123; var html = gbk.toString(&#39;utf-8&#39;,data); let DOM = new JSDOM(html); let document = DOM.window.document; console.log(document.querySelector(&#39;.tm-count&#39;).innerHTML) &#125;) function GetUrl(sUrl,success)&#123; index++; var urlObj = url.parse(sUrl); var http =&#39;&#39;; if(urlObj.protocol == &#39;http:&#39;)&#123; http = require(&#39;http&#39;); &#125; else&#123; http = require(&#39;https&#39;); &#125; let req = http.request(&#123; &#39;hostname&#39;:urlObj.hostname, &#39;path&#39;:urlObj.path &#125;,res=&gt;&#123; if(res.statusCode == 200)&#123; var arr = []; var str = &#39;&#39;; res.on(&#39;data&#39;,buffer=&gt;&#123; arr.push(buffer); //str +=buffer; &#125;); res.on(&#39;end&#39;,()=&gt;&#123; let b = Buffer.concat(arr); success &amp;&amp; success(b); &#125;) &#125; else if(res.statusCode == 302 || res.statusCode == 301)&#123; console.log(`第$&#123;index&#125;次重定向`,res.headers.location); GetUrl(res.headers.location,success) &#125; &#125;); req.end(); req.on(&#39;error&#39;,()=&gt;&#123; console.log(&#39;404&#39;); &#125;) &#125;","tags":[]},{"title":"Nodejs爬虫实战（四）","date":"2021-07-22T09:54:48.954Z","path":"2021/07/22/Nodejs爬虫实战（四）/","text":"1. 淘宝天猫页面重定向 尝试抓取淘宝页面 打印res.statusCode,res.headers.location res.statusCode返回的状态码; res.headers.location返回的地址 发现状态码为302，百度HTTP状态码 302 Move Temporarily 请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 淘宝返回给我们的只是一个临时的html页面，并不是真正的还有数据的页面。 判断是否重定向，递归寻找真页面 if(res.statusCode == 302 || res.statusCode == 301)&#123; console.log(`第$&#123;index&#125;次重定向`,res.headers.location); GetUrl(res.headers.location,success) &#125; 2. 转码 拿到了真实页面之后，打开发现有编码错误的问题 引用gbk模块 gbk提供了编码转换的方法 gbk.toString(&#39;utf-8&#39;,data); 结束 ###### 完整代码 var index = 0; const fs = require(&#39;fs&#39;); const url = require(&#39;url&#39;); const gbk = require(&#39;gbk&#39;); GetUrl(&#39;https://detail.tmall.com/item.htm?spm=a230r.1.14.6.68624507tWuF7E&amp;id=560257961625&amp;cm_id=140105335569ed55e27b&amp;abbucket=18&amp;sku_properties=10004:709990523&#39;,(data)=&gt;&#123; var html = gbk.toString(&#39;utf-8&#39;,data); console.log(html) //console.log(&#39;终于我走出来了&#39;) //fs.writeFile(&#39;iponex.html&#39;,data); //console.log(str) &#125;) function GetUrl(sUrl,success)&#123; index++; var urlObj = url.parse(sUrl); var http =&#39;&#39;; if(urlObj.protocol == &#39;http:&#39;)&#123; http = require(&#39;http&#39;); &#125; else&#123; http = require(&#39;https&#39;); &#125; let req = http.request(&#123; &#39;hostname&#39;:urlObj.hostname, &#39;path&#39;:urlObj.path &#125;,res=&gt;&#123; if(res.statusCode == 200)&#123; var arr = []; var str = &#39;&#39;; res.on(&#39;data&#39;,buffer=&gt;&#123; arr.push(buffer); //str +=buffer; &#125;); res.on(&#39;end&#39;,()=&gt;&#123; let b = Buffer.concat(arr); success &amp;&amp; success(b); &#125;) &#125; else if(res.statusCode == 302 || res.statusCode == 301)&#123; console.log(`第$&#123;index&#125;次重定向`,res.headers.location); GetUrl(res.headers.location,success) &#125; //console.log(res.statusCode,res.headers.location) &#125;); req.end(); req.on(&#39;error&#39;,()=&gt;&#123; console.log(&#39;404了，哥们&#39;); &#125;) &#125;","tags":[]},{"title":"Nodejs爬虫实战（三）","date":"2021-07-22T09:54:48.952Z","path":"2021/07/22/Nodejs爬虫实战（三）/","text":"1. 抽取函数处理 引入模块 http协议和https协议两种，既有不同，那么模块引入创建的变量自然不同 url对象的parse方法能获得http或者https协议的信息。以http://example.com:8080/one?a为例打印。 &#123; protocol : &#39;http:&#39; , auth : null , host : &#39;example.com:8080&#39; , port : &#39;8080&#39; , hostname : &#39;example.com&#39; , hash : null , search : &#39;?a=index&amp;t=article&amp;m=default&#39;, query : &#39;a=index&amp;t=article&amp;m=default&#39;, pathname : &#39;/one&#39;, path : &#39;/one?a=index&amp;t=article&amp;m=default&#39;, href : &#39;http://example.com:8080/one?a=index&amp;t=article&amp;m=default&#39; &#125; protocol属性保存了协议 if(urlObj.protocol == &#39;http:&#39;)&#123; http = require(&#39;http&#39;); &#125; else&#123; http = require(&#39;https&#39;); &#125; 处理error页面 req.on(&#39;error&#39;,()=&gt;&#123; console.log(&#39;404&#39;); &#125;) ####### 完整代码 const fs = require(&#39;fs&#39;); const url = require(&#39;url&#39;) GetUrl(&#39;https://detail.tmall.com/item.htm?spm=a230r.1.14.6.68624507tWuF7E&amp;id=560257961625&amp;cm_id=140105335569ed55e27b&amp;abbucket=18&amp;sku_properties=10004:709990523&#39;,data=&gt;&#123; fs.writeFile(&#39;iponex.html&#39;,data); &#125;) function GetUrl(sUrl,success)&#123; var urlObj = url.parse(sUrl); var http =&#39;&#39;; if(urlObj.protocol == &#39;http:&#39;)&#123; http = require(&#39;http&#39;); &#125; else&#123; http = require(&#39;https&#39;); &#125; let req = http.request(&#123; &#39;hostname&#39;:urlObj.hostname, &#39;path&#39;:urlObj.path &#125;,res=&gt;&#123; console.log(res) var arr = []; res.on(&#39;data&#39;,buffer=&gt;&#123; arr.push(buffer); &#125;); res.on(&#39;end&#39;,()=&gt;&#123; let b = Buffer.concat(arr); success &amp;&amp; success(b); &#125;) &#125;); req.end(); req.on(&#39;error&#39;,()=&gt;&#123; console.log(&#39;404&#39;); &#125;) &#125;","tags":[]},{"title":"Nodejs爬虫实战（七）","date":"2021-07-22T09:54:48.950Z","path":"2021/07/22/Nodejs爬虫实战（七）数据可视化/","text":"完整项目代码1. HTML部分 创建一个输入框，确定按钮 数据可视化的盒子 引入echarts.min.js和ajax.js 2. NodeJS部分 创建本地服务器，端口9000 引入express模块，框架搭建 3. echarts_show.js btn的点击事件 btn[&#39;onclick&#39;] = x =&gt; &#123;&#125; ajax发送get请求 将数据处理为echarts图表的表达 var json = eval(&#39;(&#39; + data + &#39;)&#39;).need; var arr = [] json.forEach(data =&gt; &#123; arr.push(&#123; name: data.w, value: data.c &#125;) &#125;); 4. ajax.js部分 引入封装好的js文件","tags":[]},{"title":"Nodejs爬虫实战（六）","date":"2021-07-22T09:54:48.948Z","path":"2021/07/22/Nodejs爬虫实战（六）/","text":"1. 处理数据 上一步获取结果中含有p标签，用正则筛选，去掉标签，只留下文本。 var myHtml = document.querySelector(&#39;.read-content&#39;).innerHTML.replace(/&lt;[^&gt;]+&gt;/g,&#39;&#39;) 统计词的个数首先需要文本分词 分词模块segment(盘古分词组件)，实例化，使用默认的识别模块及字典，载入字典文件需要1秒，仅初始化时执行一次即可 let seg = new Segment(); seg.useDefault(); 开始分词。 var arr = seg.doSegment(myHtml); 结果其中w表示内容，p表示词性，词性收录 [ &#123; w: &#39;这是&#39;, p: 0 &#125;, &#123; w: &#39;一个&#39;, p: 2097152 &#125;, &#123; w: &#39;基于&#39;, p: 262144 &#125;, &#123; w: &#39;Node.js&#39;, p: 8 &#125;, &#123; w: &#39;的&#39;, p: 8192 &#125;, &#123; w: &#39;中文&#39;, p: 1048576 &#125;, &#123; w: &#39;分词&#39;, p: 4096 &#125;, &#123; w: &#39;模块&#39;, p: 1048576 &#125;, &#123; w: &#39;。&#39;, p: 2048 &#125; ] 去掉词性为2048的标点 var myarr = []; arr.forEach(data=&gt;&#123; if(data.p !=2048)&#123; myarr.push(data.w) &#125; &#125;); JSON格式统计词内容 var myJson = &#123;&#125;; myarr.forEach(data=&gt;&#123; if(!myJson[data])&#123; myJson[data] = 1; &#125; else&#123; myJson[data]++; &#125; &#125;); 去掉其中只出现一次的 let arr2 = []; for(let word in myJson)&#123; if(myJson[word]&lt;=1)&#123; continue; &#125; arr2.push(&#123; w:word, c:myJson[word] &#125;) &#125;; 结果排序 arr2.sort((json1,json2)=&gt;json2.c-json1.c); ###### 完整代码 var index = 0; const fs = require(&#39;fs&#39;); const url = require(&#39;url&#39;); const gbk = require(&#39;gbk&#39;); const JSDOM = require(&#39;jsdom&#39;).JSDOM; const Segment = require(&#39;segment&#39;); let seg = new Segment(); seg.useDefault(); GetUrl(&#39;https://www.xs8.cn/chapter/7373911103301701/19794192502339694&#39;,(data)=&gt;&#123; let DOM = new JSDOM(data); let document = DOM.window.document; var myHtml = document.querySelector(&#39;.read-content&#39;).innerHTML.replace(/&lt;[^&gt;]+&gt;/g,&#39;&#39;) var arr = seg.doSegment(myHtml); //去掉没用的 var myarr = []; arr.forEach(data=&gt;&#123; if(data.p !=2048)&#123; myarr.push(data.w) &#125; &#125;); //计算个数，存为json格式 var myJson = &#123;&#125;; myarr.forEach(data=&gt;&#123; if(!myJson[data])&#123; myJson[data] = 1; &#125; else&#123; myJson[data]++; &#125; &#125;); //去掉只出现1次的 let arr2 = []; for(let word in myJson)&#123; if(myJson[word]&lt;=1)&#123; continue; &#125; arr2.push(&#123; w:word, c:myJson[word] &#125;) &#125;; arr2.sort((json1,json2)=&gt;json2.c-json1.c); console.log(arr2); &#125;) function GetUrl(sUrl,success)&#123; index++; var urlObj = url.parse(sUrl); var http =&#39;&#39;; if(urlObj.protocol == &#39;http:&#39;)&#123; http = require(&#39;http&#39;); &#125; else&#123; http = require(&#39;https&#39;); &#125; let req = http.request(&#123; &#39;hostname&#39;:urlObj.hostname, &#39;path&#39;:urlObj.path &#125;,res=&gt;&#123; if(res.statusCode == 200)&#123; var str = &#39;&#39;; res.on(&#39;data&#39;,buffer=&gt;&#123; str +=buffer; &#125;); res.on(&#39;end&#39;,()=&gt;&#123; success &amp;&amp; success(str); &#125;) &#125; else if(res.statusCode == 302 || res.statusCode == 301)&#123; console.log(`第$&#123;index&#125;次重定向`,res.headers.location); GetUrl(res.headers.location,success) &#125; &#125;); req.end(); req.on(&#39;error&#39;,()=&gt;&#123; console.log(&#39;404了，哥们&#39;); &#125;) &#125;","tags":[]},{"title":"Nodejs爬虫实战（二）","date":"2021-07-22T09:54:48.946Z","path":"2021/07/22/Nodejs爬虫实战（二）/","text":"1. 尝试抓取数据 引入模块http和fs，fs为文件操作模块 let 声明的变量只在 let 命令所在的代码块内有效 在ES6之前没有块级概念，let在所在区域内有效，和c语言中的变量作用域相同。 var变量，函数内声明的变量作用域是局部的，外部就是全局的。 request中包含很多信息，其中的hostname指域名，path指域名后的路径。 抓取数据必然是要在request请求发送后进行，防止数据阻塞导致 函数提前执行抛异常出现，将操作放在回调函数中。 箭头函数 (ES6语法) 更简短的函数 ES3/5： elements.map(function(element) &#123; return element.length; &#125;); ES6： elements.map((e) =&gt; &#123; return e.length; &#125;); // 当只有一个参数时，可以省略括号 elements.map(e =&gt; &#123; return e.length; &#125;); // 当函数体只有一个 `return` 语句时， //可以省略 `return` 关键字和方法体的花括号 elements.map(e =&gt; e.length); 不绑定this this:面向对象的标志 //ES3/5 //通过将this值分配给封闭的变量，可以解决this问题。 function Person() &#123; //构造函数定义`this`作为自己的实例. this.age = 0; setInterval(function growUp() &#123; // 非严格模式, growUp()定义`this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; &#125;, 1000); &#125; //ES6 //箭头函数不会创建自己的this,只从自己的作用域链的上一层继承this。 function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向 p 实例 &#125;, 1000); &#125; var p = new Person(); 取数据，通过on将data做buffer操作，将读取的结果依此push到数组arr中，通过end回调写文件fs.writeFile，写文件成功打印success var arr =[]; res.on(&#39;data&#39;,buffer=&gt;&#123; arr.push(buffer) &#125;); res.on(&#39;end&#39;,()=&gt;&#123; fs.writeFile(&#39;1.jpg&#39;,b,()=&gt;&#123; console.log(&#39;success&#39;) &#125;) &#125;); 结果发现照片打不开，为什么呢？ 这里存在一个转换的问题，它必须将我们读取到的data转换为二进制流，（将一个.jpg拖进文本编辑器会自动解析为二进制文本） buffer对象已经提供了concat方法帮我们转换为二进制流。 let b = Buffer.concat(arr); 别忘了最后的end() ####### 完整代码 const http = require(&#39;http&#39;); const fs = require(&#39;fs&#39;); let req = http.request(&#123; &#39;hostname&#39;:&#39;img.alicdn.com&#39;, &#39;path&#39;:&#39;/tps/i4/TB1_1BLMXXXXXb3XXXXlkjU.VXX-346-200.jpg_350x1000q90.jpg_.webp&#39; &#125;,res=&gt;&#123; var arr =[]; res.on(&#39;data&#39;,buffer=&gt;&#123; arr.push(buffer) &#125;); res.on(&#39;end&#39;,()=&gt;&#123; let b = Buffer.concat(arr); fs.writeFile(&#39;1.jpg&#39;,b,()=&gt;&#123; console.log(&#39;success&#39;) &#125;) &#125;); &#125;); req.end();","tags":[]},{"title":"JSP总结","date":"2021-07-22T09:54:48.944Z","path":"2021/07/22/JSP总结/","text":"JSP第三章 JSP语法 HTML创建表单表格12345678910&lt;form action=&quot;&lt;%=request.getContextPath() %&gt;/loginservlet&quot; method=&quot;post&quot; &gt; ... 账户： &lt;input type=&quot;text&quot; name=&quot;userid&quot; id=&quot;userid&quot; &gt; 密码： &lt;input type=&quot;Password&quot; name=&quot;userpwd&quot; id=&quot;userpwd&quot;&gt; &lt;input type=submit&gt; &lt;input type=reset&gt;&lt;/form&gt; 123456&lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;login_deal.jsp&quot;&gt; 用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br /&gt; 密码：&lt;input name=&quot;pwd&quot; type=&quot;password&quot; id=&quot;pwd&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;reset&quot; name=&quot;Submit2&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt; 12345678request.setCharacterEncoding(“utf-8&quot;);String username= request.getParameter(&quot;username&quot;);String pwd= request.getParameter(&quot;pwd&quot;);out.println(&quot;用户名为：&quot;+username);if ( pwd!=null &amp;&amp; pwd!=“” ) &#123; int int_pwd = Integer.parseInt(pwd); out.println(&quot;密码为：&quot;+int_pwd); &#125; 123&lt;%String path=request.getContextPath();%&gt;&lt;a href=&quot;&lt;%=path%&gt;/a.jsp&quot;&gt;aaa&lt;/a&gt; 脚本元素： 隐藏注释、&lt;%-- --%&gt; 声明、&lt;%! %&gt;变量可以用访问修饰符如private修饰、可以声明方法，方法能被代码块调用、可以定义静态语句块 脚本片段、&lt;% %&gt;不能添加访问控制修饰符、不能定义方法、不能定义static语句块 表达式、&lt;%= %&gt;不以 ;结尾，out.write(表达式); 指令元素：&lt;%@ %&gt; 页指令 &lt;%@page %&gt; &lt;%@page import=&quot;dao.UserDao&quot; %&gt;导包 设置当前JSP页面的相关信息、一个JSP页面可以包含多个Page指令。 包含指令&lt;%@include %&gt;用于在当前JSP页面中，在当前使用该指令的位置嵌入其他的文件 合并显示两个页面内容、形成一个.java文件，一个.class文件 静态联编两个文件间可以共享同一变量 标签库指令&lt;%@taglib %&gt; 动作元素：&lt; jsp:useBean &gt;、&lt; jsp:setProperty &gt;、&lt; jsp:getProperty &gt;、&lt; jsp:include &gt;、&lt; jsp:forward &gt;、&lt; jsp:param &gt; &lt; jsp:forward page = “next.jsp”/&gt; 发起页面内容不能显示到浏览器中，程序直接跳转next.jsp，显示内容。运行后形成2个.java文件，2个.class文件 &lt; jsp:include page = “next.jsp”/&gt; 发起页面和目标页面都能显示在浏览器中。程序显示两个文件内容。运行后形成2个.java文件，2个.class文件。运行时把两个.class文件内容显示到浏览器中，动态联编。 PS:动态联编，两个文件之间不共享同名变量，因为是两个独立的类。 &lt;jsp:param name=“参数 ” value=“值&quot;/&gt; 用来提供key/value 的信息，不单独使用 &lt;jsp:useBean id=&quot;Goods&quot; scope=&quot;page&quot; class=&quot;handle.shangping&quot;/&gt; id：变量名 scope: 存储范围,page: 页面直接使用，scope指定范围内，id指定的实例不存在，则生成实例 class: 完整类名 &lt;jsp:setProperty&gt;通常与&lt;jsp:useBean&gt;标识一起使用，它将调用Bean中的setXxx()方法给Bean的简单或索引属性赋值。赋的值可以是请求中携带的参数。 &lt;%@include page=”文件”%&gt;与&lt;jsp:include&gt;&lt;/jsp:include&gt;的区别 执行时间上: 前者在翻译阶段 后者在请求处理阶段 引入内容不同 前者引入静态文本(html,jsp),在JSP页面被转化成servlet之前和它融和到一起。 后者引入执行页面或servlet所生成的应答文本。 第四章 内置对象HTTP–无状态的 request对象获取客户浏览器的请求 response对客户浏览器进行响应 session保存着会话期间所需要传递的数据信息，基于用户，随用户的断开而消失，可在多个页面之间传递一个用户的特定信息 application提供应用程序在服务器中运行时的全局信息，实现用户之间共享数据，基于服务器，随服务的关闭而消失，可在一个页面上保留多个用户的信息 out 重定向response对象中的sendRedirect(url)方法 两次请求和响应，不是一个request，地址变化 定时刷新response.setHeader(&quot;Refresh&quot;,&quot;1&quot;); response.setHeader(“Refresh”,“3;url=index.jsp&quot;);跳转新页面 第五章 JavaBean分离静态工作部分和动态工作部分。 1. 值Bean严格遵循了JavaBean的命名规范，通常用来封装表单数据、数据库数据，作为信息的容器 2. 工具Bean可以不遵循JavaBean规范，通常用于封装业务逻辑，数据操作等，例如连接数据库，对数据库进行增、删、改、查和解决中文乱码等操作。 3. JavaBean规范 实现java.io.Serializable接口：实现对象在网络不同操作系统中传输、对象存储等。 JavaBean是一个public的类 类中必须存在一个public无参的构造函数 如果类的成员变量的名字是xxx（通常private），则类中可（不必须）使用两个方法： public 类型 getXxx():用来获取属性xxx pubic void setXxx(类型 值) :用来修改属性xxx 4. JavaBean属性 简单属性（Simple）: getxxx() / setxxx() 索引属性（Indexed）: 通常为数组类型的属性 绑定属性（Bound） 约束属性（Constrained） 5. Bean的存放目录：Bean的源文件连同包放在src下,编译成功的Bean连同包放在站点\\WEB-INF\\classes目录下。 6. 使用 用&lt;jsp:usebean&gt;定义要用的JavaBean 用&lt;jsp:setproperty&gt;存储属性值 用&lt;jsp:getproperty&gt;提取属性值 &lt;jsp:useBean id=&quot;Goods&quot; scope=&quot;page&quot; class=&quot;handle.shangping&quot;/&gt; id：变量名 scope: 存储范围,page: 页面直接使用，scope指定范围内，id指定的实例不存在，则生成实例 取值 获取方式 描述 page 页面直接使用 创建的JavaBean实例只能够在当前的JSP文件中使用，包括通过include静态指令包含的页面中有效 request request对象的getAttribute方法获取 创建的JavaBean实例可以在请求范围内进行存取 session session对象的getAttribute方法获取 创建的JavaBean实例可以在session范围内进行存取 application application对象的getAttribute方法获取 创建的JavaBean实例可以在application范围内进行存取 class: 完整类名 &lt;jsp:setProperty&gt;通常与&lt;jsp:useBean&gt;标识一起使用，它将调用Bean中的setXxx()方法给Bean的简单或索引属性赋值。赋的值可以是请求中携带的参数。 1234567&lt;%-- 单独用 --%&gt;&lt;jsp:useBean ……/&gt; &lt;jsp:setPropery ……/&gt; &lt;%-- 作为子标签：只有bean实例是新创建的情况才执行setProperty --%&gt;&lt;jsp:useBean ……&gt; &lt;jsp:setPropery ……/&gt; &lt;/jsp:useBean&gt; &lt;jsp:getProperty name=&quot;Bean实例名&quot; property=&quot;propertyName&quot;/&gt;读取属性值，输出到页面 第六章 Servlet1. 生命周期 客户端请求服务器，服务器加载Servlet，并创建一个Servlet实例； 容器调用Servlet的init()方法； 容器封装请求响应对象，调用service()方法； 请求处理结束后，将结果返回给容器； 容器将结果返回给客户端进行显示； Web服务器关闭时，调用destroy() 销毁Servlet实例。 2. 会创建doGet / doPost1234protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, I0Exception &#123; doGet(request, response);&#125; 3. 获取客户端提交的信息4. 调用JavaBean处理结果返回客户端第八章JavaWeb应用程序12345678&lt;%--login.jsp--%&gt;&lt;form action=&quot;&lt;%=request.getContextPath() %&gt;/loginservlet&quot; method=&quot;post&quot; &gt; 用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br/&gt; 密码：&lt;input name=&quot;pwd&quot; type=&quot;password&quot; id=&quot;pwd&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;reset&quot; name=&quot;Submit2&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt; 12345678910111213141516171819202122232425//loginservlet.java@WebServlet(&quot;/loginservlet&quot;)public class loginservlet extends HttpServlet &#123; public loginservlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getSession().invalidate();//清除session的所有信息 response.sendRedirect(request.getContextPath() + &quot;/index.jsp&quot;); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); String userid = request.getParameter(&quot;userid&quot;); String userpwd = request.getParameter(&quot;userpwd&quot;); UserDao uDao = new UserDao(); if (uDao.queryByUserNameAndPass(userid, userpwd)) response.sendRedirect(request.getContextPath() +&quot;sy444/index.jsp&quot;); else response.sendRedirect(request.getContextPath() +&quot;sy444/login.jsp&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//UserDao.java public class UserDao &#123; //根据用户名和密码查找，如果找到返回true,否则返回false public boolean queryByUserNameAndPass(String u_name,String u_pass) &#123; Connection conn = null; ResultSet rs = null; PreparedStatement stmt = null; try &#123; conn = JdbcUtils.getCon(); // ②创建连接。 String sql =&quot;SELECT * from user where username=? and password=?&quot;; // ③创建执行SQL语句的对象。 stmt = conn.prepareStatement(sql); stmt.setString(1,u_name); stmt.setString(2,u_pass); // ④执行查询数据。 rs = stmt.executeQuery(); // ⑤处理查询结果。 if (rs.next()) &#123; return true; &#125; &#125; catch (SQLException e) &#123; &#125;finally &#123;JdbcUtils.release(stmt, rs, conn);&#125; return false; &#125; public shangping selsectOne(int id) &#123; Connection conn = null;ResultSet rs = null;PreparedStatement stmt = null; shangping goods = new shangping(); try&#123; conn = JdbcUtils.getCon(); String sql =&quot;SELECT * from shangping WHERE id = ?&quot;; stmt = conn.prepareStatement(sql); stmt.setInt(1,id); rs = stmt.executeQuery(); while(rs.next()) &#123; String name = rs.getString(&quot;name&quot;); int price = rs.getInt(&quot;price&quot;); int number = rs.getInt(&quot;number&quot;); String picture = rs.getString(&quot;picture&quot;); goods = new shangping(id,name,price,number,picture); &#125; return goods; &#125; catch (SQLException e) &#123; &#125;finally &#123;JdbcUtils.release(stmt, rs, conn);&#125; return null; &#125; public boolean addIt(shangping goods, int Num)&#123; Connection conn = null; ResultSet rs = null; PreparedStatement stmt = null; try&#123; conn = JdbcUtils.getCon(); String sql =&quot;insert into car values(? , ? )&quot;; stmt = conn.prepareStatement(sql); stmt.setInt(1,goods.getId()); stmt.setString(2,goods.getName()); int ans = stmt.executeUpdate(); if(ans&gt;0) return true; else return false; &#125; catch (SQLException e) &#123; &#125;finally &#123;JdbcUtils.release(stmt, rs, conn);&#125; return false; &#125; public boolean updateit(int id, int num)&#123; Connection conn = null; ResultSet rs = null; PreparedStatement stmt = null; try&#123; conn = JdbcUtils.getCon(); String sql =&quot;update car set num=? where id=?&quot;; stmt = conn.prepareStatement(sql); stmt.setInt(1,num); stmt.setInt(2,id); int ans = stmt.executeUpdate(); if(ans&gt;0) &#123; return true; &#125;else &#123; return false; &#125; &#125; catch (SQLException e) &#123; &#125;finally &#123;JdbcUtils.release(stmt, rs, conn);&#125; return false; &#125; public boolean delit(int id)&#123; Connection conn = null;ResultSet rs = null;PreparedStatement stmt = null; try&#123; conn = JdbcUtils.getCon(); String sql =&quot;delete from car where id=?&quot;; stmt = conn.prepareStatement(sql); stmt.setInt(1,id); int ans = stmt.executeUpdate(); if(ans&gt;0) &#123; return true; &#125;else &#123; return false; &#125; &#125; catch (SQLException e) &#123; &#125;finally &#123;JdbcUtils.release(stmt, rs, conn);&#125; return false; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637//JdbcUtilspublic class JdbcUtils &#123; // 加载驱动 static &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; &#125; &#125; // 创建连接 public static Connection getCon() &#123; Connection conn = null; String url = &quot;jdbc:mysql://localhost:3306/php?useUnicode=true&amp;characterEncoding=UTF-8&quot;; try &#123; conn = DriverManager.getConnection(url, &quot;root&quot;, &quot;mysqll&quot;); &#125; catch (SQLException e) &#123; &#125; return conn; &#125; // 释放资源 public static void release(Statement st, ResultSet rs, Connection con) &#123; try &#123; if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; &#125; try &#123; if (st != null) st.close(); &#125; catch (SQLException e) &#123; &#125; try &#123; if (con != null) con.close(); &#125; catch (SQLException e) &#123; &#125; &#125;&#125; 分值填空 10*2选择 10*2判断 10*1简答2*5程序 1*40","tags":[]},{"title":"Java程序设计复习总结","date":"2021-07-22T09:54:48.942Z","path":"2021/07/22/Java程序设计复习总结/","text":"Java程序设计期中复习总结第一章 概述1. 应用程序的结构：package import class2. 源文件的扩展名.java，字节文件的扩展名：.class3. Java语言的工作原理：先编译后解释4. 一个源文件中最多可以有一个public类，并且文件名与public类名相同。5. 常用命令javac编译，java运行。6. 一个应用程序最少有一个main方法。 第二章 Java基础1. 标识符命名规则，能够区分合法标识符标识符命名规则 1. 标识符由26个英文字符大小写（a~zA~Z）、数字(0~9)、下划线(_)和美元符号($)组成。 2. 不能以数字开头，不能是关键字。 3. 严格区分大小写。 4. 标识符的可以为任意长度。 2. 所有关键字都是小写3. 基本数据类型的名称、长度和默认值，注意float类型的定义方法：float f=3.14F；float f=3.14f；没有大写或者小写f是错误的。4. while和do-while的区别 do-while语句 后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 while语句 前测试循环语句，即在循环体内的代码被执行之前，就会对出口条件求值。 5. 数组使用length属性获得长度int[] arr=&#123;&quot;11&quot;,&quot;22&quot;,33&quot;&#125;; arr.length;//3 6. int [] a,b,c是定义了3个数组，int a[],b,c是定义了一个数组a，两个变量b，c7. 掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类 8. 字符串转基本类型的方法 字符串转换为基本类型 Integer包装类的parseXxx静态方法 Integer包装类的valueOf()方法[自动拆箱] String str = “123”; int a = Integer.parseInt(str); int b = Integer.valueOf(str); 基本类型转换为字符串 Integer包装类的toString()方法 String类的valueOf()方法 n + “” int n = 6; String str = Integer.toString(n); String str = String.valueOf(n); String str = n + “”; 第三章 类和对象1. 什么是方法的重载 名字相同，参数列表不同的两个（或多个）方法 参数类型不同 参数个数不同 重载方法的依据方法参数列表的不同，是编译器用来区分调用哪一个 2. 构造方法是用来进行成员变量初始化的3. 构造方法的名字和类名相同4. 构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载5. static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用6. public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么 public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用 private：私有.就是除了class自己之外，任何人都不可以直接使用，即便是子女，朋友，都不可以使用。 protected：对于子女、朋友来说，是public可以自由使用，没有限制，而对于其他的外部class，protected就变成private。 默认(无修饰词)，同一个包内可以访问，包级访问权限； 权限修饰符用来修饰类、接口、方法、变量。 修饰类：public、默认（default）。 修饰接口：public、默认（default）。 修饰方法：private、默认、protected、public 修饰变量：private、默认、protected、public 7. 类、方法和变量等可以使用多个修饰符修饰8. 所有类的直接或者间接父类是Object类 第四章 继承1. 类之间使用extends关键字继承2. 子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）3. final修饰类、变量和方法，不能被继承和改写4. Java所有的类都是java.lang.Object类的子类 第五章 抽象类、接口1. 定义接口使用interface，实现接口implements2. abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体3. 抽象类可以没有抽象方法，有抽象方法的类必定是抽象类4. 使用interface关键字定义接口，类使用implements实现（继承）接口5. 接口中只有常量和抽象方法，并且都是public abstract的抽象方法，都是public static final的常量6. 接口可以实现多重继承，定义类的模板7. 多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态 第六章 字符串1. 字符串分为静态字符串（String）和动态字符串（StringBuffer）2. 使用length（）方法获得字符串的长度String str=&quot;asdfghjkl&quot;; str.length();//9 3. 其他常用方法chatAt（）、equals（） chatAt（） 返回位于字符串的指定索引处的字符 equals（） 所有的对象都拥有标识(内存地址)和状态(数据)，“==”比较两个对象的的内存地址，使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。 String、Math等封装类都对equals()方法进行了重写。比较的是两个对象的状态 第七章 异常处理1. 什么是异常异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 在程序执行期间发生的事件，它中断正在执行的程序的正常指令流。 2. 为什么要进行异常处理为了能够及时有效地处理程序中的运行错误，必须使用异常类。 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 3. 所有异常的父类是Throwable类，它有两个直接子类为Error和Exception Error:程序无法处理的错误，表示运行应用程序中较严重问题。恢复不是不可能但很困难的情况下的一种严重问题。 例如，内存溢出，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception:是程序本身可以处理的异常。 exception 设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况 4. 异常分为运行时异常和非运行时异常unchecked exception 非检查异常 运行时异常（RuntimeException） Error 对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。 checked exception 非运行时异常（运行时异常以外的异常就是非运行时异常） java编译器强制程序员必须进行捕获处理，比如IOExeption和SQLException。 对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。 5. 异常的处理过程是先抛弃后捕获6. 处理方法有三种： 运行时异常可回避 throws可回避交给上级调用模块处理 try-catch-finally自行处理 7. 进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面8. 使用throw制造异常throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象 第八章 输入输出1. 输入输出需要引入java.io包2. 文件和目录使用File类3. InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口4. 完成文件内容拷贝练习题第九章 JDBC1. 需要引入的包是java.sql第十章 事件处理1. 事件处理模型是授权处理模型2. 常用的五种布局管理器是哪些？ FlowLayout 流式布局 BorderLayout 边框式布局 GridLayout 网格布局 CardLayout 卡片布局 BoxLayout 盒式布局 3.JFrame的默认布局管理器是BorderLayout4. JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变第十章 多线程1 .线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行2. 启动线程需要调用start（）方法，不需要调用run（）方法3. 在定义Thread类时，run（）方法必须要重写4. 线程提供了wait、notify和notifyAll方法实现线程的同步 start()：启动线程 wait()：将当前线程置入休眠状态 notify()：唤醒在此对象监视器上等待的单个线程。 notifyAll()：唤醒在此对象监视器上等待的所有线程。 setPriority()：更改线程的优先级。 join()：使其他线程等待当前线程终止 interrupt()：中断线程 isAlive()：测试线程是否处于活动状态。 static： sleep()：线程休眠 yield()：暂停当前正在执行的线程对象，并执行其他线程。 currentThread()：返回对当前正在执行的线程对象的引用。 5. 线程的优先级从1到10，程序员可以在编程时定义6. 创建线程的方法继承Thread类和实现Runnable方法第十一章 网络编程1. TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端2. 与网络通讯相关的类都封装在java.net包下 编程题1、评委打分1234567891011121314151617181920212223242526package dafen;import java.util.Arrays;import java.util.Scanner;public class a1 &#123; public static void main(String[] args) &#123; //评委打分 Scanner scanner = new Scanner(System.in); int N=scanner.nextInt(); int[] arr = new int[N]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = scanner.nextInt(); &#125; Arrays.sort(arr); int score=0; for (int i = 1; i &lt; arr.length-1; i++) &#123; score += arr[i]; &#125; System.out.println(&quot;最终得分：&quot;+score/(arr.length-2)); &#125; &#125; 2、工厂零件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//Area.javapackage area;import java.util.Scanner;import area.JieKou.Jiekou;public class Area &#123; public static void main(String[] arg) &#123; //工厂零件求面积 Scanner scanner = new Scanner(System.in); double r; r=scanner.nextDouble(); Jiekou jk = new Yuan(r); System.out.println(jk.getArea()+&quot; &quot;+jk.getZhouchang()); h=scanner.nextDouble(); Jiekou jk = new YuanZhu(r,h); System.out.println(jk.getArea()+&quot; &quot;); &#125;&#125;//JieKou.javapackage area;public class JieKou &#123; public interface Jiekou &#123; double getArea(); double getZhouchang(); &#125;&#125;//Yuan.javapackage area;import area.JieKou.Jiekou;public class Yuan implements Jiekou&#123; private final double PI = 3.14; private double r; public Yuan() &#123;&#125; public Yuan(double r) &#123; this.r = r; &#125; public double getArea() &#123; return PI*r*r; &#125; public double getZhouchang() &#123; return 2*PI*r; &#125;&#125;//YuanZhu.javapackage area;public class YuanZhu extends Yuan&#123; private double h; public YuanZhu(double r,double h) &#123; super(r); this.h=h; &#125; public double getArea() &#123; return (super.getArea()*h); &#125; &#125; 3、文件copy操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package file;import java.io.*;public class filecopy &#123; public static void main(String[] avg) throws Exception &#123; try &#123; //复制 song(); //字符读写 切割处理 rwFileSplitEnglish(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static void rwFileSplitEnglish() throws Exception &#123; String str = &quot;&quot;; //FileReader reader = new FileReader(&quot;fileIn\\\\txt1&quot;); BufferedReader reader = new BufferedReader(new FileReader(&quot;fileIn\\\\txt1&quot;)); int len; while((len = reader.read())!=-1) str +=(char)len; reader.close(); System.out.println(str); String re = &quot; &quot;; String s[] = str.split(re); for (int i = 0; i &lt; s.length; i++) &#123; System.out.print(s[i]); &#125; System.out.println(str.length()); &#125; private static void song() throws Exception &#123; InputStream in = new FileInputStream(&quot;fileIn\\\\你一生的故事.mp3&quot;); OutputStream out = new FileOutputStream(&quot;fileOut\\\\你一生的故事2.mp3&quot;); int len; long begintime = System.currentTimeMillis(); while((len=in.read())!=-1) &#123; out.write(len); &#125; long endtime = System.currentTimeMillis(); System.out.println(endtime-begintime); in.close(); out.close(); &#125;&#125; 4、JDBCDao模式","tags":[]},{"title":"IdentifyTask查询（附样例源码）","date":"2021-07-22T09:54:48.940Z","path":"2021/07/22/IdentifyTask查询（附样例源码）/","text":"效果图 1. 空间查询触发事件12345678910111213141516171819202122232425262728query(&quot;button&quot;).on(&quot;click&quot;, function (event) &#123; map.graphics.clear(); var value = this.innerHTML; switch (value) &#123; case &quot;点&quot;: &#123; toolbar.activate(Draw.POINT, &#123; showTooltips: true &#125;) break; &#125; case &quot;线&quot;: &#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips: true &#125;) break; &#125; case &quot;面&quot;: &#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips: true &#125;) break; &#125; case &quot;X&quot;: &#123; toolbar.deactivate(); break; &#125; &#125; &#125;) 2. 绘图事件123456on(toolbar, &quot;draw-complete&quot;, function (result) &#123; toolbar.deactivate(); var params = new IdentifyParameters(); params.geometry = result.geometry; identifytask.execute(setParams(params), showIdentifyResult) &#125;); 3. 设置参数12345678function setParams(params) &#123; params.returnGeometry = true; params.tolerance = 3; params.layerIds = [0, 1]; params.mapExtent = map.extent; params.layerOption = IdentifyParameters.LAYER_OPTION_ALL; return params; &#125; 4. 显示12345678910111213141516function showIdentifyResult(res) &#123; console.log(res) if (res.length &lt;= 0) &#123; alert(&quot;未检测到&quot;) &#125; else &#123; var features = []; for (var i = 0; i &lt; res.length; i++) &#123; //此例中res[0]是建筑图层,res[1]是行政区图层 features[i] = res[i].feature; features[i].setInfoTemplate(new InfoTemplate(&#123; &quot;title&quot;: &quot;&quot;, &quot;content&quot;: &quot;$&#123;*&#125;&quot; &#125;)); &#125; //设置弹出窗口，map有自带infoWindow属性 map.infoWindow.setFeatures(features); map.infoWindow.show(enevt.mapPoint); &#125; &#125; 源码","tags":[]},{"title":"Hadoop入门——环境篇","date":"2021-07-22T09:54:48.938Z","path":"2021/07/22/Hadoop入门——环境篇/","text":"软件准备 VMware15 Ubuntu18.0.4 Hadoop3.2.1 jdk-8u162-linux-x64 步骤 安装虚拟机，一路Next 创建Ubuntu系统 安装JDK 安装Hadoop及伪分布式部署 入门学习伪分布式就可以了。","tags":[]},{"title":"Hadoop 3.2.1的安装、伪分布式部署及web无法访问踩坑","date":"2021-07-22T09:54:48.936Z","path":"2021/07/22/Hadoop 3.2.1的安装、伪分布式部署及web无法访问踩坑/","text":"安装 Hadoop 3.2.11. 下载 2. 将Hadoop 安装至 /usr/local/ 中 1sudo tar -zxf ~/下载/hadoop-3.2.1.tar.gz -C /usr/local 3. 在/usr/local文件夹在找到文件，右键重命名为hadoop4. 修改文件权限 1sudo chown -R hadoop ./hadoop 5. 查看hadoop版本 12cd /usr/local/hadoop./bin/hadoop version 伪分布式配置1. 修改配置文件core-site.xml 原代码： 12&lt;configuration&gt;&lt;/configuration&gt; 替换： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 2. 修改配置文件hdfs-site.xml 原代码： 12&lt;configuration&gt;&lt;/configuration&gt; 替换： 123456789101112131415161718&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;0.0.0.0:9870&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 3. NameNode 格式化 12cd /usr/local/hadoop./bin/hdfs namenode -format 4. 出现has been successfully formatted，则成功. 5. hadoop3.X版本中成功不在出现Exiting with status 06. 开启hadoop服务 12cd /usr/local/hadoop./sbin/start-dfs.sh 7. 通过jps查看服务状态 8. 四个都出现则代表服务正常启动9. 在浏览器中输入http://localhost:9870，3.x版本中端口已经从50070改为了9870，配置文件中已经修改了。50070访问不到，踩坑！！！多看官网，受益匪浅 10. 成功部署11. 关闭hadoop服务1./sbin/stop-dfs.sh","tags":[]},{"title":"GP--缓冲区","date":"2021-07-22T09:54:48.934Z","path":"2021/07/22/GP服务--缓冲区/","text":"1. 效果图 2. GP服务 3. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950require([&quot;esri/map&quot;, &quot;esri/geometry/Point&quot;, &quot;esri/graphic&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/tasks/Geoprocessor&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/tasks/LinearUnit&quot;, &quot;dojo/domReady!&quot;], function (Map, Point, Graphic, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Geoprocessor, FeatureSet, LinearUnit) &#123; map = new Map(&quot;map&quot;, &#123; basemap: &quot;osm&quot;, zoom: 5 &#125;); map.on(&quot;click&quot;, function (evt) &#123; var symbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CROSS, 12, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new dojo.Color([255, 0, 0]), 2), new dojo.Color([0, 255, 0, 0.25])); var graphic = new Graphic(evt.mapPoint, symbol); map.graphics.add(graphic); var gp = new Geoprocessor(&quot;http://localhost:6080/arcgis/rest/services/webgis/BufferGP/GPServer/BufferModel&quot;); var featureSet = new FeatureSet(); featureSet.fields = []; featureSet.features = [graphic]; var dis = new LinearUnit(&#123; &quot;distance&quot;: 10000, &quot;units&quot;: &quot;esriMeters&quot; &#125;); // input dis对应服务中的参数名称 var bufferParams = &#123; input: featureSet, dis: dis &#125;; //submitJob gp.execute(bufferParams, showResult, function (err) &#123; console.log(err) &#125;) &#125;) function showResult(results) &#123; console.log(results) var features = results[0].value.features; for (var i = 0; i &lt; features.length; i++) &#123; var geo = features[i].geometry; var line = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT, new dojo.Color([255, 0, 0]), 1); var fill = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, line, new dojo.Color([255, 255, 0, 0.25])); map.graphics.add(new Graphic(geo, fill)); &#125; &#125; &#125;);","tags":[]},{"title":"GPS测量原理及应用 知识总结","date":"2021-07-22T09:54:48.932Z","path":"2021/07/22/GPS测量原理及应用 知识总结/","text":"GPS第一章1. 北斗的优势及应用 （至少三点） 优势 三频定位，卫星定位精度更高。 通过三个不同频率的信号可以有效消除定位的时候产生的误差，并且多个频率的信号可以在某一个频率信号出现问题的时候改用其他信号，提高定位系统的可靠性和抗干扰能力 短报互文功能 安全、方便 应用 气象应用： 北斗系统在卫星气象方面的应用，可以提升中国天气分析和数值天气预报、气候变化监测和预测的水平，也可以提高空间天气预警业务水平，提升中国气象防灾减灾能力。 铁路智能交通：北斗卫星导航系统将可提供高可靠、高精度的定位、测速、授时服务。 应急救援： 全海域出海渔船加装北斗系统装备，利用北斗特有的短报互文通信功能及时回传海上遇险搜救信息，成为海上渔民保障安全的重要工具。 居家智慧养老项目：利用“互联网+北斗定位+社区服务组织+医疗机构+居家养老智能服务终端”，构建智能化医、养、服务结合的居家养老实施体系， 北斗+纪检 ：实时查询目标车辆的精确位置和历史轨迹，对公车实行动态监管。 2. GPS系统的组成、地面监控、GPS接收机任务 系统组成 空间部分——GPS卫星星座 作用： ​ 1. 用两个无限载波向用户连续发送导航定位信号 2. 接收导航电文及其他信息，适时的发送给广大用户 3. 接收地面主控站通过注入站发送到卫星的调度命令，实时的改正运行偏差或启用备用时钟等。 地面控制部分——地面监控系统 一个主控站。 美国本土科罗拉多。收集、处理本站和监测站收到的全部资料 ，编算出每颗卫星的星历和GPS时间系统，将预测的卫星星历、钟差、状态数据以及大气传播改正编制成导航电文传送到注入站。 三个注入站 将主控站发来的导航电文注入到相应卫星的存储器。 五个监测站 为主控站提供卫星的观测数据 用户设备部分——GPS信号接收机 捕获按一定卫星高度截止角所选择的待测卫星的信号，并跟踪卫星运行 对所接收到的GPS信号进行变换、放大和处理 测量出信号传播的时间，解译出GPS卫星所发送的导航电文 实时计算出测站的三维信息，甚至三位速度和时间。 系统特点 定位精度高：50km以内可达10-6 观测时间短： 20km以内的相对静态定位，仅需15~20 分钟 测站间无需通视：只需测站上空开阔。 可提供三维坐标、时间、速度：经典大地测量将平面与高程分别施测，GPS可同时测定点的三维坐标。 操作简便 全天候作业：24小时行。 功能多、应用广 第二章1. 天球坐标系和地球坐标系是用来干什么的？ 天球坐标系:描述卫星的运行位置和状态。该坐标系与地球自转无关。 原点—地球质心M Z轴—指向天球北极Pn X轴—指向春分点 Y轴—垂直于XMZ平面，与X轴Z轴构成右手坐标系统。 地球坐标系:描述地面观测站的位置，该坐标系随同地球自转。通常采用空间直角坐标系进行坐标转换。 原点O：地球质心 Z轴：指向地球北极Pn X轴：指格林尼治子午面与地球赤道的交点E Y轴：垂直于XOZ平面，与X轴和Y轴构成右手坐标系。 为什么选用空间直角坐标系？ 任一点的空间位置可由该点在三个坐标面的投影（X，Y，Z）唯一地确定，通过坐标平移、旋转和尺度转换，可以将一个点的位置方便的从一个坐标系转换至另一个坐标系。 与某一空间直角坐标系所相应的大地坐标系（B，L，H），只是坐标表现形式不同，实质上是完全等价的，两者之间可相互转化。 2. 怎么定义坐标系？ 坐标原点的位置。 三个坐标轴的指向。 长度单位 3. 坐标系统之间的转换七参数 同一基准 空间直角坐标系与空间大地坐标系间的转换。 空间坐标系与平面直角坐标系间的转换。 不同基准 不同坐标系之间的转换实质上就是不同基准间的转换，常用布尔萨七参数转换方法。 布尔萨七参数：即3个平移参数，3个旋转参数，1个尺度参数。 GPS坐标与我国北京54（西安80）坐标的转换流程图： 4. 时间系统 判断 时间： 时刻：发生某一现象的瞬间. 时间段：发生某一现象所经历的过程，是这一过程始末的时刻之差。 时间基准 时间原点（时刻） 时间尺度（时间段） GPS定位对时间系统的要求全球统一的时间原点和高精度的时间尺度。 原因： 时间度量的精度就意味着空间位置的精度。 GPS定位是通过测定电磁波信号的传播时间来测定站星距离的。 第三章1. 卫星的无赦运动，确定开普勒轨道方程，要知道参数 无赦运动：地球质心引力（中心引力） 第一定律：卫星运动的轨道是一个椭圆，而该椭圆的一个焦点与地球质心重合。 第二定律：卫星到地心的距离在相等的时间内所扫过的面积相等。 第三定律：卫星运行周期的平方，与轨道椭圆长半径的立方之比为一常量。 理想轨道 中心引力 二体问题：将地球和卫星视为两个质点，仅考虑地球质心引力研究卫星运动规律 受摄运动：地球非对称性引力 日月引力； 大气阻力； 光辐射压力 摄动力 地球非中心引力Fm； 太阳引力Fs和月球引力Fn； 太阳光的直接与间接辐射压力Fr； 大气阻力Fa； 地球潮汐作用力； 磁力及其他作用力 开普勒运动 轨道六参数 卫星轨道面与赤道面的相对位置 升交点赤经Ω ：升交点和赤道面春分点的夹角 近地点角距 ：轨道平面近地点和升交点的夹角 轨道倾角 ：轨道面和赤道面的夹角 卫星过近地点时刻 卫星轨道的形状 卫星轨道长半轴 卫星轨道扁率 2. GPS卫星星历描述卫星某一时刻运动轨道的信息 预报星历（广播星历） 定义：通过卫星发射到用户接收机的含有轨道信息的导航电文信号 内容：共计17个星历参数。 特点： 每2个小时更新一次， 外推的时间间隔不超过1小时 预报星历的精度一般约为20-40m 注入站—-将卫星星历、卫星钟差等参数和各种控制命令发送到GPS卫星。 预报星历的编制和传送过程： 后处理星历（精密星历） 定义：根据地面跟踪站的精密观测资料计算而得到的，不包含外推误差的实测星历。 优点： 轨道参数非常准确，也称精密星历。 缺点：不能做到实时。 后处理星历的编制和传送过程： 第四章1. GPS卫星的导航电文​ 用户用来定位和导航的数据基础。 遥测码：位于各子帧的开头，表明卫星注入数据的状态。 转换码：位于每个子帧的第二个字码，提供帮助用户从所捕获C/A码转换到捕获P码的时间计数（Z）。 第一数据块：位于第一子帧的第3 ~10字码。 卫星时钟改正——以地面主控站的原子钟为基准 电离层时延改正 星期序号WN—— GPS周期数 数据龄期AODC 卫星的健康状况 第二数据块：包含第2和第3子帧，其内容表示GPS 卫星的星历。 第三数据块：包含第4和第5子帧，内容包括了所有GPS 卫星的历书数据。可帮助用户选择工作正常的定位卫星。 2. GPS信号图，信号怎么产生的，为什么要两个载波，消除有什么影响，C/A码，P码 GPS信号 运载工具（载波L1、L2） 测距码（C/A码、P码） 导航电文（数据码、D码） 信号图 两个载波测量出或消除掉由于电离层效应而引起的延迟误差 消除有什么影响？ 粗码C/A码 码长：1023位 周期：1ms 测距误差：3~30m 特点： 由于C/A码的码长较短，易于捕获，而通过捕获C/A码所得到的信息，又可以方便的捕获到P码，称C/A码为捕获码。 C/A码的码元宽度较大，测距误差可达 3~30m。由于其精度较低，所以，称C/A码为粗捕获码。 由于C/A码单点定位精度较低，测量上采用非单点定位，即相对定位（差分定位）。 精码P码 码长：6.19*1012 bit 周期：七天 测距误差：0.3~3m 特点： 码元宽度较小，精度较高，专为军用。 目前，只有极少数接收机才能接收P码，且价格昂贵。 3. 接收机的基本工作原理 接收天线：将GPS信号的极危若的电磁波能转化为相应的电流 前置放大器：将GPS信号电流予以放大。为便于接收机对信号进行跟踪、处理和两侧。 接收机主机 变频器及中频放大器 经过GPS前置放大器的信号仍然很微弱，为了使接收机通道得到稳定的高增益，并使L频段的射频信号变为低频信号。采用变频器 信号通道 搜索卫星，牵引并跟踪卫星 对广播电文数据信号实行解扩，解调出广播电文 进行伪距测量、载波相位测量及多普勒频移测量 总结 当GPS卫星在用户世界升起时，接收机能够捕获到按一定卫星高度截止角所选择的待测卫星，并能够跟踪这些卫星的运行； 对所接收到的GPS信号，具有变换，放大和处理的功能， 以便测量出GPS信号从卫星到接收天线的传播时间， 解译出GPS卫星所发送的导航电文， 实时的计算出测站的三维位置，甚至三维速度和时间。 GPS信号接收机不仅需要功能较为强大的机内软件，而且需要一个多功能的GPS数据测后处理软件包。 接收机加处理软件包，才是完整的GPS信号用户设备。 第五章1. GPS卫星定位的基本原理，分类，四种 基本原理 运用空间距离前方交会的方法求出卫星的位置。 运用空间距离后方交会的方法求测站点的位置。 观测值：距离 用距离交会的方法求解P点的三维坐标（X，Y，Z）的观测方程： 实质：​ 由GPS接收机在某一时刻，同时接收四颗以上的GPS卫星信号，测量出GPS接收机到GPS卫星的距离，根据空间距离后方交会的方法求测站点的位置。 GPS定位方法及分类 按采用观测值 伪距定位 载波相位定位 按获取结果的时间 实时定位 事后定位 按测站的运动状态 静态定位 动态定位 按接收机的数量 绝对定位（单点定位） 相对定位（差分定位） 2. 什么是伪距测量？原理是什么，方程（详细）方程各部分的意义 定义 伪距法定位：由GPS接收机在某一时刻测出四颗以上的GPS卫星的伪距以及已知的卫星位置，采用空间距离后方交会的方法求定天线所在点的三维坐标。 伪距：由卫星发射的测距码信号到达GPS接收机的传播时间乘以光速所得出的量测距离。而不是卫星与GPS接收机的几何距离。 原理 时间 t 的测定： 卫星 — 测距码，经时间到达接收机。 接收机 — 复制码 时延器 — 延迟复制码，经延迟时间 使两码对齐，。 使实际上是不可能的，只能使，两种码不可能完全对齐，导致时间有误差。 伪距测量方程 为伪距测量值 为卫星至接收机几何距离 T 为测距码的周期 为周长 为测距模糊度 如果已知待测距离小于测距码的波长，则n=0 伪距定位观测方程 优点：定位速度快，无多值性。 缺点：定位精度低，P码的测距精度0.3m，C/A码 的测距精度3m左右 。 3. 载波相位测量的原理，方程 原理 方程 4. 整周跳变原因，修复方法 定义 在载波相位测量中，若接收机保持对卫星信号的连续跟踪，则整周未知数保持不变，整周计数也保持连续. 但当接收机无法保持对卫星信号连续跟踪时，在卫星信号重新被锁定后，整周未知数将发生变化，整周计数也将不再与前面的值保持连续而发生部分丢失现象. 不足一周的的相位观测值仍是正确的 原因 信号被其它物体遮拦； 大功率电磁场干扰； 电源中断，或接收机故障（无法修复周跳，需重新观测） 修复方法 屏幕扫描法 多项式拟合法 在卫星间求差 双频观测值修复周跳 根据平差后的残差修复周跳 5. 绝对定位，相对定位 绝对定位 ​ 接收机天线处于静止状态下，确定观测站坐标的方法称为静态绝对定位。 这时，可以连续地在不同历元同步观测不同的卫星，测定卫星至观测站的伪距，获得充分的多余观测量。测后通过数据处理求得观测站的绝对坐标。 相对定位 至少用两台GPS接收机，同步观测相同的GPS卫星，确定两台接收机天线之间的相对位置（坐标差）。 特点 优点：定位精度高 缺点： 多台接收共同作业 数据处理复杂 不能直接获取绝对坐标 应用 高精度测量定位及导航 6. 一次两次三次差分定位 单差观测（一次差）——在接收机间求差 为什么要进行单差观测？ 不同接收机观测同一颗卫星，在不同接收机间求一次差，可消除信号传播的误差（对流层、电离层等的误差），采用单差观测的目的就是要减少误差的影响提高定位结果的精度。优点：①可消除卫星钟差的影响； ②削弱星历误差的影响； ③可削弱电离层和对流层的影响。 双差观测（二次差）——在卫星间求差可以消除接收机间钟差的影响。 三次差—在星历间求差（两个历元的星历间求差）可消除的影响（过程中由于不准造成的影响） 差分定位差分GPS定位技术是将一台GPS接收机安置在基准站上进行观测。根据基准站已知精密坐标，计算出基准站到卫星的距离改正数，并由基准站实时地将这一改正数发送出去。用户接收机在进行GPS观测的同时，也接收到基准站的改正数，并对其定位结果进行改正，从而提高定位精度。 差分GPS可分为: 单基准站差分 位置差分 伪距差分 载波相位差分 具有多个基准站的局部区域差分 广域差分 GPS定位中，存在着三部分误差： 一是多台接收机公有的误差，如：卫星钟误差、星历误差； 二是传播延迟误差，如：电离层误差、对流层误差； 三是接收机固有的误差，如：内部噪声、通道延迟、多路径效应。 采用差分定位，可完全消除第一部分误差，可大部分消除第二部分误差（视基准站至用户的距离）。 第七章1. GPS测量的误差来源及消除方法 GPS卫星: 对距离测量的影响：1.5 ~ 15m 星历误差：星历包含17个参数，参数本身存在误差。​ 消除: 建立自己的卫星跟踪网； 轨道松弛法——六个轨道参数的近似值作为已知值，将改正数作为参数进行平差处理。 同步观测求差——利用两个或多个观测站，对同一卫星的同步观测值求差。 钟误差：调制波以一定的频率形成信号，信号本身存在误差；利用调制码求时间，存在误差。​ 消除: 加钟差改正模型 同步观测求差——在接收机间求一次差，可消除卫星钟差和改正后的残余误差。 相对论效应：对震荡频率产生影响，会对时间、空间距离产生影响。​ 消除: 在制造卫星钟时预先把频率降低为 卫星信号的传播过程: 对距离测量的影响：1.5 ~ 15m 电离层：信号在传播时会发生折射。​ 消除: 利用电离层改正模型加以修正（模型法） 利用双频观测 同步观测求差。 对流层：信号在传播时会发生折射。​ 消除: 采用对流层模型加以改正； 引入待估参数； 同步观测求差。 多路径效应：测站周围的反射物所反射的信号进入接收机天 线，与直接来自卫星的信号产生干涉。​ 消除: 选择合适的站址； 对接收机天线的要求； 同步观测求差。 不论是对流层或电离层与高度角都有很大的关系， 正上方影响最小，地平方向最大。高度角越大越好。 地面接收设备: 对距离测量的影响：1.5 ~ 5m 接收机钟差：接收机钟与卫星钟不同步。​ 消除: 作为未知数，一并求解； 在卫星间求一次差； 加时钟改正模型。 位置误差：对中、整平、水准器校正不好等。​ 消除: 校正仪器、仔细安置仪器、强制归心。 天线相位中心：天线的几何中心与电磁场相位中心不重合，类似经纬仪度盘的偏心差。​ 消除: 同步观测求差。 所有天线安置时方向要一致，指向标均指向北方向。 其他影响 地球潮汐：海潮，固体潮 负荷潮：与地球的内部质量分布不均匀有关，与地球的引力有关。对距离测量的影响：1.0m 第八章1. GPS测量的设计依据，基准设计 设计依据 GPS测量规范：主要指国家、城市以及行业标准。 测量任务书：布网的设计既要符合有关标准又要满足任务要求。 基准设计 位置基准：由给定的起算点确定 方位基准：由给定边的起算方位角确定 尺度基准：测距仪测定的基线边、GPS基线边或两个起算点间的距离确定 2. GPS网构成的几个基本概念及网特征条件 基本概念 观测时段：测站上开始接收卫星信号到观测停止，连续工作的时间段。 同步观测：两台或两台以上接收机同时对同一组卫星进行的观测。 同步观测环：三台或三台以上接收机同步观测获得的基线向量所构成的闭合环。 独立观测环：由独立观测所获得的基线向量所构成的闭合环。 异步观测环：在构成多边形环路的所有基线向量中，只要有非同步观测基线向量，则该多边形环路叫异步观测环。 独立基线：对于N台GPS接收机构成的同步观测环，有J条同步观测基线，其中独立基线数为 N-1。 非独立基线：除独立基线外的其他基线，总基线数与独立基线数之差即为非独立基线数。 GPS网特征条件的计算 全网观测时段数 总基线数 必要基线数 独立基线数 多余基线数 3. GPS网特征条件的计算 4. GPS外野实施，怎么选点，观测，不能做什么 选点 点位应安置在视野开阔，易安装仪器的地方； 点位目标明显，视场周围15°以上没有障碍物的地方； 点位应远离大功率无线电用电器大于200m；远离高压电线，不小50m； 点位附近无大面积水域，无强烈信号干扰，以免造成信号衰减； 点位应选在交通便利、有利于其它观测手段扩展和联测； 地面基础稳定易于点的保存； 图形应有利于同步观测边、点联测； 利用旧点时应对旧点的稳定性、完好性和站标的安全性进行检查； 观测过程中不允许进行以下操作：​ a)接收机关闭又重新启动；​ b)进行自测试；​ c)改变卫星仰角；​ d)改变数据采样间隔；​ e)改变天线位置；​ f)按动关闭文件和删除文件等功能键。 5. RTK的测量原理，基准站，移动站什么时候发送数据 测量原理 在基准站上安置一台GPS接收机，对所有可见GPS卫星进行连续的观测，并将其观测数据，通过无线电传输设备，实时的发送给用户观测站。 在用户站上，GPS接收机在接收GPS卫星信号的同时，通过无线电接收设备，接收基准站传输的观测数据，然后根据相对定位的原理，实时的计算并显示用户站的三维坐标及其精度。 第九章1. GPS测量数据处理过程，原理，方法 过程 数据采集： GPS接收机至卫星的伪距、载波相位和卫星星历等数据。 GPS数据处理：从原始的观测值出发得到最终的测量定位成果。 基线解算： 原始观测数据的读入 外业输入数据的检查与修改 设置基线解算的控制参数 基线解算 基线解算质量的检核 结束 2. GPS高程：之间的差异 大地水准面和正高（正高系统）: 以大地水准面为基准面的高程系统。 似大地水准面和正常高（正常高系统）: 以似大地水准面为基准面的高程系统。 参考椭球面和大地高（大地高系统）: 以参考椭球面为基准面的高程系统 3. 高程计算方法：3个 绘等直线图法—— 几何内插法 测区内有m个点，大地高均已知； 选n个点进行水准测量，得其正常高； 计算n个点的高程异常： 依据各点的坐标按一定比例将点展绘在图纸上，并在n个点旁标注出其高程异常值。 选取高程异常等高距（1～5cm），绘等值线图。 利用内插法求出其余m-n个点的高程异常值。 注：n个点选取时要覆盖整个测区。 多项式曲线拟合法 在测线上有m个点，经GPS测量得其大地高； 在m个点中n个点，用水准测量方法测得其正常高。 计算n个点的高程异常： 找出与x（或y）的函数关系： 或 可用多项式表示： 当工程为带状时利用绘等直线法就不是很方便了，拟合的好坏与点的个数和点的位置有关。 多项式曲面拟合法 在测区上有m个点，经GPS测量得其大地高； 在m个点中n个点，用水准测量方法测得其正常高。 计算n个点的高程异常： 找出 与点的坐标（ x，y）的函数关系： 可用多项式表示： 拟合的点在测区内应分布均匀。 Other2. GPS功能定位，导航，授时","tags":[]},{"title":"github_码云操作---提交中的常用命令","date":"2021-07-22T09:54:48.930Z","path":"2021/07/22/github_码云操作---提交中的常用命令/","text":"将login分支中的代码提交到本地仓库，合并到master分支推送到远端 git status:查看当前项目中源代码的状态 git add .:将修改后文件和新增文件添加到暂存区 git commit -m &quot;提交的文本说明信息&quot;:提交暂存区代码到本地仓库 git branch:查看分支 git checkout -b login:新建一个user分支，并切换到这个分支，执行后，当前处于该分支，当前所有的修改也切换到了这个分支中 git push -u origin lohin:将本地的login分支推动到云端origin仓储里的login分支（远端没有此分支，该分支的第一次推送） git checkout master:切换分支到master git merge login:合并分支 git push:推送 git remote rm origin：远程起源已存在时先输入这个 坑 报错! [rejected] master -&gt; master (non-fast-forward) error: failed to push some refs to &#39;https://xxxxxxxxxxxxxxxxxxx.git&#39;解决： git pull origin master --allow-unrelated-histories 同步远程仓库 如果仓库中有一个说明文件，可能会进入vim编辑模式， esc -&gt; : -&gt; q! -&gt; enter退出即可 git push origin master重新提交 如果提示本地未提交，就重新add commit","tags":[]},{"title":"GIS复习【VI】","date":"2021-07-22T09:54:48.928Z","path":"2021/07/22/GIS复习【VI】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录13、数据库与空间数据库14、数据库的数据模型15、空间数据的组织方式16、ArcGIS中的数据方式 ——————————————————正文——————————————————- 13、数据库与空间数据库 数据库概述 数据管理技术的发展过程 人工管理阶段–&gt;文件管理阶段–&gt;数据库管理阶段 建立数据库的目的 保存数据 管理和控制与这些数据相关联的事物。 数据库定义： 为了一定的目的，在计算机系统中以特定的结构组织、存储、管理和应用的相关联的数据集合。 数据组织层次 数据项(元素/基本项/字段)：定义数据的最小单位 记录：由若干相关联的数据项组成 文件：一给定类型的记录的全部具体值的集合 数据库：若干文件的集合。 5. 逻辑关系 - 1：1 - 1：N - M：N 空间数据的特征 空间分布特征 空间对象隐含了空间分布特征,需要按照位置进行空间对象的检索 非结构化特征 用一条记录表达一个空间对象，它的数据项可能是很长的，例如，1条弧段的坐标，它可能是2对坐标，也可能是10万对坐标。 非结构化是空间数据难以直接采用通用的关系型 数据库管理系统的主要原因。 空间关系特征 空间数据库中记录的拓扑信息表达了多种空间关系 分类编码特征 基础地理信息要素分类与代码 海量数据特征 多尺度与多态性 X 空间数据库 定义 应用于地理空间数据处理与信息分析领域的具有工程性质的数据库。 是存取、管理空间信息的数据库。 特点： 数据量特别大 属性数据和空间数据联合管理 数据应用范围广泛 2. 数据库与空间数据库的比较 ![](https://img-blog.csdnimg.cn/20190420141933619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 3. 一般组成 ![](https://img-blog.csdnimg.cn/20190420141947749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 1. 栅格数据库 - 遥感影像数据 - DEM数据 2. 矢量数据库 - 各种空间实体数据（图形和属性数据） 14、数据库的数据模型 传统数据库的数据模型 层次模型（1:n） 结点代表数据记录，连线描述位于不同结点数据间的从属关系 网状模型（m:n） 没有明确的从属关系 关系模型 实体本身的信息以及实体之间的联系均表现为二维表，这种表就称为关系 一个实体由若干个关系组成，而关系表的集合就构成为关系模型。 关系模型用关系代数和关系运算来操纵数据 面向对象的数据模型 定义 以对象作为最基本的元素 面向对象的几何抽象类型 面向对象的属性数据模型 面向对象数据库系统的实现方式 特点：有效地表达空间数据的拓扑关系。表达和处理属性数据时，具有独特的优越性。 练习 4.1 数据管理技术发展的三个阶段？答：人工管理阶段–&gt;文件管理阶段–&gt;数据库管理阶段 空间数据的五大特征？答：分布特征、非结构化特征、空间关系特征、分类编码特征、海量数据特征。 空间数据库的定义与一般构成？答：定义：应用于地理空间数据处理于信息分析领域的具有工程性质，存取、管理空间信息的数据库。一般构成：矢量数据库（图形和属性）、栅格数据库（影响和高程模型） 传统数据库的数据模型有哪三种？答：层次模型（1：n）、网状模型（m：n）、关系模型 15、空间数据的组织方式 矢量数据组织 位置数据和属性数据通常是分开组织 文件与关系数据库混合管理 两个子系统分别存储和检索空间数据和属性数据，使用一种标识符将两者联系起来。缺点： 查询运算，模型操作运算速度慢； 数据分布和共享困难； 数据的安全性、一致性、完整性、并发控制以及数据损坏后的恢复方面 全关系型空间数据库管理 图形数据与属性数据都采用关系型数据库存储。 本质：将图形数据的变长部分（坐标数据）当作一个二进制块，交由关系数据库管理系统进行存贮和管理。 特点：不必进行烦琐的连接 对象-关系数据库管理 对现有的关系数据库进行扩展，增加空间数据类型 解决了空间数据的变长记录的管理 它仍然没有解决对象的嵌套问题，空间数据结构也不能由用户任意定义 扩展方式： 加一个空间数据管理引擎 由数据库管理系统的软件商在关系数据库管理系统中进行空间数据管理的专用模块扩展，定义操纵点、线、面、圆、长方形等空间对象的API（Application Programming Interface）函数。 栅格数据组织 影像数据和数字高程模型 基于文件的影像数据库管理 目前大部分GIS软件和遥感图像处理软件都是采用文件方式来管理遥感影像数据。 文件结合数据库管理 影像数据仍按照文件方式组织管理；在关系数据库中，每个文件都有唯一的标识号（ID）对应影像信息，如文件名称、存储路径等 关系数据库管理 将影像数据存储在二进制变长字段中，影像数据的元数据信息也存放在关系数据库的表中，二者可以进行无缝管理。 特点： 易于共享 方便管理多数据源和多时态的数据 数据的一致性和完整性控制 影像数据和元数据集成到一起，能方便的进行交互式查询。 不同操作系统平台下运行 16、ArcGIS中的数据方式 Coverage ：与shapefile不同的是shapefile文件不存储拓扑信息，因此相对其它数据格式要较少地占用存储空间，在显示和访问效率上要快许多。 Shapefile ：基于文件的存储，不能存储拓扑关系。 Geodatabase ：基于数据库的存储，可以存储拓扑关系。 个人地理数据库 Microsoft Access 数据文件 (.mdb)，2GB数据量限制，单用户数据库，仅适用于 Windows。 文件地理数据库 文件系统的文件夹中保存的ArcGIS所支持类型的 GIS 数据集的集合，单个数据集的大小限制为1TB，单用户数据库，跨平台。 ArcSDE地理数据库 在关系数据库中以表的形式保存的ArcGIS所支持类型的GIS 数据集的集合，可建立在服务器端的网络数据库连接。使用 ArcSDE 技术，数据库大小取决于所关联的DBMS。 练习 4.2 矢量数据的三种组织方式？ 栅格数据组织的三种方式 ArcGIS中文件组织方式？Geodatabase的三种类型？","tags":[]},{"title":"GIS复习【V】","date":"2021-07-22T09:54:48.926Z","path":"2021/07/22/GIS复习【V】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录17、空间数据源18、空间数据采集19、空间数据的编辑与处理20、空间数据质量及其精度分析 ————————————————-正文———————————————————- 17、空间数据源 数据源的分类 图形图像数据： 地图 、工程图、规划图 遥感影像、包括卫星、航空、地面遥感影像等 文本资料数据： 实测数据、野外调查的原始记录 共享数据（可能包含图形图像数据） 其他数据、如调查报告、立法文件等 ![](https://img-blog.csdnimg.cn/20190420151010764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 数据源特征 地图数据 具有共同参考坐标系统的点、线、面的二维平面形式的表示，分为普通地图和专题地图。 在应用地图数据时应注意以下几点： 地图存储介质的缺陷 地图现势性较差 地图投影的转换 遥感影像数据 特征： 能够提供大范围的瞬间静态图像； 能够进行大面积的重复性观测； 大大加宽了人眼所能观察的光谱范围； 空间详细程度高。 实测数据 GPS点位数据、地籍测量数据、观测站点监测数据等通常具有较高的精度和较好的现势性 统计数据 统计数据一般都是和一定范围内的统计单元或观测点联系在一起。 共享数据 多媒体数据 文本资料数据 空间数据采集与处理的基本流程 18、空间数据采集 空间（图形）数据的采集 野外数据采集：平板测量、全野外数字测图、空间定位测量 地图数字化：手扶跟踪数字化、扫描矢量化 摄影测量方法：航空摄影测量、地面摄影测量 遥感图像处理 流程： 观测数据的输入 再生、矫正处理 变化处理 分类处理 处理结果输出 **选择采集方法：** - 数字化设备：数字化仪、扫描仪、遥感与摄影测量设备 - 特点：范围大，速度快 - 使用范围：大面积GIS数据采集、资源普查等 **** - 野外测量：大平板、全站仪、GPS、移动测绘系统 - 特点：精度高、效率较低 - 适合范围：小范围GIS数据采集或局部数据更新 属性数据的采集 属性数据的来源与分类 社会环境 自然环境 资源与能源 2. 属性数据的编码 编码的直接产物就是代码，而分类分级则是编码的基础。 **编码原则：** - 系统性和科学性 - 一致性 - 标准化和通用性 - 编码的简捷性 - 编码的可扩展性 3. 常用的编码分类方法 1. 层次分类编码法：按分类对象的从属和层次关系为排列顺序 2. 多源分类编码法：不同的分类依据分别编码，数字之间没隶属关系。 属性数据和图形数据的连接 19、空间数据的编辑与处理20、空间数据质量及其精度分析","tags":[]},{"title":"GIS复习【III】","date":"2021-07-22T09:54:48.924Z","path":"2021/07/22/GIS复习【III】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录6、空间数据模型+7、栅格数据结构++8、矢量数据结构++9、矢量与栅格的比较与选择++10、矢栅一体化11、镶嵌数据结构12、三维数据结构+ ——————————————————–正文—————————————————————- 6、空间数据模型*数据模型是对现实世界进行认知、简化和抽象表达 空间实体抽象的三个层次 空间数据模型概念 对象模型 场模型 网络模型 空间逻辑数据模型 矢量数据模型 栅格数据模型 矢量-栅格一体化数据模型 镶嵌数据模型 面向对象数据模型 7、栅格数据结构** 概念 定义：将地表划分成为紧密相邻的网格阵列。每个网格的位置由行列号定义，并包含一个代码，以表示该网格的属性。 注意：栅格数据模型是将连续空间离散化，即用二维铺盖或划分覆盖整个连续空间。 特点 属性明显，定位隐含； 数据结构简单； 面向位置的数据结构，难以建立空间对象之间的关系； 比例尺大小为栅格(像元)的大小与地表相应单元的大小之比；存在几何和属性偏差。 属性值的确定 x 中心点法：取位于栅格中心的属性值为该栅格的属性值。 面积占优法：栅格单元属性值为面积最大者。 重要性法：取重要的属性值为栅格属性值。 长度占优法：每个栅格单元的值由该栅格中线段最长的实体的属性来确定。 栅格结构数据获取的途径 手工获取 扫描仪扫描 遥感影像数据 由矢量数据转换而来 栅格数据编码方法** 直接栅格编码 优点：简单、直观，无压缩 缺点：存在大量冗余，精度提高有限制。 完全栅格数据的组织：基于层（波段）、基于行、基于像元。 游程编码长度 数据结构：（A，P），A表示属性值，P代表该游程相同代码重复的个数。 属性变化越少，压缩比例越大，适合于类型区域面积较大的栅格。 - 优点： 1. 栅格加密时，数据量不会明显增加，压缩效率高，最大限度保留原始栅格结构， 2. 编码解码运算简单，且易于检索、叠加、合并等操作，得到广泛应用。 - 缺点：不适合于类型连续变化或类型区域分散的数据。 3. 块状编码 ![](https://img-blog.csdnimg.cn/20190420112711673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 对大而简单的多边形更为有效，在合并、插入、检查延伸性、计算面积等操作时有明显的优越性 4. 四叉树编码 **莫顿码** 十进制莫顿码产生过程：十进制的行、列坐标表示为二进制，按位交错，得到二进制再转化为十进制。 1. 四叉树编码 ![](https://img-blog.csdnimg.cn/20190420112725786.png) ![](https://img-blog.csdnimg.cn/20190420112759775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) - 图形必须为2n×2n的栅格阵列。 - n 为极限分割次数 - n＋1是四叉树最大层数或最大高度 2. 线性四叉树编码 ![](https://img-blog.csdnimg.cn/2019042011281168.png) ![](https://img-blog.csdnimg.cn/20190420112822376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 3. 二维行程编码 ![](https://img-blog.csdnimg.cn/20190420112836674.png) 4. 带指针的二维行程编码 ![](https://img-blog.csdnimg.cn/20190420112849656.png) ![](https://img-blog.csdnimg.cn/20190420112900448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 优点：有效地计算多边形的数量特征 缺点： - 矢/栅正反变换还不理想 - 建立四叉树耗时 - 修改麻烦 - 不直接体现物体之间的拓扑关系 - 滑动变异 - 失去了内在的相关性 5. 链式编码 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190420112915384.png) ![](https://img-blog.csdnimg.cn/20190420112924164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) ![](https://img-blog.csdnimg.cn/20190420112940480.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 8、矢量数据结构** 地理实体 点实体：具有特定的位置而没有长度的实体 线实体：具有长度的实体 特征： 长度：从起点到终点的总长； 弯曲度：用于表示像道路拐弯时弯曲的程度。 方向性：如水流方向,上下游; 公路,单双向之分。 面状实体：又称为多边形、区域等，水对湖泊、岛屿、地块等一类现象的描述 地理实体需要描述的内容： 编码 位置 类型 行为 属性 说明 时间维描述 关系 矢量数据结构定义 通过记录坐标的方式尽可能精确地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。特点：定位明显，属性隐含 获取方式 外业测量 栅格数据转换 跟踪数字化 组织方式 多边形矢量编码 实体式数据结构 只记录空间对象的位置坐标和属性信息，不记录拓扑关系 优点： 结构简单、直观、易实现 缺点： 相邻多边形的公共边界被数字化并存储两次 缺少多边形的邻接信息 处理岛或洞等嵌套问题较麻烦 区别于矢量的简单数据结构,矢量的拓扑空间数据结构的特点是： 点是相互独立的，点连成线，线构成面； 每条线始于起始结点，止于终止结点，并与左右多边形相邻接。 矢量的拓扑空间数据结构主要有： 索引式 双重独立编码结构 链状双重独立编码结构等。 2. 索引式数据结构 将坐标对以顺序方式存储，由点索引与边界线号相联系，以线索引与各多边形相联系，形成树状索引结构 ![](https://img-blog.csdnimg.cn/20190420113037878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) ![](https://img-blog.csdnimg.cn/20190420113047593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) - 优点： 1. 消除数据的冗余和不一致 2. 邻接信息、岛信息可通过查找公共弧段号查询 - 缺点： 1. 表达拓扑关系繁琐 2. 以人工建立编码表，工作量大，易出错 3. 双重独立式（DIME） 美国人口统计局研制用来进行人口普查分析和制图的，以城市街道为编码的主体 ![](https://img-blog.csdnimg.cn/20190420113058805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) - 结点与结点或面域与面域之间是邻接关系。 - 节点与线段或面域与线段之间为关联关系。 4. 链式双重独立式 将若干直线段合为一个弧段(或链段)，每个弧段可以有许多中间点。 ![](https://img-blog.csdnimg.cn/20190420113109643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 特点：拓扑关系明确，也能表达岛信息，而且以弧段为记录单位，满足实际应用需要。 9、矢量与栅格的比较与选择** 选择的原则： 要素还是位置 可获取的数据 定位要素的必要精度 需要什么类型的要素 需要什么类型的拓扑关系 所需空间分析类型 生产地图类型 栅格结构：大范围小比例尺的自然资源、环境、农林业等区域问题的研究。 矢量结构：城市分区或详细规划、土地管理、公用事业管理等方面的应用。 10、矢栅一体化 概念 将矢量面向目标的方法和栅格象元充填的方法结合起来， 采用填满线状目标路径和充填面状目标空间的方法 作为一体化数据结构的基础 点、线、面状地物均采用面向目标的描述方法，因此它保持了矢量的特性，而象元空间充填表达建立了位置与地物的联系，使之具有栅格的性质。 以矢量的方式来组织栅格数据的数据结构。 三个约定 点状地物仅有空间位置，没有形状和面积，在计算机内部仅有一个位置数据。 线状地物有形状但没有面积，在计算机内部需要用一组象元填满整个路径。 面状地物具有形状和面积，在平面上的投影是由边界包围的空间和一组填满路径的象元表达的边界组成。 细分网格法 一体化数据结构是基于栅格的，表达目标的精度受栅格尺寸的限制，可利用细分格网法提高数据的表达精度。 矢栅一体化数据结构设计 ** 线性四叉树(Morton)是基本数据格式 三个约定作为设计点、线、面数据结构的基本依据 细分格网法保证足够精度。 11、镶嵌数据结构**.采用规则或不规则的小面块集合来逼近自然界不规则的地理单元，适合于对连续变化场景的地理现象进行抽象。 **.小面块之间不重叠且能完整铺满整个地理空间。 **.分为规则镶嵌数据模型和不规则镶嵌数据模型。 规则镶嵌数据模型* 用规则的小面块集合来逼近自然界不规则的地理单元。 在实际应用中，普遍采用正方形或矩形进行地理空间的划分。此时的规则镶嵌数据模型就转化为栅格数据模型。 不规则镶嵌数据模型 有限离散的观测样点来表示某地理现象的空间分布规律时，适合于采用不规则镶嵌数据模型。 最典型的不规则镶嵌数据模型有Voronoi图（也称Thiessen多边形）和不规则三角网（Triangular IrregularNetwork，简称TIN）模型。 Thiessen多边形构造** 样本点之间最近样本点的连线。 最邻近的点 外接圆范围内不含有其它离散点 凸四边形 对每个三角形作中垂线。 相邻三角形外心（外接圆圆心）的连线或三角形边垂直平分线与图廓线构成泰森多边形。泰森多边形和Delaunay三角网互为偶图。 特征 每个泰森多边形内仅含有一个离散点； 组成多边形的边总是与两相邻样点的连线垂直，泰森多边形内的点到相应离散点的距离最近； 泰森多边形边上的点到其两边的离散点的距离相等。 2. 不规则三角网 - 三角形大小随样点密度的变化自动变化，所有样点都称为三角形的顶点，当样点密集时生成的三角形小，而样点较稀时则三角形较大。 - 任何一个Delaunay三角形的外接圆不能包含其他任何点在该包围的内部。 12、三维数据结构*栅格：将地理实体的三维空间分成细小单元——体元。**普遍用八叉树 **矢量：x，y，z，抽象为点、线、面、体，面构成体。 常用三维边界表示 八叉树结构 依次递归运算，直到每个子区域均为单一值为止。 三维边界表示法 顶点表： 用来表示多面体各顶点的坐标 边表：指出构成多面体某边的两个顶点","tags":[]},{"title":"GIS复习【II】","date":"2021-07-22T09:54:48.922Z","path":"2021/07/22/GIS复习【II】/","text":"目录3、地理空间信息描述4、地理信息数字化描述方法5、空间数据的类型和关系 ————————————————————正文—————————————————————- 3、地理空间信息描述1、地球空间模型 地球的自然表面 地球是一个近似球体，自然表面是一个极其复杂的不规则曲面。 水准面 假设当海水处于完全静止的平衡状态时，从海平面延伸到所有大陆下部，而与地球重力方向处处正交的一个连续、闭合的曲面 海水有潮汐，时高时低，所以水准面有无数个。 水准面的特性是处处与铅垂线相垂直。 不能用数学公式表达 大地体 被大地水准面所包围的形体 大地水准面：通过平均海水面的一个水准面 地球椭球体 起伏是微小的，且形状接近一个扁率极小的椭圆绕短轴旋转所形成的规则椭球体 说明： 视为球体：在制作小比例尺地图时（小于1:500万），因缩小程度很大，可以把地球视为球体，忽略地球扁率。计算更简单，半径约为6371千米。 视为椭球体：制作大比例尺地图时（大于1:100万），为保证精度，必须将地球视为椭球体。 参考椭球体 在某一局部，与大地水准面符合得最好的一个地球椭球体 基准面 地心基准面：使用地球的质心作为原点，使用最广泛的是 WGS 1984 区域基准面：特定区域内与地球表面吻合，大地原点是参考椭球与大地水准面相切的点，例如Beijing54、Xian80 总结 练习题2.1相对同一地理位置，不同的大地基准面，它们的经纬度坐标一样吗？地球椭球体与大地基准面之间的关系是一对一还是一对多？ 答：相对同一地理位置，不同的大地基准面，它们的经纬度坐标是有差异的。椭球体与大地基准面之间的关系是一对多的关系。因为基准面是在椭球体的基础上建立的，但椭球体不能代表基准面，同样的椭球体能定义不同的基准面。 2、地理空间坐标系 球面坐标系统 天文地理坐标系 大地地理坐标系 意义：GIS中的空间数据是地球表层的数据，即使把地球表面看成是一个椭球面，球面坐标也难以计算距离、方向、面积等参数，需将球面坐标转换成平面坐标，形成平面直角坐标 大地地理坐标系 大地测量中以参考椭球面为基准面建立起来的坐标系。 地心大地坐标系 参心大地坐标系 平面直角坐标系统 3、地图投影 定义（什么是） 将地球椭球面上的点映射到平面上的方法 过程（怎么进行） 投影的实质：经纬度坐标 —&gt; 笛卡儿平面直角坐标系 分类（有哪些） 投影面形状 方位 圆锥 圆柱 投影面位置 正轴 斜轴 横轴 投影变形 长度 面积 角度 等距投影：沿某一特定方向上的距离不变。 等角投影：投影前后角度不变。 等积投影：投影前后面积不变。 选择（哪个合适） 各国家的地理信息系统投影—-与该国基本地图系列所用的投影系统一致 各比例尺GIS投影—-与相应比例尺的主要信息源地图所用的投影一致 各地区GIS投影—-与所在区域适用的投影一致 所用投影以等角投影为宜（形状不失真） 各种地理信息系统一般以一种或两种（至多三种）投影系统为其投影坐标系统，以保证地理定位框架的统一 常用投影 高斯—克吕格投影（横轴等角切椭圆柱投影）： 1：50万、 1：25万、1：10万、1：5万、1：2.5万、1：1万、1：5000 兰勃特Lambert投影（正轴等角割圆锥投影） 1：100万 4、地图对地理空间的描述 空间对象 点：有位置，无宽度和长度；抽象的点线：有长度，但无宽度和高度；用来描述线状实体 面：具有长和宽的目标；通常用来表示自然或人工的封闭多边形；一般分为连续面和不连续面 连续面：等值线表示。可以根据等值线的疏密，判断制图对象的变化趋势和分布特征 不连续面：用面状符号表示，符号的轮廓线表示其分布位置和范围，轮廓线内的颜色、网纹、或说明符号表示其质量特征。 2.地图的分类 内容：普通、专题 比例尺 大：&gt; 1:10万 中：1:100万 &lt; &amp;&amp; &lt;1:10万 小：&lt; 1:100万 5、遥感影像对地理空间的描述 卫星遥感可以覆盖全球的每一个角落，航空遥感可以快速获取小范围的详细资料。 遥感影像对空间信息的描述主要是通过不同的颜色和灰度来表示的。 地物的结构、成分、分布等不同，其反射光谱特性和放射光谱特性也各不相同，传感器记录的个种地物在某一波段的电磁辐射发射能量也各不相同，在遥感影像上表现为不同的颜色和灰度信息。 综上，通过遥感影像可以获取大量的空间地物的特征信息。 4、地理信息数字化描述方法对地理信息进行数字化描述，就是要使计算机能够识别地理事物的形状。 计算机显式描述空间实体（栅格数据结构） 河流：栅格中的一系列像元。这些像元都给予相同的编码值或者用相同的颜色、符号、数字、灰度值来表示。 PS：每一个地理实体的形态都是由栅格中的一组像元来构成。 计算机隐式描述空间实体（矢量数据结构） 河流：定义了始点和终点的线及某种连接关系来描述 PS：地理实体的形状和位置由一组坐标对所确定。 5、空间数据的类型和关系 空间数据的分类 空间数据按数据结构分类：矢量数据、栅格数据等 按属性分为： 空间定位数据、非空间属性数据 按几何特征分为：点、线、面、体 空间数据的基本特征 空间：空间对象的位置及与相邻对象的空间关系或拓扑关系 属性：空间对象的专题属性 时间：空间对象随着时间变化引起的空间、属性的变化 空间数据的拓扑关系 拓扑性质：图形保持连续状态下变形，但图形关系不变 拓扑变换：任意拉伸，压缩，但不能扭转或折叠 拓扑元素 点：孤立点、线的端点、面的首尾点、链的连接点。 线：两结点之间的有序弧段，包括链、弧段和线段。 面：若干弧段组成的闭合多边形。 关系分类 拓扑邻接：同类元素之间的拓扑关系 拓扑关联：不同类元素之间的拓扑关系 拓扑包含：空间中不同类或同类但不同级元素之间的拓扑关系（一般只谈面状要素的包含关系） 拓扑连通：空间图形中弧段之间的拓扑关系。 拓扑关系表 ![](https://img-blog.csdnimg.cn/20190420092802745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 点、线、面三种要素之间的拓扑关系 拓扑关系的意义 可以确定一种地理实体相对于另一种地理实体的空间位置关系，这种空间关系不随地图投影而变化； 有利于空间要素的查询 作为工具，重建地理实体。 练习题2.1 如何为地理实体建立可用于确定特定位置的坐标系？ 答： 如何建立地球表面的几何模型？基于地球表面模型，怎么逐步建立坐标系？为什么要进行地图投影？ 答：地球表面是曲面，地图是平面的，他们之间需要映射。这种映射就是投影 地理空间实体的三要素有什么？他们之间的拓扑关系是怎么样的？ 答：点、线、面。关系：邻接、关联、包含、连通 空间数据的基本特征？地理信息的数字化描述方法是什么？ 答：空间特征、属性特征、时间特性。显性描述（栅格）和隐性描述（矢量） 什么是拓扑性质；拓扑变形包括什么? 答：性质：图形保持连续状态下变形，但图形关系不变。变形：任意拉伸，压缩，但不能扭转或折叠 拓扑邻接、拓扑关联； 答：拓扑邻接：同类元素之间的拓扑关系。拓扑关联：不同类元素之间的拓扑关系 空间实体抽象三个层次。 答：空间概念数据模型、空间逻辑数据模型、物理数据模型","tags":[]},{"title":"GIS复习【I】","date":"2021-07-22T09:54:48.920Z","path":"2021/07/22/GIS复习【I】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录1、GIS概念2、GIS构成3、GIS的功能及应用 —————————————————-正文—————————————————— 1、GIS概念一、数据与信息 数据 通过数字化或记录下来可以被鉴别的数字、文字、符号、声音、图象等符号。 信息： 用数字、文字、符号、语言等介质来表示事件、事物、现象等的内容、数量或特征，向人们提供现实世界新的事实和知识，是生产、建设、经营、管理、分析和决策的依据。 关系 数据是信息的载体 信息是数据的内涵与解释 形与质的关系 只有数据对实体行为产生影响才成为信息，数据只有经过解释才有意义，成为信息。 二、地理信息和地理信息系统 地理信息 地理信息是有关地理实体的性质、特征和运动状态的表征和一切有用的知识，是对表达地理特征与地理现象之间关系的地理数据的解释。 特性： 空间分布性 数据量大 信息载体的多样性 地理信息系统 在计算机硬件、软件系统支持下，对整个或部分地球表层（包括大气层）空间中的有关地理分布数据进行采集、存储、管理、运算、分析、显示和描述的技术系统。 GIS定义的理解 物理外壳：计算机的技术系统 操作对象：空间数据和属性数据 技术优势： 混合数据结构和有效的数据集成 独特的地理空间分析能力 快速的空间定位搜索和复杂的查询功能 强大的图形创造和可视化表达手段 地理过程的演化模拟和空间决策支持功能 2、GIS构成1、基本硬件构成（单机） 2、GIS硬件组成 局域网 广域网 3、GIS软件组成 4、GIS数据（空间数据、属性数据） 系统分析与处理的对象、构成系统的应用基础 5、“3S”关系 3、GIS的功能及应用1、GIS基本功能 数据采集与编辑 数据存储与管理 数据处理和变换 空间分析和统计 产品制作与显示 二次开发和编程 数据处理： 数据变换： 投影变换、几何纠正、比例尺缩放、误差改正和处理 数据重构： 数据拼接、裁剪、数据压缩、结构转换、格式转换 数据抽取： 类型选择、窗口提取、布尔提取、空间内插 空间分析和统计： 路径分析 生成数字高程模型 2、应用领域 测绘制图 资源管理 城乡规划 国土监测 环境保护 国防军事 练习题1.1 地理信息系统形成于20世纪（60年代） 我国的GIS发展自20世纪（70年代初）起步 世界上第一个地理信息系统起步于（加拿大） （MAPGIS）是中国的 GIS脱胎于（地理学）","tags":[]},{"title":"GIS程序设计 知识总结","date":"2021-07-22T09:54:48.917Z","path":"2021/07/22/GIS程序设计 知识总结/","text":"GIS程序设计简答1. 开发模式，开发软件的特点，概念 独立开发： 定义：不依赖于任何GIS工具软件，从空间数据的采集、编辑到数据的处理分析及结果输出，所有的算法都由开发者独立设计，然后选用某种程序设计语言，如VC++、VB、Delphi、C++ Builder等，在一定的操作系统平台上编程实现。 特点： 无需依赖任何商业GIS工具软件，减少了开发成本 综合程度和操作效率最高 单纯二次开发： 定义：在宏语言中调用DLL库，定义GIS系统工具不提供或不支持的功能， 特点： 功能弱，程序不美观，开发收到限制 增加学习负担 集成二次开发： 定义：利用专业GIS工具软件或其提供的组件来实现GIS的基本功能，采用可视化开发工具，进行集成开发。集成二次开发目前主要有OLE／DDE方式和组件式方式两种。 特点： GIS工具软件能够提供成熟的功能。例如：空间数据库存储、空间分析等 高效，便捷，不需要从底层学习具体的实现原理，易上手。 1. 基于arcengine或者arcobject 2. 基于com（原理） 2. 接口及类：特，用，概，接口应用 接口的特点： 1. 接口的多态性：许多不同的类可以支持相同的接口 2. 接口的继承性：所有的子类都继承了父类的接口 面向接口编程： 接口定义了能做什么，类定义了该怎么做。类实现了接口中的方法。 接口描述了一系列外部可见操作 接口具有类内置的一组属性和方法 Com类代码： 接口模块：定义方法和属性 类模块：实现方法和属性 COM 对象的接口是抽象的，接口与类不同。因为接口没有 任何的实现，所以不能通过自身实例化。因为接口没有任何的实现，所以不能通过自身实例化。接口由具体的类来实现由具体的类来实现，功能用接口抽象地模拟，并且用类去真正实现。 地图接口 1. ILayer接口:所有图层类都可以实现该接口，定义了所有图层公共的方法和属性。 - Name属性:返回图层名称； - MaximumScale属性:显示或设置图层可以出现的最大比例尺； - MinmumScale属性:显示或设置图层可以出现的最小比例尺； - ShowTips属性：指示当鼠标放在图层中某个要素上时，是否出现Tips; - SpatialReference属性：设置图层的空间参考。 2. IFeatureLayer接口:主要用于设置要素图层的数据源（FeatureClass） - DataSourceType属性：返回图层的数据源类型； - Search方法：通过2个参数，过滤器（IQueryFilter类型的对象）和布尔值（用于返回要素游标是否循环，返回一个Icursor对象） IFeatureLayer接口继承自Ilayer接口，IFeatureClass接口继承自Iclass接口。 FeatureLayer可以创建自己的对象，FeatureClass不行 类 Version类库：ArcEngine 10.0新出的类库，包含里将独立应用程序绑定到特定的ArcGIS系列产品的函数和方法。 System：ystem库是ArcGIS框架中最底层的一个库，它包含了一些被其他库使用的一些基础组件。 SystemUI：SystemUI库定义了一些在ArcGIS中被用户界面组件使用的类型。象ICommand和ITool这样的接口就在这里定义。 Geometry：几何库包含了核心的几何对象，比如点，面，线等。在几何库中还定义和实现了空间参考的对象，包括投影坐标系和几何坐标系。 Display：显示库包含了支持在输出设备上显示图形的组件，屏幕显示、符号、颜色、显示交互（Feedback)等都在这个库中定义。 Server：提供了连接、管理ArcGIS Server的核心类，如IServerObjectManager、IServerObject等，其他类库的对象可以通过ArcGIS Server的IServerContext进行远程创建。 Output：提供了将MapControl和PagelayoutControl中的地图输出到打印机以及其他设备文件中。 3. 对象模型图：类和关系，分别有什么特点 类 抽象类：不能用于创建对象，对子类例程进行了规定（通过类型继承）。 普通类：不能直接创建对象，但可以作为另一个类的属性或者通过另一个类的实例化来创建对象。 组件类：可以直接创建对象。 关系 关联关系：表示类之间的关系。关联的两端都定义了多样性。 组成关系：是一种“整体类”对象控制着“部分类”对象的生命期关系。 类型继承关系：定义共享父类的属性和方法，同时又具有了自己独特的属性和方法的特定对象类。 实例化关系：表示某个类的对象具有创建另一个类的对象的方法。 N元关系：表示两个以上的类相互关联。在各个关联分支的交叉点上放置一个菱形。 多样性关系：是对能于另一个对象关联的对象数目的一种限制。关联和组成关系的两端都定义了多样性。 抽象类(AbstractClass)： 不能创建或实例化 抽象类永远不能有实例 为子类定义了泛化（general） 子类集成了抽象类的接口 抽象类的OMD 符号: 2维灰色矩形 普通类/可实例化类 (Class) 不能创建或实例化 抽象类永远不能有实例 为子类定义了泛化（general） 子类集成了抽象类的接口 IRow pNewRow； ITable pTable; pNewRow = pTable.CreateRow(); IRow row = table.CreateRow(); 实例化类的OMD符号： 3维白色的矩形 组件类/可创建的类(CoClass) 可以创建:使用 New关键字 1IMap pmap = new Map(); 实例化: 从其它对象获得 12Imap pMap;pMap = m_MapDocument.get_Map(i); 可创建类的OMD符号：3维灰色矩形 AE控件有哪些，分类特点 制图控件: MapControl 和PageLayoutControl 框架控件: TOCControl（内容表控件） 和ToolbarControl(工具条控件)–（buddy控件捆绑） 许可控件：LicenseControl（启动时执行License初始化） 符号控件:SymbologyControl Reader Control: ReaderControl和ReaderControl 三维控件：GlobeControl和SceneControl 矢量数据集相关类的关系 矢量数据数据的加载，分析，查询 接口： 1. **IWorkspaceFactory**：创建工作工厂 2. **IWorkspace**：工作化工作空间 3. **IFeatureWorkspace**：接口转换为要素工作空间 4. **IFeatureClass**：创建featureClass 5. **IFeatureLayer**：创建要素图层 6. **IMap**：接收AxMapControl中的地图对象 类： ShapefileWorkspaceFactory：作为子类创建工作空间 FeatureLayer：创建要素图层用于接收打开的shpfile文件的featureClass，作为图层，只是表现形式，真正的数据在FeatureClass中。 FeatureClass是从Dataset继承过来的,FeatureClass是有空间数据字段的数据集。 程序流程（简答）1. 数据访问，添加矢量矢量加载： 获取文件路径和文件名称 创建地理空间工厂WorkspaceFactory（怎么创建） 实例化地理空间Workspace（怎么实例化） 获取FeatureClass 创建要素图层FeatureLayer 为要素图层定义数据集FeatureClass 添加至地图控件 刷新地图视图 2. 空间数据显示—图层渲染 1. 抽象类：Symbol，MarkerSymbol，LineSymbol，FillSymbol 2. 组件类： 1. RgbColor：颜色 2. SimpleMarkerSymbol，SimplelineSymbol，SimplefillSymbol：简单点线面符号 3. SimpleRenderer：简单渲染 实例化ISimpleMarkerSymbol，提供简单点符号 实例化ISimpleRenderer，提供简单渲染器 获取渲染图层赋值给IGeoFeatureLayer，提供要素图层对成员控制地理特征渲染的入口,获取渲染图层 调用pGeoFeatureLayer.Renderer属性赋值渲染器 刷新地图视图 3. 元素添加至地图 获取pagelayerout对象、活动视图pActiveView 、图形容器pGraphicsContainer、地图窗口MapFrame 创建UID对象，设置value 通过MapFrame的CreateSurroundFrame(uid,null)方法创建mapSurroundFrame 实例化一个区域几何envelope（包裹元素的盒子）。通过PutCoords(xmin, ymin, xmax, ymax)方法设置地图上的位置 通过mapSurroundFrame获取Element，设置框架的几何体属性Geometry为区域几何对象envelope 通过图形容器pGraphicsContainer的AddElement(Element，ZOrder)方法把地图要素添加地图布局。 刷新视图。 接口： IGraphicsContainer：管理map上的Element对象，获取图形容器 IMapFrame：访问控制地图元素对象的成员 IMapSurroundFrame：获取或更新存储在帧中的环绕对象（指北针、比例尺条或图例） IEnvelope：地物的外接矩形，用来放置元素。 IElement：通过这一属性设置该元素的外接矩形在地图上的位置。所有图形元素和框架元素都实现的接口，可以确定元素的Geometry属性。 类： UID用来设置元素类型的编码 MapFrame： 用于显示地图的图形元素。 MapSurroundFrame：用于显示地图包围的图形元素。 Envelope：包络线，是每个几何形体的最小外接矩形。每个Geometry都拥有一个Envelope Element：抽象类 12345678910111213141516171819202122232425public void add(string value,double xmin,double ymin, double xmax, double ymax)&#123; //获取图形容器 IGraphicsContainer graphicsContainer = pageLayoutControl.PageLayout as IGraphicsContainer; //根据MapSurround的uid，创建相应的MapSurroundFrame和MapSurround UID uid = new UID(); uid.Value = value; IMapFrame mapFrame = pageLayoutControl.PageLayout as IMapFrame; IMapSurroundFrame mapSurroundFrame = mapFrame.CreateSurroundFrame(uid, null); //为要素实例化一个区域几何。元素的外接矩形 envelope = new Envelope() as IEnvelope; envelope.PutCoords(xmin, ymin, xmax, ymax); //获取Element，用来设置框架的几何体属性 IElement eement = mapSurroundFrame as IElement; //geometry属性控制区域几何在地图上的位置 element.Geometry = envelope; graphicsContainer.AddElement(element, 0); activeView.Refresh(); pagelayoutcontrol.Refresh();&#125; 4. 属性查询步骤： 获取数据源FeatureClass 循环给每一列写字段名 获取查询返回的游标，null代表没有查询条件，返回整个表 用IFeature接收指针指向的数据 将指针指向第一个要素属性行 如果pFeature不为空则循环7，8，9步 获取表中的新行，并将引用赋值给DataRow 为每一个属性单元格赋值 游标指向下一行要素并重新赋值给pFeature 将DataTable赋值给dataGridView的数据源 类： QueryFilter：过滤数据通过属性值或者属性之间的关系 QueryDef：代表了数据库中基于一个或多个表、要素类的进行的属性查询，通过这个对象，用户可以在多个表间建立连接，并且保证在这个连接基础上的查询可以实现。 FeatureCursor：普通类，通过pFeatureClass.Search(filter, false);实例化 接口： IFeatureClass：数据源 IQueryFilter：用于属性查询 IFeatureCursor：查询返回的游标 IFeature：要素，返回游标中要素集单位 5. 空间查询步骤： 获取pFeatureLayer 实例化过滤器pSpatialFilter 创建geometry，用来装载框选范围 将框选几何geometry赋给pSpatialFilter 设置空间范围的查询条件（从空间查询窗体获得） 实例化查询接口pfeatureSelection 调用查询方法SelectFeatures(过滤器, esriSelectionResultEnum.esriSelectionResultNew, false);实现高亮 刷新图层 接口： IFeatureLayer：当前的要素图层，用于接口转换 ISpatialFilter：过滤器，用来设置空间范围的查询条件 IGeometry：几何类型，获取框选范围 IFeatureSelection：查询接口，用于查询，没有返回值，实现高亮 类： FeatureLayer：组件类，要素图层 SpatialFilter：组件类，过滤器 Geometry：普通类，通过mapControl.TrackRectangle();实例化，几何类型 程序设计题1. 面向接口的编程及接口转换2. 接口的继承3. 图层的显示及渲染123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/////Shp///OpenFileDialog pOpenfileDialog = new OpenFileDialog();if (pOpenfileDialog.ShowDialog() == DialogResult.OK)&#123; string path = pOpenfileDialog.FileName; bool shp = path.EndsWith(&quot;.shp&quot;); if (shp) openShpFile(path);&#125;private void openShpFile(string file)&#123; int index = 0; //获取最后一个“\\\\”时的索引位置 index = file.LastIndexOf(&quot;\\\\&quot;); //获得shp文件的路径 string filePath = file.Substring(0, index); //获得shp文件名 string fileName = file.Substring(index + 1, file.Length - (index + 1)); //由工作空间工厂创建shp工作空间工厂类 IWorkspaceFactory pWorkspaceFactory = new ShapefileWorkspaceFactory(); //打开工作空间 IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(filePath, 0); //转换工作空间为要素工作空间 IFeatureWorkspace pFeatureWorkspace = pWorkspace as IFeatureWorkspace; //打开要素类 IFeatureClass pFC = pFeatureWorkspace.OpenFeatureClass(fileName); //创建要素图层 IFeatureLayer pFLayer = new FeatureLayer(); //设置图层的featureclass为上面打开的文件 pFLayer.FeatureClass = pFC; //设置图层的名称 pFLayer.Name = pFC.AliasName; //转换featurelayer为layer ILayer pLayer = pFLayer as ILayer; IMap pMap = mapControl.Map; //添加图层 pMap.AddLayer(pLayer); //刷新 mapControl.ActiveView.Refresh();&#125;/////渲染/////简单渲染，点符号public static void easy_point(string filename, IRgbColor point_rgb, int width)&#123; //实例化ISimpleFillSysmbol变量, 提供简单的填充符号类型 ISimpleMarkerSymbol pSimplemarkerSymbol = new SimpleMarkerSymbol(); pSimplemarkerSymbol.Color = point_rgb; pSimplemarkerSymbol.OutlineSize = width; //实例化简单渲染变量 ISimpleRenderer pSimpleRender = new SimpleRenderer(); //设置pSimpleRender的符号样式 pSimpleRender.Symbol = pSimplemarkerSymbol as ISymbol; Render_tool(pSimpleRender, filename);&#125;private static void Render_tool(ISimpleRenderer pSimpleRenderer, string filename)&#123; //提供要素图层对成员控制地理特征渲染的入口,获取渲染图层 IGeoFeatureLayer pGeoFeatureLayer = getGeoLayer(filename); if (pGeoFeatureLayer != null) //调用Renderer属性, 具体说明如何通过图层要素渲染器渲染图层 pGeoFeatureLayer.Renderer = pSimpleRenderer as IFeatureRenderer; mapControl.ActiveView.Refresh();&#125;public static IGeoFeatureLayer getGeoLayer(string layerName)&#123; ILayer pLayer; //定义图层 IGeoFeatureLayer pGeoFeatureLayer; //定义要素图层 for (int i = 0; i &lt; CSR_mapControl.LayerCount; i++) &#123; pLayer = CSR_mapControl.get_Layer(i); //若当前图层不为空且与与layerName的值相同 if (pLayer != null &amp;&amp; pLayer.Name == layerName) &#123; pGeoFeatureLayer = pLayer as IGeoFeatureLayer; return pGeoFeatureLayer; &#125; &#125; return null;&#125;/////Tiff/////工作空间实例化IWorkspaceFactory pRasterWsF = new RasterWorkspaceFactory();IWorkspace pWs = pRasterWsF.OpenFromFile(RasterPath, 0);IRasterWorkspace pRasterWs = pWs as IRasterWorkspace;IRasterDataset pRasterDS = pRasterWs.OpenRasterDataset(RasterName);//影像金字塔的判断和创建IRasterPyramid pRasterPyramid = pRasterDS as IRasterPyramid;if ((pRasterPyramid != null) &amp;&amp; (!pRasterPyramid.Present))&#123; pRasterPyramid.Create();&#125;//新建栅格图层IRasterLayer pRasterLayer = new RasterLayer();pRasterLayer.CreateFromRaster(pRasterDS.CreateDefaultRaster());IMap pmap = mapControl.Map;//加载显示pmap.AddLayer(pRasterLayer);mapControl.ActiveView.Refresh(); 4. 属性查询12345678910111213141516171819202122232425262728293031public static DataTable getFeatureLayerTable(IFeatureLayer pFeatureLayer)&#123; //获取数据源FeatureClass IFeatureClass pFeatureClass = pFeatureLayer.FeatureClass; DataTable dt = new DataTable(); for (int i = 0; i &lt; pFeatureClass.Fields.FieldCount; i++) &#123; //循环给每一列写字段名 dt.Columns.Add(pFeatureClass.Fields.get_Field(i).Name); &#125; //获取查询返回的游标，null代表没有查询条件，返回整个表 IFeatureCursor pFeatureCursor = pFeatureClass.Search(null, false); //将指针指向第一个要素属性行 IFeature pFeature = pFeatureCursor.NextFeature(); while (pFeature != null) &#123; //获取表中的新行，并将引用赋值给DataRow DataRow dataR = dt.Rows.Add(); for (int j = 0; j &lt; pFeatureClass.Fields.FieldCount; j++) &#123; //为每一个属性单元格赋值 if (pFeature.get_Value(j) == null) dataR[j] = pFeatureClass.ShapeType.ToString(); else dataR[j] = pFeature.get_Value(j); &#125; //游标指向下一行要素 pFeature = pFeatureCursor.NextFeature(); &#125; return dt;&#125; 5. 空间查询1234567891011121314IFeatureLayer pFeatureLayer = pLayer as IFeatureLayer;//实例化一个过滤器，用来设置空间范围的查询条件ISpatialFilter pSpatialFilter = new SpatialFilter();IGeometry geometry = mapControl.TrackRectangle();//将几何范围赋值给pSpatialFilterpSpatialFilter.Geometry = geometry;//设置空间范围的查询条件pSpatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;//实例化查询接口IFeatureSelection pfeatureSelection = pFeatureLayer as IFeatureSelection;//实现高亮pfeatureSelection.SelectFeatures(pSpatialFilter, esriSelectionResultEnum.esriSelectionResultNew, false);mapControl.Refresh();//地图刷新 分值 填空：1*15 选择：2*10 简答：基本概念、总结及功能流程 4*5 程序阅读：改错、对象模型图 5*3 程序设计：2*15","tags":[]},{"title":"GIS-Experiment3","date":"2021-07-22T09:54:48.916Z","path":"2021/07/22/GIS-Experiment3/","text":"ArcGIS 操作3第1步 裁剪要素地理处理 —&gt; ArcToolbox —&gt; 分析工具 —&gt; 提取分析 —&gt; 裁剪 第2步 拼接图层 地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 常规 —&gt; 追加 第3步 要素融合 地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 制图综合 —&gt; 融合 第4步 图层合并地理处理 —&gt; ArcToolbox —&gt; 分析工具 —&gt; 叠加分析 —&gt; 联合 第5步 图层相交地理处理 —&gt; ArcToolbox —&gt; 分析工具 —&gt; 叠加分析 —&gt; 相交 第6步 定义投影地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 投影和变换 —&gt; 定义投影 第7步 投影变换地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 投影和变换 —&gt; 要素 —&gt; 投影","tags":[]},{"title":"GeoServer发布WMS服务","date":"2021-07-22T09:54:48.914Z","path":"2021/07/22/GeoServer发布WMS服务/","text":"目录 准备 WMS WTMS 一、 准备1. 首先我们需要一些配置，进入根目录下面 2.进入data 3. 新建一个目录，名字随意 4. 创建shp和tif文件夹，shp发布WMS，tif用来发布WTMS 5. 先放进去一个shp文件和tif文件 6.安装版，在服务中打开geoserver服务，解压版运行start Geoserver 6. 打开GeoServer的网页端 7. 没有登录的在这里登陆一下 安装的时候设置的用户名和密码没有用，不知道为什么默认：账户：admin密码：geoserver 8. 先建一个工作区，设置为默认工作区，提交即可 开启这两个服务 二、 WMS1. 新建数据存储，选择数据源，保存 2. 发布 如果找不到这个页面，点击图层 -》新建图层 即可 3. 修改参数，保存 这里得定义SRS要和图层得坐标一样，否则会出现，结果中看不到矢量或者只能看到一部分得现象 4. 发布结束，预览 5. 由于本机SRS没有设置为3587，只能看到一部分 6. 修改SRS 7. 查看完整地图 三、 WTMS1. 在ArcMap中查看坐标代码 2. 制定新的Gridsets 3. 将自定义的Gridsets添加到常用，提交 4. 新建数据存储，选择geoTiff，保存 5. 发布，删掉别的切片规则 6. 切片 为none就是切完了 7. 查看切片结果","tags":[]},{"title":"esri loader + arcgis api 图层控制 + 筛选","date":"2021-07-22T09:54:48.912Z","path":"2021/07/22/esri loader + arcgis api 图层控制 + 筛选/","text":"功能 ID 筛选 #option-choose 清除筛选 #option-clean 显示隐藏控制 #option-visible 筛选函数中的layerDefinitoin控制筛选条件 js部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 我们需要在该组件装载之后做的事情都放在该方法里 mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.28&#x27; &#125;) this.createMap() &#125;, // 我们需要执行的方法都定义在该属性里 methods: &#123; createMap: function() &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;esri/geometry/Extent&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;dojo/query&#x27;, &#x27;esri/toolbars/navigation&#x27;, &#x27;esri/geometry/Point&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, Extent, ArcGISDynamicMapServiceLayer, query, Navigation, Point]) =&gt; &#123; var tjUAVurl = &#x27;http://localhost:6080/arcgis/rest/services/Eco/BJ_td_gd_nyd/MapServer&#x27; var map = new Map(&#x27;map&#x27;, &#123; extent: new Extent(&#123; xmin: 114.4134760856628, ymin: 40.13100080490112, xmax: 118.36547288894677, ymax: 41.64383821487438, spatialReference: &#123; wkid: 4326 &#125; &#125;), logo: false &#125;) var tjUAVLayer = new ArcGISDynamicMapServiceLayer(tjUAVurl) var tjUAVLayerLD = new ArcGISDynamicMapServiceLayer(tjUAVurl)// 筛选 map.addLayer(tjUAVLayer) // *************************************************************************************** // var that = this // 筛选 function btnLayerDefinitions() &#123; map.removeLayer(tjUAVLayer) var layerDefinitoin = [] layerDefinitoin[0] = &#x27;payMon_suz &gt; 20&#x27; tjUAVLayerLD.setLayerDefinitions(layerDefinitoin) map.addLayer(tjUAVLayerLD) that.opensuccess() &#125; // 清除筛选 function optinClean() &#123; map.removeLayer(tjUAVLayerLD) map.addLayer(tjUAVLayer) that.opensuccess() &#125; function btnVisible() &#123; if (that.options_power[2].label === &#x27;隐藏&#x27;) &#123; // 打开所有显示 var visible = [] for (var i = 0; i &lt; tjUAVLayer.layerInfos.length; i++) &#123; visible.push(i) &#125; tjUAVLayer.setVisibleLayers(visible) that.options_power[2].label = &#x27;显示&#x27; &#125; else &#123; // 关闭所有显示 visible = [-1] tjUAVLayer.setVisibleLayers(visible) that.options_power[2].label = &#x27;隐藏&#x27; &#125; that.opensuccess() &#125; // *************************************************************************************** // query(&#x27;#option-choose&#x27;).on(&#x27;click&#x27;, btnLayerDefinitions) query(&#x27;#option-clean&#x27;).on(&#x27;click&#x27;, optinClean) query(&#x27;#option-visible&#x27;).on(&#x27;click&#x27;, btnVisible) &#125;) &#125; &#125;","tags":[]},{"title":"esri loader + arcgis api 实现小部件","date":"2021-07-22T09:54:48.910Z","path":"2021/07/22/esri loader + arcgis api 实现小部件/","text":"template部分12345678910&lt;template&gt; &lt;el-row style=&quot;box-shadow: rgba(0, 0, 0, 0.1) 0px 2px 12px 0px;&quot;&gt; &lt;el-button type=&quot;&quot; icon=&quot;el-icon-plus&quot; circle class=&quot;zoomin&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;&quot; icon=&quot;el-icon-minus&quot; circle class=&quot;zoomout&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; icon=&quot;el-icon-thumb&quot; circle class=&quot;pan&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; icon=&quot;el-icon-full-screen&quot; circle class=&quot;fullmap&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;&quot; icon=&quot;el-icon-arrow-left&quot; circle class=&quot;beforePic&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;&quot; icon=&quot;el-icon-arrow-right&quot; circle class=&quot;afterPic&quot;&gt;&lt;/el-button&gt; &lt;/el-row&gt;&lt;/template&gt; js部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import * as esriLoader from &#x27;esri-loader&#x27;// import $ from &#x27;jquery&#x27;export default &#123; data() &#123; return &#123; xyText: &#x27;&#x27;, extent_tag: [ ], value: &#x27;&#x27;, // 选择的ID options_power: [&#123; value: &#x27;option-choose&#x27;, label: &#x27;筛选&#x27; &#125;, &#123; value: &#x27;option-clean&#x27;, label: &#x27;清除&#x27; &#125;, &#123; value: &#x27;option-visible&#x27;, label: &#x27;显示&#x27; &#125;, &#123; value: &#x27;setting-extent-xy&#x27;, label: &#x27;设置坐标&#x27; &#125;, &#123; value: &#x27;setting-extent&#x27;, label: &#x27;设置范围&#x27; &#125;], xy_zdy: &#123;&#125;, extent_zdy: &#123;&#125;, centerDialogVisible: false, centerDialogVisible_extent: false, checked: true &#125; &#125;, // 我们需要在该组件装载之后做的事情都放在该方法里 mounted() &#123; esriLoader.setDefaultOptions(&#123; version: &#x27;3.28&#x27; &#125;) this.createMap() &#125;, // 我们需要执行的方法都定义在该属性里 methods: &#123; createMap: function() &#123; esriLoader.loadModules([&#x27;esri/map&#x27;, &#x27;esri/geometry/Extent&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;dojo/query&#x27;, &#x27;esri/toolbars/navigation&#x27;, &#x27;esri/geometry/Point&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, Extent, ArcGISDynamicMapServiceLayer, query, Navigation, Point]) =&gt; &#123; var tjUAVurl = &#x27;http://localhost:6080/arcgis/rest/services/Eco/BJ_td_gd_nyd/MapServer&#x27; var map = new Map(&#x27;map&#x27;, &#123; extent: new Extent(&#123; xmin: 114.4134760856628, ymin: 40.13100080490112, xmax: 118.36547288894677, ymax: 41.64383821487438, spatialReference: &#123; wkid: 4326 &#125; &#125;), logo: false &#125;) var tjUAVLayer = new ArcGISDynamicMapServiceLayer(tjUAVurl) map.addLayer(tjUAVLayer) // *************************************************************************************** // var navToolbar = new Navigation(map) query(&#x27;.zoomin&#x27;).on(&#x27;click&#x27;, () =&gt; &#123; navToolbar.activate(Navigation.ZOOM_IN) &#125;) query(&#x27;.zoomout&#x27;).on(&#x27;click&#x27;, () =&gt; &#123; navToolbar.activate(Navigation.ZOOM_OUT) &#125;) query(&#x27;.pan&#x27;).on(&#x27;click&#x27;, () =&gt; &#123; navToolbar.activate(Navigation.PAN) &#125;) query(&#x27;.fullmap&#x27;).on(&#x27;click&#x27;, () =&gt; &#123; navToolbar.zoomToFullExtent() &#125;) query(&#x27;.beforePic&#x27;).on(&#x27;click&#x27;, () =&gt; &#123; navToolbar.zoomToPrevExtent() &#125;) query(&#x27;.afterPic&#x27;).on(&#x27;click&#x27;, () =&gt; &#123; navToolbar.zoomToNextExtent() &#125;) &#125;&#125; 效果图","tags":[]},{"title":"esri loader + Arcgis api 4.x加载 arcgis server 地图服务","date":"2021-07-22T09:54:48.908Z","path":"2021/07/22/esri loader + Arcgis api 4.x加载 arcgis server 地图服务/","text":"默认是加载4.x的api在线连接。1. template部分123&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt; 2. 导包部分 js和css自动导入最新版，所以不用再导入loadScript和loadCss1import &#123; loadModules &#125; from &#x27;esri-loader&#x27; 3. export接口部分123456789101112131415161718192021222324252627282930export default &#123; name: &#x27;web-map&#x27;, mounted() &#123; loadModules([&#x27;esri/map&#x27;, &#x27;esri/views/MapView&#x27;, &#x27;esri/layers/MapImageLayer&#x27;, &#x27;esri/geometry/Extent&#x27;, &#x27;esri/geometry/SpatialReference&#x27;], &#123; css: true &#125;) .then(([ArcGISMap, MapView, MapImageLayer, Extent, SpatialReference]) =&gt; &#123; const map = new ArcGISMap(&#123; // basemap: &#x27;osm&#x27;, logo: false &#125;) var dongURL = &#x27;http://localhost:6080/arcgis/rest/services/shopping/payMon_zenzhag/MapServer&#x27; var donglayer = new MapImageLayer(dongURL) map.add(donglayer) this.view = new MapView(&#123; container: this.$el, map: map, // center: [-118, 34], zoom: 8 &#125;) &#125;) &#125;, beforeDestroy() &#123; if (this.view) &#123; // destroy the map view this.view.container = null &#125; &#125;&#125;","tags":[]},{"title":"esri loader + Arcgis api 3.x加载 arcgis server 地图服务","date":"2021-07-22T09:54:48.906Z","path":"2021/07/22/esri loader + Arcgis api 3.x加载 arcgis server 地图服务/","text":"默认是加载4.x的api在线连接。使用3.x的api需要手动调用链接。1. template部分，需要绑定id，和纯js的相同123&lt;template&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;/template&gt; 2. 导包部分1import &#123; loadScript, loadCss, loadModules &#125; from &#x27;esri-loader&#x27; 3. export接口部分12345678910111213141516171819202122232425export default &#123; name: &#x27;web-map&#x27;, mounted() &#123; loadScript(&#123; url: &#x27;https://js.arcgis.com/3.28/&#x27; &#125;) loadCss(&#x27;https://js.arcgis.com/3.28/esri/css/esri.css&#x27;) loadModules([&#x27;esri/map&#x27;, &#x27;esri/geometry/Extent&#x27;, &#x27;esri/layers/ArcGISDynamicMapServiceLayer&#x27;, &#x27;dojo/domReady!&#x27;], &#123; css: true &#125;) .then(([Map, Extent, ArcGISDynamicMapServiceLayer]) =&gt; &#123; var tjUAVurl = &#x27;http://localhost:6080/arcgis/rest/services/shopping/payMon_zenzhag/MapServer&#x27; var map = new Map(&#x27;map&#x27;, &#123; // extent: extent1, logo: false &#125;) var tjUAVLayer = new ArcGISDynamicMapServiceLayer(tjUAVurl) map.addLayer(tjUAVLayer) &#125;) &#125;, beforeDestroy() &#123; if (this.view) &#123; // destroy the map view this.view.container = null &#125; &#125;&#125;","tags":[]},{"title":"","date":"2021-07-22T09:54:48.903Z","path":"2021/07/22/echarts绘制map，添加图表，符合ES6规范/","text":"效果图 1. template结构12345&lt;template&gt; &lt;div class=&quot;wrap&quot; style=&quot;position: relative; width: 100%&quot;&gt; &lt;div id=&quot;map&quot; style=&quot;width: 100%; height: 835px;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 2. 引用bj.json是北京市的json数据，不能暴露echarts官方的Amd规范的js文件，参考这篇 1234import * as esriLoader from &#x27;esri-loader&#x27;import $ from &#x27;jquery&#x27;import echarts from &#x27;echarts&#x27;import beijing from &#x27;../../assets/js/mapchart/bj.json&#x27; 3. export default 测试功能，虚拟数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346export default &#123; data() &#123; return &#123; geoCoordMap: &#123; 东城区: [116.418757, 39.937544], 西城区: [116.366794, 39.910309], 朝阳区: [116.486409, 39.991489], 丰台区: [116.286968, 39.863642], 石景山区: [116.170445, 39.974601], 海淀区: [116.280316, 40.039074], 门头沟区: [115.905381, 40.009183], 房山区: [115.701157, 39.735535], 通州区: [116.758603, 39.802486], 顺义区: [116.753525, 40.128936], 昌平区: [116.235906, 40.318085], 大兴区: [116.338033, 39.658908], 怀柔区: [116.607122, 40.524272], 平谷区: [117.112335, 40.244783], 密云区: [116.943352, 40.477362], 延庆区: [115.985006, 40.465325] &#125;, rawData: [ // [&quot;东城区&quot;,10,20,30], // [&quot;西城区&quot;,10,20,30], [&#x27;朝阳区&#x27;, 0.0544, 2.1299, 6.3964], [&#x27;丰台区&#x27;, 0.056, 1.892, 6.434], [&#x27;石景山区&#x27;, 0.043, 1.967, 5.842], [&#x27;海淀区&#x27;, 0.053, 2.143, 6.543], [&#x27;门头沟区&#x27;, 0.034, 1.907, 5.434], [&#x27;房山区&#x27;, 0.038, 2.231, 4.34], [&#x27;通州区&#x27;, 0.023, 2.201, 4.58], [&#x27;顺义区&#x27;, 0.037, 2.231, 5.21], [&#x27;昌平区&#x27;, 0.025, 2.542, 4.85], [&#x27;大兴区&#x27;, 0.043, 2.145, 3.82], [&#x27;怀柔区&#x27;, 0.032, 1.981, 4.74], [&#x27;平谷区&#x27;, 0.042, 1.992, 4.30], [&#x27;密云区&#x27;, 0.032, 2.090, 3.99], [&#x27;延庆区&#x27;, 0.046, 2.313, 3.84] ] &#125; &#125;, mounted() &#123; echarts.registerMap(&#x27;BJ&#x27;, beijing) esriLoader.setDefaultOptions(&#123; version: &#x27;3.31&#x27; &#125;) this.createMap(this) &#125;, methods: &#123; createMap: function (that) &#123; var myChart = echarts.init(document.getElementById(&#x27;map&#x27;)) var option = &#123; animation: false, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, geo: &#123; map: &#x27;BJ&#x27;, // silent: true, roam: true, zoom: 1.155, center: [116.366794, 40.400309], label: &#123; emphasis: &#123; show: false, areaColor: &#x27;#eee&#x27; &#125; &#125;, itemStyle: &#123; normal: &#123; areaColor: &#x27;#EECFA1&#x27;, borderColor: &#x27;#FFF&#x27; &#125;, emphasis: &#123; areaColor: &#x27;#C1CDC1&#x27; &#125; &#125; &#125;, series: [] &#125; function renderEachCity() &#123; option = &#123; xAxis: [], yAxis: [], grid: [], series: [], tooltip: &#123; trigger: &#x27;item&#x27;, axisPointer: &#123; type: &#x27;none&#x27; &#125; &#125; &#125; if (that.rawData !== undefined) &#123; that.rawData.forEach(function (dataItem, idx) &#123; console.log(idx) var geoCoord = that.geoCoordMap[dataItem[0]] var coord = myChart.convertToPixel(&#x27;geo&#x27;, geoCoord) idx += &#x27;&#x27; var inflationData = [] for (var k = 1; k &lt; 4; k++) &#123; inflationData.push(dataItem[k]) &#125; option.xAxis.push(&#123; id: idx, gridId: idx, type: &#x27;category&#x27;, name: dataItem[0], nameLocation: &#x27;middle&#x27;, nameGap: 3, splitLine: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisLine: &#123; onZero: false, lineStyle: &#123; color: &#x27;#666&#x27; &#125; &#125;, // data: xAxisCategory, data: [&#x27;二阶&#x27;, &#x27;一阶&#x27;, &#x27;b&#x27;], z: 100 &#125;) option.yAxis.push(&#123; id: idx, gridId: idx, splitLine: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisLine: &#123; show: false, lineStyle: &#123; color: &#x27;#1C70B6&#x27; &#125; &#125;, z: 100 &#125;) option.grid.push(&#123; id: idx, width: 30, height: 40, left: coord[0] - 15, top: coord[1] - 15, z: 100 &#125;) option.series.push(&#123; id: idx, type: &#x27;bar&#x27;, xAxisId: idx, yAxisId: idx, barGap: 0, barCategoryGap: 0, data: inflationData, z: 100, itemStyle: &#123; normal: &#123; color: function (params) &#123; var colorList = [&#x27;#F75D5D&#x27;, &#x27;#59ED4F&#x27;, &#x27;#4C91E7&#x27;] return colorList[params.dataIndex] &#125; &#125;, emphasis: &#123; label: &#123; show: false &#125; &#125; &#125; &#125;) &#125;, that.rawData) &#125; else &#123; console.log(&#x27;error&#x27;) &#125; myChart.setOption(option) &#125; setTimeout(renderEachCity, 0) function throttle(fn, delay, debounce) &#123; var currCall var lastCall = 0 var lastExec = 0 var timer = null var diff var scope var args delay = delay || 0 function exec() &#123; lastExec = (new Date()).getTime() timer = null fn.apply(scope, args || []) &#125; var cb = function () &#123; currCall = (new Date()).getTime() scope = that args = arguments diff = currCall - (debounce ? lastCall : lastExec) - delay clearTimeout(timer) if (debounce) &#123; timer = setTimeout(exec, delay) &#125; else &#123; if (diff &gt;= 0) &#123; exec() &#125; else &#123; timer = setTimeout(exec, -diff) &#125; &#125; lastCall = currCall &#125; return cb &#125; var throttledRenderEachCity = throttle(renderEachCity, 0) myChart.on(&#x27;geoRoam&#x27;, throttledRenderEachCity) myChart.setOption(option) myChart.on(&#x27;click&#x27;, function (e) &#123; console.log(e) // console.log(params); if (e.componentSubType === &#x27;bar&#x27;) &#123; $(&#x27;.tongJiTu&#x27;).remove() creatWrap() var divObj = document.createElement(&#x27;div&#x27;) $(divObj).addClass(&#x27;tongJiTu&#x27;) divObj.id = &#x27;zhuzhuang&#x27; var divX = getMousePos().x var divY = getMousePos().y $(divObj).css(&#123; width: 250, height: 300, border: &#x27;1px solid #ccc&#x27;, position: &#x27;absolute&#x27;, top: divY, left: divX &#125;).appendTo(&#x27;.wrap&#x27;) zhuZhuangTu(e) clearWrap(&#x27;.zhedang&#x27;) &#125; &#125;) // 获取横纵坐标 function getMousePos(event) &#123; var e = event || window.event var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft var scrollY = document.documentElement.scrollTop || document.body.scrollTop var x = e.pageX || e.clientX + scrollX var y = e.pageY || e.clientY + scrollY // console.log(x,y) return &#123; x: x, y: y &#125; &#125; // 生成柱状图 function zhuZhuangTu(e) &#123; var index = e.seriesIndex var infodata = [] for (var k = 1; k &lt; 4; k++) &#123; infodata.push(that.rawData[index][k]) console.log(infodata) &#125; var zhuzhuang = echarts.init(document.getElementById(&#x27;zhuzhuang&#x27;)) option = &#123; backgroundColor: &#x27;rgba(255,255,255,.6)&#x27;, legend: &#123; data: [&#x27;二阶&#x27;, &#x27;一阶&#x27;, &#x27;b&#x27;] &#125;, xAxis: [ &#123; type: &#x27;category&#x27;, data: [&#x27;二阶&#x27;, &#x27;一阶&#x27;, &#x27;b&#x27;] &#125; ], yAxis: [ &#123; splitLine: &#123; show: false &#125;, type: &#x27;value&#x27; &#125; ], series: [ &#123; type: &#x27;bar&#x27;, itemStyle: &#123; normal: &#123; color: function (params) &#123; var colorList = [&#x27;#F75D5D&#x27;, &#x27;#59ED4F&#x27;, &#x27;#4C91E7&#x27;] return colorList[params.dataIndex] &#125; &#125; &#125;, data: infodata &#125; ] &#125; zhuzhuang.setOption(option) &#125; // 生成遮挡层 function creatWrap() &#123; var zheDang = document.createElement(&#x27;div&#x27;) $(zheDang).addClass(&#x27;zhedang&#x27;).css(&#123; width: &#x27;100%&#x27;, height: &#x27;100%&#x27;, position: &#x27;absolute&#x27;, top: 0, left: 0, backgroundColor: &#x27;rgba(0,0,0,.3)&#x27; &#125;).appendTo(&#x27;.wrap&#x27;) &#125; // 去掉遮挡层 function clearWrap(id) &#123; $(id).click(function (e) &#123; // console.log(that); this.remove() $(&#x27;.tongJiTu&#x27;).remove() return false &#125;) &#125; &#125; &#125;&#125;","tags":[]},{"title":"arcgis server发布切片地图","date":"2021-07-22T09:54:48.901Z","path":"2021/07/22/arcgis server发布切片地图/","text":"和动态地图相比点击缓存 -》 使用缓存中的切片 -》 建议 -》 分析 -》 发布-》","tags":[]},{"title":"Arcgis api for js通过json添加点，显示弹框信息","date":"2021-07-22T09:54:48.899Z","path":"2021/07/22/Arcgis api for js通过json添加点，显示弹框信息/","text":"数据格式 12345&#123; &quot;china&quot;:[ &#123;&quot;id&quot;:&quot;1&quot;,&quot;city&quot;:&quot;上海&quot;,&quot;x&quot;:&quot;121.4648&quot;,&quot;y&quot;:&quot;31.2891&quot;&#125; ]&#125; 完整数据下载 模块&quot;esri/InfoTemplate&quot;, &quot;dojo/store/JsonRest&quot; 调用，弹框代码123456789101112131415161718192021222324map.on(&quot;load&quot;, () =&gt; &#123; var store = new JsonRest(&#123; target: &quot;china1.json&quot; &#125;); var infoTemplate = new InfoTemplate(&quot;$&#123;id&#125;&quot;, &quot;城市:$&#123;city&#125;&lt;/br&gt;X坐标:$&#123;X&#125;&lt;/br&gt;Y坐标:$&#123;Y&#125;&quot;); store.query(&#123; &quot;id&quot;: &quot;*&quot; &#125;).then(function (result, request) &#123; var items = result.china; // console.log(items); for (var i = 0; i &lt; items.length; i++) &#123; var attr = &#123; &quot;id&quot;: i, &quot;name&quot;: items[i].city, &quot;X&quot;: items[i].x, &quot;Y&quot;: items[i].y &#125;; var locPoint = new Point(items[i].x, items[i].y, new SpatialReference(&#123; wkid: 4326 &#125;)); var graphic = new Graphic(locPoint, markerSym, attr, infoTemplate); // markerSym为点符号样式 // 将图形添加到地图中 map.graphics.add(graphic) &#125; &#125;) &#125;)","tags":[]},{"title":"ArcGIS API for JavaScript 入门必读","date":"2021-07-22T09:54:48.897Z","path":"2021/07/22/ArcGIS API for JavaScript 入门必读/","text":"ArcGIS API for JavaScript 是 Esri公司根据js实现的地图方面的调用脚本。1. WebGIS必备: ArcGIS API for JavaScript（下文中用ArcJS代替） ArcGIS Sever（下文中用ArcSer代替） 2. ArcJS作用： 通过ArcSer的REST API调用地图服务，提供显示，查询，分析，缓冲区等功能。 调用ArcGIS Server的GP服务，得到分析结果 同时调用多个ArcGIS Server服务，实现服务聚合 3.入门路线 加载 小部件 查询 基础功能 分析渲染 此路线为博主学习路线。。 4. 源码（对你有帮助的话，请给一个小星星）giteegithub 4.学习链接API 3.X 加载 动态地图加载 加载动态图层 + 注册文件夹 闪烁Layer(js入门) 小部件 绑定小部件 鹰眼图 图例 查询 FindTask属性查询 QueryTask属性查询 QueryTask空间查询 QueryTask空间+属性查询 GraphicsLayer的属性查询 查询+echarts交互 QueryTask属性查询+空间查询（附样例源码） IdentifyTask查询（附样例源码） 基础功能 地理编码 地图打印 几何服务_缓冲区 交互画图1 交互画图2 具体坐标生成Graphic 分析 网络分析（最短路径） 网络分析（临近设施分析） 网络分析+路网数据（源码下载） 影像分析 缓冲区空间查询 GP–缓冲区 渲染 唯一值渲染 分类渲染 服务器分类渲染 扩展 卷帘 小操作 发布切片服务 通过json添加点，显示弹框信息 API 4.X 加载 动态地图加载api 4.x 小操作 联动","tags":[]},{"title":"Hello World","date":"2021-07-22T09:49:44.338Z","path":"2021/07/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]